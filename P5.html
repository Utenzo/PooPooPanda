<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Poo Poo Panda ‚Äî Single-file (versione base + nuove feature)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0d1117; }
    body { font-family: 'Segoe UI Emoji','Apple Color Emoji','Noto Color Emoji', system-ui, Arial, sans-serif; }
    #game-container { width:100vw; height:100vh; display:flex; align-items:center; justify-content:center; }
    .audio-unlock { position: fixed; inset: 0; display: none; align-items:center; justify-content:center; background: rgba(0,0,0,0.6); z-index: 999; }
    .audio-unlock > button { font-size: 18px; padding: 10px 14px; border-radius: 12px; border: 0; background: #0a7d33; color: #fff; box-shadow: 0 6px 16px rgba(0,0,0,0.35); cursor:pointer; }
    .hint { position: fixed; bottom: 8px; left: 8px; background: rgba(255,255,255,0.9); padding: 6px 8px; border-radius: 8px; font-size: 12px; z-index: 50; }
  </style>
</head>
<body>
  <div id="game-container"></div>
  <div id="audio-gate" class="audio-unlock"><button id="audio-btn">üîà Tocca per attivare audio</button></div>
  <div class="hint">Tocco/click per muovere ‚Ä¢ SPAZIO: üí© ‚Ä¢ N: üêã ‚Ä¢ S: üßú‚Äç‚ôÄÔ∏è ‚Ä¢ T: üåÄ</div>

  <!-- Phaser UMD -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.87.0/dist/phaser.min.js"></script>

  <script type="module">
  /*
   * PATCH (richieste utente):
   * ‚úÖ Landscape: UI sempre in vista + layout responsive (wrap) + banda UI ‚Äúfuori dal quadro di gioco‚Äù
   * ‚úÖ Messaggio sconfitta boss: non ‚Äúscoperto‚Äù, ma ‚Äúsconfitto dal bagnino‚Äù
   * ‚úÖ Bonus sempre in primo piano (depth alto)
   * ‚úÖ Pulsanti (spara/bonus/restart/menu) sempre in primo piano e fuori area giocabile
   * ‚úÖ Bottone ‚ÄúSpara‚Äù del boss pi√π comodo (grande, in basso a destra)
   * ‚úÖ Score live durante il gioco + classifica finale con nome (localStorage)
   * ‚úÖ Ali quando sali molto sopra l‚Äôacqua (Sea/Boss: ‚Äúvola‚Äù)
   */

  const Phaser = window.Phaser;
  const FONT = "Segoe UI Emoji, Apple Color Emoji, Noto Color Emoji, Arial, sans-serif";
  const GAME_VERSION = "v1.2.0 - Score + UI Safe + Landscape";

  // ===================== LAYOUT / UI SAFE AREA =====================
  function uiBandHeightFor(h){
    // banda UI pi√π alta su landscape bassi
    if (h <= 420) return 120;
    if (h <= 520) return 110;
    return 96;
  }
  function topHudHeightFor(h){
    return 60;
  }
  function playableRectFor(scene){
    const w = scene.scale.width, h = scene.scale.height;
    const top = topHudHeightFor(h);
    const band = uiBandHeightFor(h);
    return { x: 0, y: top, w, h: Math.max(120, h - top - band), top, band };
  }
  function setWorldBoundsToPlayable(scene){
    const pr = playableRectFor(scene);
    scene.physics.world.setBounds(0, pr.y, pr.w, pr.h);
    return pr;
  }

  function makeUIButton(scene, label, opts={}){
    const t = scene.add.text(0,0,label,{
      fontFamily: FONT,
      fontSize: opts.fontSize ?? 18,
      color: opts.color ?? '#fff',
      backgroundColor: opts.bg ?? '#444',
      padding: opts.padding ?? {left:10,right:10,top:6,bottom:6}
    }).setDepth(1000);
    t.setInteractive({ useHandCursor:true });
    return t;
  }

  function layoutButtonRow(scene, buttons, area){
    // area: {x,y,w,h} -> wrap su 1 o 2 righe se serve
    // mette bottoni centrati verticalmente nella banda
    const pad = 10;
    const maxW = area.w - pad*2;
    const lineH = 44;
    let x = area.x + pad;
    let y = area.y + Math.floor((area.h - lineH)/2);

    // prova 1 riga
    const widths = buttons.map(b=>b.displayWidth + 10);
    const total = widths.reduce((a,b)=>a+b,0) + (buttons.length-1)*8;
    const twoRows = (total > maxW);

    if (!twoRows){
      x = area.x + Math.max(pad, Math.floor((area.w - total)/2));
      for (let i=0;i<buttons.length;i++){
        const b = buttons[i];
        b.setPosition(x, y);
        x += (b.displayWidth + 10) + 8;
      }
      return;
    }

    // 2 righe: alterna / riempie
    const rows = [[],[]];
    let row = 0;
    for (const b of buttons){
      rows[row].push(b);
      row = 1-row;
    }
    const y1 = area.y + Math.floor((area.h - (lineH*2 + 8))/2);
    const y2 = y1 + lineH + 8;

    const placeRow = (btns, yy)=>{
      const ww = btns.map(b=>b.displayWidth+10);
      const t = ww.reduce((a,b)=>a+b,0) + (btns.length-1)*8;
      let xx = area.x + Math.max(pad, Math.floor((area.w - t)/2));
      for (let i=0;i<btns.length;i++){
        btns[i].setPosition(xx, yy);
        xx += (btns[i].displayWidth + 10) + 8;
      }
    };
    placeRow(rows[0], y1);
    placeRow(rows[1], y2);
  }

  function clampToPlayable(scene, img){
    const pr = playableRectFor(scene);
    const r = img.displayWidth*0.5;
    img.x = Phaser.Math.Clamp(img.x, r, pr.w - r);
    img.y = Phaser.Math.Clamp(img.y, pr.y + r, pr.y + pr.h - r);
  }

  // ===================== SCORE / STATS + LEADERBOARD =====================
  const Leaderboard = {
    key: 'poopoopanda_leaderboard_v1',
    load(){
      try { return JSON.parse(localStorage.getItem(this.key) || '[]'); }
      catch(_){ return []; }
    },
    save(list){
      try { localStorage.setItem(this.key, JSON.stringify(list)); } catch(_) {}
    },
    add(entry){
      const list = this.load();
      list.push(entry);
      list.sort((a,b)=> b.score - a.score);
      this.save(list.slice(0,10));
      return this.load();
    }
  };

  function computeFinalScore(stats){
    // Pi√π punti se:
    // - mangi pi√π cibo (buono) all‚Äôinizio
    // - meno mal di pancia (picco)
    // - meno tempo totale
    // - usi meno bonus
    // - vieni colpito meno dal bagnino
    const food = stats.goodEats * 60;
    const bad  = stats.badEats  * -70;
    const stomachPenalty = Math.round(stats.maxStomach * 100) * -8;
    const timePenalty = Math.floor(stats.totalTimeSec) * -3;
    const bonusPenalty = stats.bonusUsed * -120;
    const hitPenalty = stats.bossHitsTaken * -160;
    const winBonus = stats.didWin ? 800 : 0;
    const base = 500;

    return Math.max(0, base + food + bad + stomachPenalty + timePenalty + bonusPenalty + hitPenalty + winBonus + (stats.scoreEvents||0));
  }

  // ========== DOMAIN ==========
  const Characters = {
    PANDA_PICCOLO: { specie: 'panda', eta: 'piccolo' },
    PANDA_ADULTO:  { specie: 'panda', eta: 'adulto'  },
    BAMBINO:       { specie: 'umano', eta: 'piccolo' },
    ADULTO:        { specie: 'umano', eta: 'adulto'  }
  };
  const Foods = { BAMBOO: 'bamboo', PASTA: 'pasta', PIZZA: 'pizza', GELATO: 'gelato' };
  function allowedFoodsFor(character){
    if (character.specie === 'panda') return new Set([Foods.BAMBOO]);
    if (character.specie === 'umano' && character.eta === 'piccolo') return new Set([Foods.PASTA]);
    if (character.specie === 'umano' && character.eta === 'adulto') return new Set([Foods.PIZZA]);
    return new Set();
  }
  function poopGain(character, food){
    const allowed = allowedFoodsFor(character);
    if (allowed.has(food)) return 0.18;
    if (food === Foods.GELATO) return 0.06;
    return 0.00;
  }
  function defaultRng(){ return { int(min, max){ return Math.floor(Math.random()*(max-min+1)) + min; } }; }
  function randomPointAvoiding(center, minDist, bounds, rng = defaultRng()){
    const maxTry = 50;
    for (let i=0;i<maxTry;i++){
      const x = rng.int(bounds.xMin, bounds.xMax);
      const y = rng.int(bounds.yMin, bounds.yMax);
      const dx = x - center.x, dy = y - center.y;
      if (Math.hypot(dx,dy) >= minDist) return { x, y };
    }
    return { x: rng.int(bounds.xMin, bounds.xMax), y: rng.int(bounds.yMin, bounds.yMax) };
  }
  function isInVisionCone(observer, dirAngle, fovRad, range, target){
    const dx = target.x - observer.x, dy = target.y - observer.y;
    const dist = Math.hypot(dx, dy); if (dist > range) return false;
    const ang = Math.atan2(dy, dx);
    let diff = ang - dirAngle;
    diff = Math.atan2(Math.sin(diff), Math.cos(diff));
    return Math.abs(diff) <= fovRad/2;
  }

  const GameState = {
    selected:   { specie: 'panda', eta: 'piccolo', genere: 'm' },
    poopMeter:  0,
    stomach:    0,
    hasNarwhal: false,
    hasSiren:   false,
    hasTornado: false,
    crabsFriendly: false,
    transitioning: false,

    // score/stats (per run)
    score: 0,
    stats: {
      startMs: 0,
      goodEats: 0,
      badEats: 0,
      maxStomach: 0,
      bonusUsed: 0,
      bossHitsTaken: 0,
      didWin: false,
      totalTimeSec: 0,
      scoreEvents: 0
    }
  };

  function resetForNewRun(){
    GameState.poopMeter = 0;
    GameState.stomach   = 0;
    GameState.hasNarwhal = false;
    GameState.hasSiren   = false;
    GameState.hasTornado = false;
    GameState.crabsFriendly = false;
    GameState.transitioning = false;

    GameState.score = 0;
    GameState.stats = {
      startMs: performance.now(),
      goodEats: 0,
      badEats: 0,
      maxStomach: 0,
      bonusUsed: 0,
      bossHitsTaken: 0,
      didWin: false,
      totalTimeSec: 0,
      scoreEvents: 0
    };
  }

  function addScore(delta, reason){
    GameState.score = Math.max(0, GameState.score + delta);
    // teniamo anche un ‚Äúlog‚Äù aggregato leggero
    GameState.stats.scoreEvents += delta;
    // (reason non stampato per non sporcare UI; ma pronto per debug)
  }

  function labelForFood(foodType){
    switch(foodType){
      case Foods.BAMBOO: return 'üéã Bamboo';
      case Foods.PASTA:  return 'üçù Pasta';
      case Foods.PIZZA:  return 'üçï Pizza';
      case Foods.GELATO: return 'üç¶ Gelato';
      default:           return 'Cibo';
    }
  }
  function colorForFood(foodType){
    switch(foodType){
      case Foods.BAMBOO: return '#1f7a1f';
      case Foods.PASTA:  return '#7a5d1f';
      case Foods.PIZZA:  return '#a83232';
      case Foods.GELATO: return '#7a1f6a';
      default:           return '#333333';
    }
  }

  // ========== SFX ==========
  let _audioCtx = null;
  function ensureAudioContext(){ if (!_audioCtx) _audioCtx = new (window.AudioContext || window.webkitAudioContext)(); return _audioCtx; }
  function tone({ freq=440, dur=0.12, type='sine', vol=0.22 }){
    const ctx = ensureAudioContext();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = type; osc.frequency.value = freq;
    osc.connect(gain); gain.connect(ctx.destination);
    gain.gain.setValueAtTime(vol, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + dur);
    osc.start(); osc.stop(ctx.currentTime + dur);
  }
  const SFX = {
    play: (f,d,t,v)=> tone({ freq:f, dur:d, type:t, vol:v }),
    eat(){ this.play(520,0.08,'triangle',0.22); this.play(660,0.06,'sine',0.18); },
    wrong(){ this.play(220,0.10,'sawtooth',0.18); },
    drop(){ this.play(180,0.14,'square',0.22); },
    narwhal(){ this.play(400,0.10,'sine',0.2); this.play(300,0.20,'triangle',0.15); },
    siren(){ this.play(900,0.08,'square',0.2); this.play(700,0.12,'square',0.2); },
    tornado(){ this.play(120,0.3,'sawtooth',0.2); },
    crab(){ this.play(760,0.06,'square',0.22); this.play(640,0.08,'triangle',0.18); },
    win(){ [523,659,783].forEach((f,i)=>setTimeout(()=>this.play(f,0.12,'sine',0.22), i*120)); },
    lose(){ [196,185,174].forEach((f,i)=>setTimeout(()=>this.play(f,0.12,'triangle',0.22), i*120)); },
    button(){ this.play(540,0.08,'sine',0.22); }
  };

  // ========== UI helpers ==========
  function drawProgressBar(graphics, x, y, w, h, progress, fillColor=0x9b5a1a){
    graphics.lineStyle(2, 0x222222, 1);
    graphics.strokeRoundedRect(x, y, w, h, 8);
    graphics.fillStyle(0x333333, 1);
    graphics.fillRoundedRect(x, y, w, h, 8);
    const innerPad = 4, iw = (w - innerPad*2) * Math.max(0, Math.min(1, progress));
    graphics.fillStyle(fillColor, 1);
    graphics.fillRoundedRect(x + innerPad, y + innerPad, iw, h - innerPad*2, 6);
  }
  function makeBamboo(scene, x, baseY, totalH){
    const c = scene.add.container(x, baseY);
    const g = scene.add.graphics(); c.add(g);
    const stemW = 16; const segments = Math.max(3, Math.floor(totalH/36));
    let y = 0;
    for (let i=0;i<segments;i++){
      g.fillStyle(0x2e7d32,1); g.fillRoundedRect(-stemW/2, -y-36, stemW, 36, 6);
      g.lineStyle(3,0x1b5e20,1); g.strokeLineShape(new Phaser.Geom.Line(-stemW/2, -y-18, stemW/2, -y-18));
      const leaf = (lx,ly,ang,sz=12)=>{ g.fillStyle(0x66bb6a,1); const ax=Math.cos(ang), ay=Math.sin(ang); g.fillTriangle(lx,ly, lx-ax*sz, ly-ay*sz, lx-ay*sz*0.6, ly+ax*sz*0.6); };
      if (i%2===0) leaf(stemW/2, -y-24, 0.2); else leaf(-stemW/2, -y-10, Math.PI-0.2);
      y += 36;
    }
    c.setSize(stemW, totalH);
    scene.tweens.add({ targets:c, angle:2, yoyo:true, repeat:-1, duration:2200, ease:'Sine.easeInOut' });
    return c;
  }

  // ========== TEXTURES ==========
  function drawBow(g, cx, cy, col=0xff3da7){ g.fillStyle(col,1); g.fillEllipse(cx-6,cy,8,10); g.fillEllipse(cx+6,cy,8,10); g.fillCircle(cx,cy,3); }
  function drawCap(g, cx, cy, col=0x1f4d7a){ g.fillStyle(col,1); g.fillEllipse(cx,cy,26,12); g.fillRect(cx-13, cy, 26, 5); }
  function drawGlasses(g, cx, cy){ g.lineStyle(2,0x000000,1); g.strokeCircle(cx-8,cy,6); g.strokeCircle(cx+8,cy,6); g.lineBetween(cx-2,cy, cx+2,cy); }
  function createCharacterTexture(scene, key, sel){
    const g = scene.add.graphics();
    const isPanda = sel.specie === 'panda';
    const isBaby  = sel.eta === 'piccolo';
    const size = isBaby ? 22 : 28;
    const pad = 22;
    const cx = pad + size, cy = pad + size;
    if (isPanda) {
      g.fillStyle(0xffffff, 1); g.fillCircle(cx, cy, size);
      g.fillStyle(0x000000, 1);
      g.fillCircle(cx-12, cy-18, isBaby?6:7); g.fillCircle(cx+12, cy-18, isBaby?6:7);
      g.fillEllipse(cx-7, cy-2, 10, 14); g.fillEllipse(cx+7, cy-2, 10, 14);
      g.fillStyle(0xffffff, 1); g.fillCircle(cx-7, cy-2, 3); g.fillCircle(cx+7, cy-2, 3);
      g.fillStyle(0x000000, 1); g.fillCircle(cx, cy+5, 3);
      if (isBaby) { g.fillStyle(0xffa3a3,0.8); g.fillCircle(cx-12, cy+10, 3); g.fillCircle(cx+12, cy+10, 3); }
      else { if (sel.genere==='m'){ g.fillStyle(0xa00000,1); g.fillTriangle(cx, cy+18, cx-6, cy+28, cx+6, cy+28); } else { g.fillStyle(0xffe066,1); g.fillCircle(cx, cy+26, 4); } }
      if (sel.genere==='f') drawBow(g, cx-14, cy-26, 0xff3da7); else drawCap(g, cx, cy-28, 0x1f4d7a);
    } else {
      const skin = 0xffe0bd; g.fillStyle(skin, 1); g.fillCircle(cx, cy, size);
      const hairCol = 0x3b2e2a;
      if (isBaby) { g.fillStyle(hairCol, 1); g.fillEllipse(cx, cy-10, size*1.6, size*0.8); }
      else { g.fillStyle(hairCol, 1); if (sel.genere==='f') g.fillEllipse(cx, cy-6, size*1.8, size*1.6); else g.fillEllipse(cx, cy-8, size*1.8, size*1.0); }
      g.fillStyle(0x000000, 1); g.fillCircle(cx-7, cy-2, 3); g.fillCircle(cx+7, cy-2, 3); g.lineStyle(2, 0x000000, 1); g.strokeCircle(cx, cy+6, 6);
      if (sel.genere==='f') drawBow(g, cx-14, cy-26, 0xff3da7); else drawCap(g, cx, cy-28, 0x1f4d7a);
      if (!isBaby && sel.genere==='m') drawGlasses(g, cx, cy-2);
    }
    const w = (size+pad)*2, h = (size+pad)*2; g.generateTexture(key, w, h); g.destroy();
  }
  function createSwimmerTexture(scene, key, tint=0x00a3c4){
    const g = scene.add.graphics(); const pad=10; const r=12, cx=pad+r, cy=pad+r;
    g.fillStyle(0xffe0bd,1); g.fillCircle(cx, cy, r);
    g.fillStyle(tint,1); g.fillEllipse(cx, cy-6, r*1.8, r*1.0);
    g.lineStyle(2,0x000000,1); g.strokeRect(cx-8, cy-2, 16, 4);
    g.fillStyle(0xc0dff4,1); g.fillEllipse(cx, cy+16, r*1.2, r*0.8);
    g.generateTexture(key, pad*2+r*2, pad*2+r*2+16); g.destroy();
  }
  function createLifeguardTexture(scene, key){
    const g = scene.add.graphics(); const pad=10; const r=14, cx=pad+r, cy=pad+r;
    g.fillStyle(0xffe0bd,1); g.fillCircle(cx, cy, r);
    g.fillStyle(0xc62828,1); g.fillEllipse(cx, cy-8, r*1.8, r*1.0); g.fillRect(cx-12, cy-8, 24, 5);
    g.fillStyle(0x808080,1); g.fillRect(cx-2, cy+6, 4, 6);
    g.fillStyle(0xffffff,1); g.fillEllipse(cx, cy+18, r*1.4, r*1.0);
    g.fillStyle(0xc62828,1); g.fillRect(cx-2, cy+14, 4, 8); g.fillRect(cx-6, cy+16, 12, 4);
    g.generateTexture(key, pad*2+r*2, pad*2+r*2+18); g.destroy();
  }

  // ========== LIMBS + WINGS ==========
  function makeLimbs(scene, color=0x000000){
    const parts = ['LA','RA','LL','RL'].reduce((acc,k)=>{ acc[k]=scene.add.graphics(); return acc; },{});
    const draw = (g,x,y,rot)=>{ g.clear(); g.fillStyle(color,1); g.save(); g.translateCanvas(x,y); g.rotateCanvas(rot); g.fillRoundedRect(-2,-8,4,16,2); g.restore(); };
    return { parts, draw, setVisible(v){ Object.values(parts).forEach(p=>p.setVisible(v)); }, destroy(){ Object.values(parts).forEach(p=>p.destroy()); } };
  }
  function updateLimbs(limbs, px, py, moving, t){
    const amp = moving? 0.8 : 0.2; const speed = moving? 10 : 2; const s = Math.sin(t*speed);
    limbs.draw(limbs.parts.LA, px-12, py+6,  s*amp);
    limbs.draw(limbs.parts.RA, px+12, py+6, -s*amp);
    limbs.draw(limbs.parts.LL, px-8,  py+20, -s*amp);
    limbs.draw(limbs.parts.RL, px+8,  py+20,  s*amp);
  }
  function makeWings(scene){
    const L = scene.add.text(0,0,'ü™Ω',{fontFamily:FONT,fontSize:22}).setOrigin(0.5).setDepth(20).setVisible(false);
    const R = scene.add.text(0,0,'ü™Ω',{fontFamily:FONT,fontSize:22}).setOrigin(0.5).setDepth(20).setVisible(false);
    return {
      setDepth(d){ L.setDepth(d); R.setDepth(d); },
      setVisible(v){ L.setVisible(v); R.setVisible(v); },
      update(px,py,t){
        const flap = Math.sin(t*12)*6;
        L.setPosition(px-18, py+6-flap);
        R.setPosition(px+18, py+6+flap);
      },
      destroy(){ L.destroy(); R.destroy(); }
    };
  }

  // ========== SCENES ==========
  class MenuScene extends Phaser.Scene {
    constructor(){ super('MenuScene'); }
    create(){
      resetForNewRun();
      const { width, height } = this.scale;

      const bg = this.add.graphics();
      bg.fillStyle(0x0b3d91,1); bg.fillRect(0,0,width,height*0.35);
      bg.fillStyle(0x1976d2,1); bg.fillRect(0,height*0.35,width,height*0.25);
      bg.fillStyle(0xf4e2b5,1); bg.fillRect(0,height*0.60,width,height*0.40);
      makeBamboo(this, 54, height-20, height*0.75);
      makeBamboo(this, width-54, height-20, height*0.68);

      const title = this.add.text(width/2, 60, 'Poo Poo Panda', { fontFamily: FONT, fontSize: 54, color:'#ffffff' }).setOrigin(0.5);
      title.setShadow(3,3,'#000000',6,true,true);

      const panelW = Math.min(720, width-60), panelH = 300;
      const panel = this.add.graphics();
      panel.fillStyle(0x1b2838, 0.95); panel.fillRoundedRect((width-panelW)/2, 150, panelW, panelH, 20);
      panel.lineStyle(3, 0x64b5f6, 1.0); panel.strokeRoundedRect((width-panelW)/2, 150, panelW, panelH, 20);
      this.add.text(width/2, 165, 'Scegli il personaggio e il genere', { fontFamily: FONT, fontSize: 22, color:'#e3f2fd' }).setOrigin(0.5);

      const options = [
        { label: 'Panda piccolo', value: Characters.PANDA_PICCOLO },
        { label: 'Panda adulto',  value: Characters.PANDA_ADULTO  },
        { label: 'Bambino umano', value: Characters.BAMBINO       },
        { label: 'Adulto umano',  value: Characters.ADULTO        },
      ];
      const cards = []; let selectedIdx = 0; let gender = 'm';
      const startX = (width-panelW)/2 + 28; const startY = 205; const gapX = (panelW-56)/4; const cardW = gapX-14; const cardH = 110;

      const makeCard = (i)=>{
        const x = startX + i*gapX; const y = startY; const c = this.add.container(x, y);
        const g = this.add.graphics(); c.add(g);
        const k = ()=>`menu_prev_${i}_${gender}`;
        const drawCardBG = (active=false)=>{
          g.clear();
          if (active){ g.fillStyle(0x143d5b,1); g.fillRoundedRect(0,0,cardW,cardH,16); g.lineStyle(3,0x64b5f6,1); g.strokeRoundedRect(0,0,cardW,cardH,16); }
          else       { g.fillStyle(0x102131,1); g.fillRoundedRect(0,0,cardW,cardH,16); g.lineStyle(2,0x5dade2,1); g.strokeRoundedRect(0,0,cardW,cardH,16); }
        };
        drawCardBG(i===selectedIdx);

        const ensureTex = ()=>{
          if (!this.textures.exists(k())) createCharacterTexture(this, k(), { ...options[i].value, genere: gender });
        };
        ensureTex();
        const img = this.add.image(cardW/2, 46, k()).setScale(0.9); c.add(img);
        const txt = this.add.text(cardW/2, cardH-20, options[i].label, { fontFamily: FONT, fontSize: 16, color:'#e3f2fd' }).setOrigin(0.5);
        txt.setShadow(2,2,'#000',4,true,true); c.add(txt);

        c.setSize(cardW, cardH);
        c.setInteractive(new Phaser.Geom.Rectangle(0,0,cardW,cardH), Phaser.Geom.Rectangle.Contains)
          .on('pointerover', ()=> drawCardBG(true))
          .on('pointerout',  ()=> drawCardBG(i===selectedIdx))
          .on('pointerdown', ()=>{ SFX.button(); selectedIdx=i; cards.forEach((card, idx)=>card.drawBG(idx===selectedIdx)); });

        cards.push({c,g,img,txt,drawBG:drawCardBG, refreshTexture:()=>{ ensureTex(); img.setTexture(k()); }});
      };
      for (let i=0;i<options.length;i++) makeCard(i);

      const pillW = 220, pillH = 40; const pillX = width/2 - pillW/2, pillY = 325;
      const pill = this.add.graphics();
      const drawPill = ()=>{
        pill.clear();
        pill.fillStyle(0x102131,1); pill.fillRoundedRect(pillX, pillY, pillW, pillH, 20);
        pill.lineStyle(2,0x90caf9,1); pill.strokeRoundedRect(pillX, pillY, pillW, pillH, 20);
        const knobX = gender==='m'? pillX+pillW*0.25 : pillX+pillW*0.75;
        pill.fillStyle(0x64b5f6,1); pill.fillRoundedRect(knobX-44, pillY+6, 88, pillH-12, 16);
      };
      drawPill();
      this.add.text(pillX+pillW*0.25, pillY+pillH/2, '‚ôÇÔ∏è Maschio', { fontFamily: FONT, fontSize:16, color:'#e3f2fd' }).setOrigin(0.5);
      this.add.text(pillX+pillW*0.75, pillY+pillH/2, '‚ôÄÔ∏è Femmina', { fontFamily: FONT, fontSize:16, color:'#e3f2fd' }).setOrigin(0.5);
      this.add.zone(pillX, pillY, pillW, pillH).setOrigin(0).setInteractive().on('pointerdown', ()=>{
        SFX.button();
        gender = gender==='m' ? 'f' : 'm'; drawPill();
        cards.forEach(c=>c.refreshTexture());
      });

      this.add.text(width/2, height - 110, 'Consiglio: Panda‚ÜíBamboo | Bimbo‚ÜíPasta | Adulto‚ÜíPizza', { fontFamily: FONT, fontSize: 16, color: '#0b0b0b', backgroundColor:'#e3f2fd', padding:{left:10,right:10,top:4,bottom:4} }).setOrigin(0.5);

      const start = this.add.text(width/2, height - 60, 'Inizia ‚ñ∂', { fontFamily: FONT, fontSize: 30, color: '#ffffff', backgroundColor:'#43a047', padding:{ left:18, right:18, top:8, bottom:8 } }).setOrigin(0.5);
      start.setShadow(3,3,'#1b5e20',6,true,true);
      start.setInteractive({ useHandCursor: true })
        .on('pointerover', ()=> start.setStyle({ backgroundColor:'#2e7d32' }))
        .on('pointerout',  ()=> start.setStyle({ backgroundColor:'#43a047' }))
        .on('pointerdown', ()=>{
          if (GameState.transitioning) return; GameState.transitioning = true; SFX.button();
          const chosen = options[selectedIdx].value; GameState.selected = { specie: chosen.specie, eta: chosen.eta, genere: gender };
          resetForNewRun(); // start run now
          this.scene.start('LandScene');
        });

      this.add.text(width - 10, height - 10, `Versione ${GAME_VERSION}`, {
        fontFamily: FONT,
        fontSize: 14,
        color: "#ffffff"
      }).setOrigin(1, 1).setAlpha(0.8);
    }
  }

  class LandScene extends Phaser.Scene {
    constructor(){ super('LandScene'); }
    create(){
      GameState.transitioning = false;
      const pr = setWorldBoundsToPlayable(this);
      const { width, height } = this.scale;

      this.cameras.main.setBackgroundColor('#87CEEB');
      this.bg = this.add.graphics();
      this.bg.fillStyle(0x1976d2,1); this.bg.fillRect(0,pr.y, width, pr.h*0.45);
      this.bg.fillStyle(0xF4E2B5, 1); this.bg.fillRect(0, pr.y + pr.h*0.45, width, pr.h*0.55);

      this.add.text(10, 10, `Personaggio: ${GameState.selected.specie} ${GameState.selected.eta} (${GameState.selected.genere==='m'?'M':'F'})`, { fontFamily: FONT, fontSize: 16, color: '#fff' }).setDepth(1000);

      const key = `char_${GameState.selected.specie}_${GameState.selected.eta}_${GameState.selected.genere}`;
      createCharacterTexture(this, key, GameState.selected);

      this.player = this.add.image(width/2, pr.y + pr.h*0.75, key).setDepth(10);
      this.physics.add.existing(this.player);
      this.player.body.setCircle(this.player.displayWidth/2);
      this.player.body.setCollideWorldBounds(true);

      this.playerLimbs = makeLimbs(this, 0x000000);
      Object.values(this.playerLimbs.parts).forEach(p=>p.setDepth(11));

      this.foods = this.physics.add.group();
      this.bonuses = this.physics.add.group();

      // UI top (barre + score)
      this.ui = this.add.graphics().setDepth(1000);
      this.poopText = this.add.text(0, 0, '', { fontFamily: FONT, fontSize: 14, color: '#fff' }).setOrigin(1,0).setDepth(1001);
      this.stomachText = this.add.text(0, 0, '', { fontFamily: FONT, fontSize: 14, color: '#fff' }).setOrigin(1,0).setDepth(1001);
      this.scoreText = this.add.text(16, 36, '', { fontFamily: FONT, fontSize: 16, color:'#fff' }).setDepth(1001);

      this.promptText = this.add.text(width/2, 46, '', { fontFamily: FONT, fontSize: 18, color: '#e3f2fd' }).setOrigin(0.5).setDepth(1001);

      // bottoni fuori area giocabile (banda in basso)
      this.btnMenu = makeUIButton(this,'‚¨Ö Menu', { bg:'#444' }).on('pointerdown', ()=>{ resetForNewRun(); this.scene.start('MenuScene'); });
      this.btnRestart = makeUIButton(this,'‚ü≤ Ricomincia (R)', { bg:'#444' }).on('pointerdown', ()=> this.restartLand());
      this.btnSea = makeUIButton(this,'Vai al Mare ‚ñ∂ (M)', { bg:'#0a7d33' }).on('pointerdown', ()=> this.tryGoSea());
      this.btnSea.visible = false;

      this.sceneStartMs = this.time.now; this.GRACE_MS = 1000; this.EAT_COOLDOWN_MS = 180; this.lastEatMs = 0;

      this.spawnFoodWave(); this.spawnBonusNarwhal();

      this.tut = this.add.text(width/2, height-90, 'Mangia i cibi giusti. Evita quelli sbagliati (mal di pancia). Riempi fino al 60% e vai al mare!', { fontFamily:FONT, fontSize: 16, color:'#001', backgroundColor:'#fff', padding:{left:8,right:8,top:6,bottom:6} }).setOrigin(0.5).setDepth(1000);
      this.time.delayedCall(5000, ()=> this.tut.setVisible(false));

      this.cursors = this.input.keyboard.createCursorKeys(); this.wasd = this.input.keyboard.addKeys('W,A,S,D');
      this.keyM = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.M);
      this.keyR = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);

      this.pointerTarget = null; this.pointerMarker = this.add.circle(0, 0, 8, 0x000000, 0.3).setVisible(false).setDepth(1000);
      const setPointerTarget = (p)=>{ this.pointerTarget = { x: p.worldX, y: p.worldY }; this.pointerMarker.setPosition(this.pointerTarget.x, this.pointerTarget.y).setVisible(true); };
      this.input.on('pointerdown', setPointerTarget); this.input.on('pointermove', (p)=>{ if (p.isDown) setPointerTarget(p); });

      this.physics.add.overlap(this.player, this.foods, this.onEatFood, null, this);
      this.physics.add.overlap(this.player, this.bonuses, this.onTakeBonus, null, this);

      this.swimFX = this.add.text(0,0,'üí¶',{ fontFamily:FONT, fontSize:20 }).setVisible(false).setDepth(12);

      // bonus sempre in primo piano
      // (foods sotto, bonus sopra)
      this.foodDepth = 40;
      this.bonusDepth = 200;

      this.layoutUI();
      this.scale.on('resize', ()=> this.layoutUI());
    }

    layoutUI(){
      const pr = setWorldBoundsToPlayable(this);
      const { width, height } = this.scale;

      // riallinea sfondo per bounds aggiornati
      this.bg.clear();
      this.bg.fillStyle(0x1976d2,1); this.bg.fillRect(0,pr.y, width, pr.h*0.45);
      this.bg.fillStyle(0xF4E2B5, 1); this.bg.fillRect(0, pr.y + pr.h*0.45, width, pr.h*0.55);

      // banda in basso
      const bandY = pr.y + pr.h;
      const bandH = pr.band;
      const band = this._bandGfx || (this._bandGfx = this.add.graphics().setDepth(900));
      band.clear();
      band.fillStyle(0x0b0f16, 0.75);
      band.fillRect(0, bandY, width, bandH);
      band.lineStyle(2, 0x223344, 0.9);
      band.strokeRect(0, bandY, width, bandH);

      // pos bottoni (wrap)
      layoutButtonRow(this, [this.btnMenu, this.btnRestart, this.btnSea], {x:0,y:bandY,w:width,h:bandH});

      // tut in safe area
      if (this.tut) this.tut.setPosition(width/2, bandY - 40);

      // clamp player dentro play area
      clampToPlayable(this, this.player);
    }

    restartLand(){ resetForNewRun(); this.scene.start('LandScene'); }

    getSafeSpawn(minDist=120){
      const pr = playableRectFor(this);
      const b = { xMin: 40, xMax: pr.w-40, yMin: pr.y+40, yMax: pr.y+pr.h-40 };
      return randomPointAvoiding({x:this.player.x,y:this.player.y}, minDist, b);
    }

    spawnFoodWave(){
      const types=[Foods.BAMBOO,Foods.PASTA,Foods.PIZZA,Foods.GELATO];
      for(let i=0;i<8;i++){
        const t=Phaser.Utils.Array.GetRandom(types);
        const p=this.getSafeSpawn(140);
        this.spawnFoodAt(p.x,p.y,t);
      }
    }

    spawnFoodAt(x,y,t){
      const food=this.add.text(x,y,labelForFood(t),{ fontFamily:FONT, fontSize:18, color:colorForFood(t)}).setOrigin(0.5).setDepth(this.foodDepth);
      this.physics.add.existing(food);
      food.body.setCircle(24).setOffset(-24,-24);
      food.body.setImmovable(true);
      food.foodType=t;
      this.foods.add(food);
    }

    spawnSingleFood(){
      const types=[Foods.BAMBOO,Foods.PASTA,Foods.PIZZA,Foods.GELATO];
      const t=Phaser.Utils.Array.GetRandom(types);
      const p=this.getSafeSpawn(120);
      this.spawnFoodAt(p.x,p.y,t);
    }

    spawnBonusNarwhal(){
      if (GameState.hasNarwhal) return;
      const p=this.getSafeSpawn(160);
      const b=this.add.text(p.x,p.y,'üêã Narvalo',{ fontFamily:FONT, fontSize:18, color:'#551a8b'}).setOrigin(0.5).setDepth(this.bonusDepth);
      this.physics.add.existing(b);
      b.body.setCircle(26).setOffset(-26,-26);
      b.body.setImmovable(true);
      b.bonusType='narwhal';
      this.bonuses.add(b);
    }

    onEatFood(player, food){
      const now=this.time.now;
      if (now-this.sceneStartMs< this.GRACE_MS) return;
      if (now-this.lastEatMs<this.EAT_COOLDOWN_MS) return;
      this.lastEatMs=now;

      const gain=poopGain(GameState.selected, food.foodType);
      if (gain===0){
        GameState.stomach = Math.min(1, GameState.stomach + 0.22);
        GameState.stats.badEats++;
        addScore(-50, 'bad_eat');

        this.tweens.add({targets:food, angle:10, yoyo:true, duration:120, onComplete:()=>food.destroy()});
        SFX.wrong();
      } else {
        GameState.poopMeter = Math.min(1, GameState.poopMeter + gain);
        GameState.stats.goodEats++;
        addScore(+35, 'good_eat');

        this.tweens.add({targets:food, scale:1.25, yoyo:true, duration:120, onComplete:()=>food.destroy()});
        SFX.eat();
      }
      GameState.stats.maxStomach = Math.max(GameState.stats.maxStomach, GameState.stomach);

      this.time.delayedCall(300, ()=>this.spawnSingleFood());
    }

    onTakeBonus(player, bonus){
      if (bonus.bonusType==='narwhal'){
        GameState.hasNarwhal=true;
        addScore(+120,'bonus_pick');
        this.tweens.add({ targets:bonus, angle:360, scale:1.5, duration:240, onComplete:()=>bonus.destroy() });
        SFX.narwhal();
      }
    }

    tryGoSea(){
      if (GameState.poopMeter<0.6 || GameState.transitioning) return;
      GameState.transitioning=true;
      this.scene.start('SeaScene');
    }

    update(time, delta){
      const pr = playableRectFor(this);
      const { width } = this.scale;
      const body=this.player.body; body.setVelocity(0);

      const inWaterBandTop = pr.y;
      const inWaterBandBottom = pr.y + pr.h*0.45;
      const inWater = (this.player.y >= inWaterBandTop && this.player.y <= inWaterBandBottom);
      const speed = inWater ? 110 : 160;

      if (this.cursors.left.isDown||this.wasd.A.isDown) body.setVelocityX(-speed); else if (this.cursors.right.isDown||this.wasd.D.isDown) body.setVelocityX(speed);
      if (this.cursors.up.isDown||this.wasd.W.isDown) body.setVelocityY(-speed); else if (this.cursors.down.isDown||this.wasd.S.isDown) body.setVelocityY(speed);

      if (this.pointerTarget){
        const dx=this.pointerTarget.x-this.player.x, dy=this.pointerTarget.y-this.player.y, dist=Math.hypot(dx,dy);
        if (dist>6) body.setVelocity((dx/dist)*speed, (dy/dist)*speed);
        else { this.pointerTarget=null; this.pointerMarker.setVisible(false); }
      }

      // clamp dentro play area
      clampToPlayable(this, this.player);

      // HUD top
      const barW=220, barH=22, pad=16;
      const xRight = width - barW - pad;
      this.ui.clear();
      drawProgressBar(this.ui, xRight, 10, barW, barH, GameState.poopMeter, 0x9b5a1a);
      drawProgressBar(this.ui, xRight, 10+barH+6, barW, barH, GameState.stomach,   0xcc3333);
      this.poopText.setPosition(xRight+barW, 10).setText(`Pup√π: ${Math.round(GameState.poopMeter*100)}%`);
      this.stomachText.setPosition(xRight+barW, 10+barH+6).setText(`Mal di pancia: ${Math.round(GameState.stomach*100)}%`);

      this.scoreText.setText(`Score: ${GameState.score}`);

      const canSea = GameState.poopMeter>=0.6;
      this.promptText.setText(canSea? 'Premi M o tocca ‚ñ∂ Vai al Mare':'Mangia i cibi adatti per riempire la barra');
      this.btnSea.visible = canSea;

      if (Phaser.Input.Keyboard.JustDown(this.keyM)) this.tryGoSea();
      if (Phaser.Input.Keyboard.JustDown(this.keyR)) this.restartLand();

      if (GameState.poopMeter>=1.0) { SFX.lose(); this.scene.start('LoseScene', { reason:'overeat' }); }
      if (GameState.stomach>=1.0)   { SFX.lose(); this.scene.start('LoseScene', { reason:'stomachache' }); }

      this.swimFX.setVisible(inWater).setPosition(this.player.x, this.player.y - 34);

      const moving = body.velocity.length() > 5;
      updateLimbs(this.playerLimbs, this.player.x, this.player.y, moving, time/1000);
    }

    shutdown(){ this.playerLimbs?.destroy?.(); }
  }

  class SeaScene extends Phaser.Scene {
    constructor(){ super('SeaScene'); }
    create(){
      const { width, height } = this.scale;
      GameState.transitioning=false;
      const pr = setWorldBoundsToPlayable(this);

      this.cameras.main.setBackgroundColor('#3CB7E7');

      // spiaggia dentro area giocabile (non nella banda UI)
      this.beachHeight = Math.floor(pr.h * 0.30);
      this.beachTopY   = pr.y + pr.h - this.beachHeight;

      const bg = this.add.graphics();
      bg.fillStyle(0x3CB7E7,1); bg.fillRect(0,0,width,height);
      bg.fillStyle(0xF4E2B5,1); bg.fillRect(0, this.beachTopY, width, this.beachHeight);

      const key = `char_${GameState.selected.specie}_${GameState.selected.eta}_${GameState.selected.genere}`;
      createCharacterTexture(this, key, GameState.selected);

      this.player = this.add.image(width*0.5, this.beachTopY - 40, key).setDepth(20);
      this.physics.add.existing(this.player);
      this.player.body.setCircle(this.player.displayWidth/2);
      this.player.body.setCollideWorldBounds(true);

      this.playerLimbs = makeLimbs(this, 0x001122);
      Object.values(this.playerLimbs.parts).forEach(p=>p.setDepth(21));
      this.wings = makeWings(this);
      this.wings.setDepth(22);

      this.currentAngle = Phaser.Math.FloatBetween(-Math.PI, Math.PI);
      this.currentSpeed = 38;
      this.currentFrozen = false;
      this.currentArrow = this.add.graphics().setDepth(1000);

      this.cloud = this.add.text(width/2, 36, '‚òÅÔ∏è‚òÅÔ∏è‚òÅÔ∏è', { fontFamily:FONT, fontSize: 40, color:'#ffffff' }).setOrigin(0.5).setVisible(false).setDepth(1000);
      this.tweens.add({ targets:this.cloud, scale:1.15, yoyo:true, repeat:-1, duration:450, ease:'Sine.easeInOut' });
      this.scheduleNextCurrentChange();

      this.poops = this.add.group(); this.narwhals = []; this.swimmers = [];

      const lifekey = 'lifeguard_tex'; if (!this.textures.exists(lifekey)) createLifeguardTexture(this, lifekey);
      this.lifeguardSprite = this.add.image(width/2, this.beachTopY - 20, lifekey).setDepth(30);

      this.lifeguard = {
        x: this.lifeguardSprite.x,
        y: this.lifeguardSprite.y,
        dir: -Math.PI/2,
        sweepMin: -Math.PI/2 - Phaser.Math.DegToRad(35),
        sweepMax: -Math.PI/2 + Phaser.Math.DegToRad(35),
        speed: Phaser.Math.DegToRad(20),
        fov: Phaser.Math.DegToRad(50),
        range: 360,
        distractedUntil: 0
      };

      this.visionGfx = this.add.graphics().setDepth(900);

      const capColors = [0x00a3c4,0xffa726,0x8e24aa,0x2e7d32,0xd32f2f,0x455a64];
      for (let i=0; i<6; i++) this.spawnSwimmer(Phaser.Utils.Array.GetRandom(capColors));

      this.seaBonuses = this.physics.add.group();
      if (!GameState.hasNarwhal) this.spawnSeaBonus('narwhal');
      if (!GameState.hasSiren)   this.spawnSeaBonus('siren');
      if (!GameState.hasTornado) this.spawnSeaBonus('tornado');
      this.spawnCrabBonus();

      this.tornado = null; this.tornadoGfx = this.add.graphics().setDepth(950);

      // HUD + SCORE
      this.ui = this.add.graphics().setDepth(1000);
      this.uiText = this.add.text(16, 12, '', { fontFamily:FONT, fontSize: 16, color:'#fff' }).setDepth(1001);
      this.statusText = this.add.text(width/2, 12, '', { fontFamily:FONT, fontSize: 16, color:'#fff' }).setOrigin(0.5).setDepth(1001);
      this.poopText = this.add.text(0, 0, '', { fontFamily:FONT, fontSize: 14, color:'#fff' }).setOrigin(1,0).setDepth(1001);
      this.stomachText = this.add.text(0, 0, '', { fontFamily:FONT, fontSize: 14, color:'#fff' }).setOrigin(1,0).setDepth(1001);
      this.scoreText = this.add.text(16, 36, '', { fontFamily: FONT, fontSize: 16, color:'#fff' }).setDepth(1001);

      // Bottoni nella banda UI (fuori gioco) ‚Äî e sempre in primo piano
      this.btnDrop = makeUIButton(this,'Sgancia üí© (SPAZIO)', { bg:'#a34a00' }).on('pointerdown',()=>{ this.dropPoop(); SFX.drop(); });
      this.btnNar  = makeUIButton(this,'Narvalo üêã (N)',     { bg: GameState.hasNarwhal ? '#6a1b9a':'#555' }).on('pointerdown',()=>{ this.triggerNarwhal(); });
      this.btnSir  = makeUIButton(this,'Sirena ‚ú® (S)',      { bg: GameState.hasSiren ? '#2947a3':'#555' }).on('pointerdown',()=>{ this.triggerSiren(); });
      this.btnTor  = makeUIButton(this,'Tornado üåÄ (T)',     { bg: GameState.hasTornado ? '#00695c':'#555' }).on('pointerdown',()=>{ this.triggerTornado(); });
      this.btnMenu = makeUIButton(this,'‚¨Ö Menu',            { bg:'#444' }).on('pointerdown',()=>{ resetForNewRun(); this.scene.start('MenuScene'); });
      this.btnRestart = makeUIButton(this,'‚ü≤ Ricomincia',    { bg:'#444' }).on('pointerdown',()=>{ resetForNewRun(); this.scene.start('LandScene'); });

      this.tut = this.add.text(width/2, height-90, 'Lascia la üí© in mare e aspetta che si arena. Evita i coni (bagnino/nuotatori/granchi). Prendi il bonus ü¶Ä sulla spiaggia!', { fontFamily:FONT, fontSize: 16, color:'#001', backgroundColor:'#fff', padding:{left:8,right:8,top:6,bottom:6} }).setOrigin(0.5).setDepth(1000);
      this.time.delayedCall(7000, ()=> this.tut.setVisible(false));

      this.cursors = this.input.keyboard.createCursorKeys(); this.wasd = this.input.keyboard.addKeys('W,A,S,D');
      this.keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
      this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
      this.keyN = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.N);
      this.keyT = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.T);

      this.pointerTarget = null;
      this.pointerMarker = this.add.circle(0,0,8,0x000000,0.3).setVisible(false).setDepth(1000);
      const setPointerTarget = (p)=>{ this.pointerTarget = { x: p.worldX, y: p.worldY }; this.pointerMarker.setPosition(this.pointerTarget.x, this.pointerTarget.y).setVisible(true); };
      this.input.on('pointerdown', setPointerTarget);
      this.input.on('pointermove', (p)=>{ if (p.isDown) setPointerTarget(p); });

      this.physics.add.overlap(this.player, this.seaBonuses, (player, b)=>{
        if (b.type==='narwhal'){ GameState.hasNarwhal = true; this.btnNar.setStyle({ backgroundColor:'#6a1b9a' }); addScore(+160,'bonus_pick'); SFX.narwhal(); }
        if (b.type==='siren')  { GameState.hasSiren = true;   this.btnSir.setStyle({ backgroundColor:'#2947a3' }); addScore(+160,'bonus_pick'); SFX.siren(); }
        if (b.type==='tornado'){ GameState.hasTornado = true; this.btnTor.setStyle({ backgroundColor:'#00695c' }); addScore(+160,'bonus_pick'); SFX.tornado(); }
        if (b.type==='crab')   { GameState.crabsFriendly = true; addScore(+200,'bonus_pick'); SFX.crab(); this.onCrabsBefriend(); }
        this.tweens.add({ targets:b, angle:360, scale:1.5, duration:240, onComplete:()=>b.destroy() });
      });

      this.crabs = []; this.crabGfx = this.add.graphics().setDepth(800);
      this.spawnCrabs(6);

      // depth: bonus sempre sopra
      this.seaBonuses.getChildren().forEach(x=>x.setDepth(600));
      this.scale.on('resize', ()=> this.layoutUI());
      this.layoutUI();

      this.time.delayedCall(300, ()=> this.updateStatusTexts());
    }

    layoutUI(){
      const pr = setWorldBoundsToPlayable(this);
      const { width } = this.scale;

      this.beachHeight = Math.floor(pr.h * 0.30);
      this.beachTopY   = pr.y + pr.h - this.beachHeight;

      // banda in basso
      const bandY = pr.y + pr.h;
      const bandH = pr.band;
      const band = this._bandGfx || (this._bandGfx = this.add.graphics().setDepth(900));
      band.clear();
      band.fillStyle(0x0b0f16, 0.75);
      band.fillRect(0, bandY, width, bandH);
      band.lineStyle(2, 0x223344, 0.9);
      band.strokeRect(0, bandY, width, bandH);

      layoutButtonRow(this, [this.btnDrop, this.btnNar, this.btnSir, this.btnTor, this.btnMenu, this.btnRestart], {x:0,y:bandY,w:width,h:bandH});
      if (this.tut) this.tut.setPosition(width/2, bandY - 40);

      clampToPlayable(this, this.player);
    }

    scheduleNextCurrentChange(){
      const nextMs = Phaser.Math.Between(12000, 20000);
      this._cloudTimer1 = this.time.delayedCall(nextMs - 2500, ()=>{ if (!this.currentFrozen) this.cloud.setVisible(true); });
      this._cloudTimer2 = this.time.delayedCall(nextMs, ()=>{
        if (this.currentFrozen) { this.cloud.setVisible(false); this.scheduleNextCurrentChange(); return; }
        this.currentAngle = Phaser.Math.FloatBetween(-Math.PI, Math.PI);
        this.cloud.setVisible(false);
        this.scheduleNextCurrentChange();
      });
    }

    spawnSeaBonus(type){
      const pr = playableRectFor(this);
      const x = Phaser.Math.Between(40, pr.w-40), y = Phaser.Math.Between(pr.y+90, this.beachTopY-60);
      const label = type==='narwhal' ? 'üêã Narvalo' : type==='siren' ? 'üßú‚Äç‚ôÄÔ∏è Sirena' : 'üåÄ Tornado';
      const color = type==='narwhal' ? '#6a1b9a' : type==='siren' ? '#0a4abf' : '#00695c';
      const b = this.add.text(x, y, label, { fontFamily:FONT, fontSize: 18, color: color }).setOrigin(0.5).setDepth(600);
      this.physics.add.existing(b); b.body.setCircle(26).setOffset(-26,-26); b.body.setImmovable(true); b.type = type;
      this.seaBonuses.add(b);
    }

    spawnCrabBonus(){
      const pr = playableRectFor(this);
      const x = Phaser.Math.Between(40, pr.w-40), y = Phaser.Math.Between(this.beachTopY+20, pr.y + pr.h - 30);
      const b = this.add.text(x, y, 'ü¶Ä Bonus', { fontFamily:FONT, fontSize: 18, color:'#8B4513' }).setOrigin(0.5).setDepth(600);
      this.physics.add.existing(b); b.body.setCircle(26).setOffset(-26,-26); b.body.setImmovable(true); b.type='crab';
      this.seaBonuses.add(b);
    }

    spawnSwimmer(tint){
      const pr = playableRectFor(this);
      const x = Phaser.Math.Between(60, pr.w-60), y = Phaser.Math.Between(pr.y+90, this.beachTopY-80);
      const key = `swim_${tint}`; if (!this.textures.exists(key)) createSwimmerTexture(this, key, tint);
      const s = this.add.image(x,y,key).setDepth(50);
      this.physics.add.existing(s); s.body.setCircle(s.displayWidth/2); s.body.setCollideWorldBounds(true);
      const limbs = makeLimbs(this, 0x223344);
      const data = { sprite:s, dir: Phaser.Math.FloatBetween(-Math.PI, Math.PI), speed: 40, fov: Phaser.Math.DegToRad(40), range: 140, changeAt: 0, limbs };
      this.swimmers.push(data);
    }

    spawnCrabs(n=5){
      const pr = playableRectFor(this);
      for (let i=0;i<n;i++){
        const x = Phaser.Math.Between(40, pr.w-40);
        const y = Phaser.Math.Between(this.beachTopY+16, pr.y + pr.h - 32);
        const t = this.add.text(x, y, 'ü¶Ä', { fontFamily:FONT, fontSize: 22 }).setDepth(60);
        this.physics.add.existing(t); t.body.setCircle(12).setCollideWorldBounds(true);
        const crab = { sprite:t, dir: Phaser.Math.FloatBetween(-Math.PI, Math.PI), speed: 34, fov: Phaser.Math.DegToRad(35), range: 110, changeAt: 0, friend:false };
        this.crabs.push(crab);
      }
    }

    onCrabsBefriend(){ this.crabs.forEach(c=>c.friend=true); }

    nearestPoop(from){
      let best=null, bestD=1e9;
      this.poops.getChildren().forEach(p=>{
        if(!p.active) return;
        const d=Phaser.Math.Distance.Between(from.x,from.y,p.x,p.y);
        if(d<bestD){ best=p; bestD=d; }
      });
      return best;
    }

    triggerNarwhal(){
      if (!GameState.hasNarwhal) return;
      GameState.hasNarwhal = false;
      this.btnNar.setStyle({ backgroundColor:'#555' });
      GameState.stats.bonusUsed++;
      addScore(-120,'bonus_used');

      const n = this.add.text(this.player.x, this.player.y, 'üêã', { fontFamily:FONT, fontSize: 26 }).setDepth(700);
      n._speed = 90; n._target = this.nearestPoop(n); this.narwhals.push(n);
      SFX.narwhal();
    }

    triggerSiren(){
      if (!GameState.hasSiren) return;
      GameState.hasSiren = false;
      this.btnSir.setStyle({ backgroundColor:'#555' });
      GameState.stats.bonusUsed++;
      addScore(-120,'bonus_used');

      const siren = this.add.text(this.player.x, this.player.y, 'üßú‚Äç‚ôÄÔ∏è', { fontFamily:FONT, fontSize: 26 }).setDepth(700);
      this.lifeguard.distractedUntil = this.time.now + 15000;
      this.time.delayedCall(15000, ()=>{ siren.destroy(); });
      SFX.siren();
    }

    triggerTornado(){
      if (!GameState.hasTornado) return;
      GameState.hasTornado = false;
      this.btnTor.setStyle({ backgroundColor:'#555' });
      GameState.stats.bonusUsed++;
      addScore(-120,'bonus_used');

      this.tornado = { x: this.player.x, y: this.player.y, until: this.time.now + 15000 };
      SFX.tornado();
    }

    dropPoop(){
      if (GameState.poopMeter <= 0) return;
      const chunk = Math.min(GameState.poopMeter, 0.2);
      GameState.poopMeter = Math.max(0, Math.min(1, GameState.poopMeter - chunk));
      addScore(+10,'drop_poop');

      const p = this.add.text(this.player.x, this.player.y, 'üí©', { fontFamily:FONT, fontSize: 20}).setDepth(500);
      p._tDrop = this.time.now; p._ttlMs = 60000; p._stranded=false;
      p._label = this.add.text(p.x, p.y-18, '60', { fontFamily:FONT, fontSize: 12, color:'#001' }).setOrigin(0.5).setDepth(501);
      this.poops.add(p); SFX.drop();
    }

    update(time, delta){
      const dt = delta/1000;
      const pr = playableRectFor(this);
      const { width, height } = this.scale;

      const body=this.player.body; body.setVelocity(0);

      const onBeach = (this.player.y >= this.beachTopY);
      const speed = onBeach ? 150 : 120;

      if (this.cursors.left.isDown||this.wasd.A.isDown) body.setVelocityX(-speed); else if (this.cursors.right.isDown||this.wasd.D.isDown) body.setVelocityX(speed);
      if (this.cursors.up.isDown||this.wasd.W.isDown) body.setVelocityY(-speed); else if (this.cursors.down.isDown||this.wasd.S.isDown) body.setVelocityY(speed);

      if (this.pointerTarget){
        const dx=this.pointerTarget.x-this.player.x, dy=this.pointerTarget.y-this.player.y, dist=Math.hypot(dx,dy);
        if (dist>6) body.setVelocity((dx/dist)*speed,(dy/dist)*speed);
        else { this.pointerTarget=null; this.pointerMarker.setVisible(false); }
      }

      // clamp player nel play area
      clampToPlayable(this, this.player);

      const cx = Math.cos(this.currentAngle)*this.currentSpeed;
      const cy = Math.sin(this.currentAngle)*this.currentSpeed;
      if (!onBeach){ body.velocity.x += cx; body.velocity.y += cy; }

      // freccia corrente
      this.currentArrow.clear();
      this.currentArrow.fillStyle(0x002244, 0.15); this.currentArrow.fillCircle(40, 40, 18);
      this.currentArrow.lineStyle(5, 0xfff176, 0.95);
      const ax=40, ay=40;
      const ex=ax + Math.cos(this.currentAngle)*32, ey=ay + Math.sin(this.currentAngle)*32;
      this.currentArrow.lineBetween(ax, ay, ex, ey);
      this.currentArrow.fillStyle(0xfff176, 1);
      this.currentArrow.fillTriangle(
        ex, ey,
        ex - Math.cos(this.currentAngle+0.5)*10, ey - Math.sin(this.currentAngle+0.5)*10,
        ex - Math.cos(this.currentAngle-0.5)*10, ey - Math.sin(this.currentAngle-0.5)*10
      );

      // bagnino sweep
      if (time >= this.lifeguard.distractedUntil){
        this.lifeguard.dir += this.lifeguard.speed * dt;
        if (this.lifeguard.dir > this.lifeguard.sweepMax || this.lifeguard.dir < this.lifeguard.sweepMin){
          this.lifeguard.speed *= -1;
          this.lifeguard.dir = Phaser.Math.Clamp(this.lifeguard.dir, this.lifeguard.sweepMin, this.lifeguard.sweepMax);
        }
      }

      // swimmers
      for (const s of this.swimmers){
        if (time > s.changeAt){ s.dir = Phaser.Math.FloatBetween(-Math.PI, Math.PI); s.changeAt = time + Phaser.Math.Between(1200, 2600); }
        let vx = Math.cos(s.dir)*s.speed + cx, vy = Math.sin(s.dir)*s.speed + cy;

        if (this.tornado && time < this.tornado.until){
          const dx = this.tornado.x - s.sprite.x, dy = this.tornado.y - s.sprite.y; const d = Math.hypot(dx,dy)||1; const pull = 120;
          vx += (dx/d)*pull; vy += (dy/d)*pull;
        }
        s.sprite.body.setVelocity(vx, vy);

        const moving = Math.hypot(vx,vy)>5;
        updateLimbs(s.limbs, s.sprite.x, s.sprite.y, moving, time/1000);
      }

      // tornado
      if (this.tornado && time >= this.tornado.until){ this.tornado=null; this.tornadoGfx.clear(); }
      this.tornadoGfx.clear();
      if (this.tornado){
        this.tornadoGfx.lineStyle(3, 0x00695c, 0.9);
        this.tornadoGfx.strokeCircle(this.tornado.x, this.tornado.y, 24);
        this.tornadoGfx.strokeCircle(this.tornado.x, this.tornado.y, 12);
        this.tornadoGfx.strokeCircle(this.tornado.x, this.tornado.y, 36);
      }

      // narvali
      for (const n of this.narwhals){
        if (!n.active) continue;
        if (!n._target || !n._target.active) n._target = this.nearestPoop(n);
        if (n._target){
          const dx = n._target.x - n.x, dy = n._target.y - n.y; const d = Math.hypot(dx,dy)||1;
          n.x += (dx/d)*n._speed*dt + cx*dt; n.y += (dy/d)*n._speed*dt + cy*dt;
          if (d<10 && n._target.active){
            n._target._label?.destroy(); n._target.destroy(); n._target = this.nearestPoop(n);
            addScore(+40,'poop_removed');
            SFX.narwhal();
          }
        } else {
          n.x += cx*dt; n.y += cy*dt; n._despawnAt = n._despawnAt || (time+2000); if (time>=n._despawnAt){ n.destroy(); }
        }
      }

      // poops drift
      this.poops.getChildren().forEach(p=>{
        const nowBeach = (p.y >= this.beachTopY);
        if (!p._stranded && !nowBeach){ p.x += cx*dt; p.y += cy*dt; }
        if (nowBeach) p._stranded = true;

        p._label?.setPosition(p.x, p.y-18);
        const left = Math.max(0, Math.ceil((p._ttlMs - (time - p._tDrop))/1000));
        p._label?.setText(left.toString());
        if (left<=0 && p.active){ p._label?.destroy(); p.destroy(); }
        p.x = Phaser.Math.Clamp(p.x, 8, width-8);
        p.y = Phaser.Math.Clamp(p.y, pr.y+8, pr.y+pr.h-8);
      });

      // crabs
      for (const c of this.crabs){
        if (time > c.changeAt){ c.dir = Phaser.Math.FloatBetween(-Math.PI, Math.PI); c.changeAt = time + Phaser.Math.Between(1000, 2200); }
        let vx = Math.cos(c.dir)*c.speed, vy = Math.sin(c.dir)*c.speed;
        const nx = c.sprite.x + vx*dt, ny = c.sprite.y + vy*dt;
        if (ny < this.beachTopY+10 || ny > pr.y + pr.h - 16) { c.dir = -c.dir; continue; }
        c.sprite.x = Phaser.Math.Clamp(nx, 16, width-16);
        c.sprite.y = Phaser.Math.Clamp(ny, this.beachTopY+10, pr.y + pr.h - 16);

        if (c.friend){
          const target = this.nearestPoop(c.sprite);
          if (target){
            const dx=target.x-c.sprite.x, dy=target.y-c.sprite.y, d=Math.hypot(dx,dy)||1;
            c.sprite.x += (dx/d)*50*dt; c.sprite.y += (dy/d)*50*dt;
            if (d<12 && target.active){
              target._label?.destroy(); target.destroy();
              addScore(+40,'poop_removed');
              SFX.crab();
            }
          }
        }
      }

      // vision cones
      this.visionGfx.clear();
      this.drawCone(this.visionGfx, this.lifeguard.x, this.lifeguard.y, this.lifeguard.dir, this.lifeguard.fov, this.lifeguard.range, 0xff0000, 0.15);
      for (const s of this.swimmers){ this.drawCone(this.visionGfx, s.sprite.x, s.sprite.y, s.dir, s.fov, s.range, 0xff8800, 0.12); }
      if (!GameState.crabsFriendly){
        for (const c of this.crabs){
          const dir = c.dir, fov = Phaser.Math.DegToRad(35), range = 80;
          this.drawCone(this.visionGfx, c.sprite.x, c.sprite.y, dir, fov, range, 0xaa5500, 0.12);
        }
      }

      if (this.isAnyPoopDetected()){ SFX.lose(); resetForNewRun(); this.scene.start('LoseScene', { reason:'detected' }); return; }

      if (GameState.poopMeter <= 0 && this.poops.countActive(true) === 0){
        SFX.win();
        this.scene.start('BossScene');
        return;
      }

      // HUD top + score
      const barW=220, barH=22, pad=16, xRight = width - barW - pad;
      this.ui.clear();
      drawProgressBar(this.ui, xRight, 10, barW, barH, GameState.poopMeter, 0x9b5a1a);
      drawProgressBar(this.ui, xRight, 10+barH+6, barW, barH, GameState.stomach,   0xcc3333);
      this.poopText.setPosition(xRight+barW, 10).setText(`Pup√π: ${Math.round(GameState.poopMeter*100)}%`);
      this.stomachText.setPosition(xRight+barW, 10+barH+6).setText(`Mal di pancia: ${Math.round(GameState.stomach*100)}%`);
      this.scoreText.setText(`Score: ${GameState.score}`);

      const status = [
        GameState.hasNarwhal? 'Narvalo pronto' : 'Narvalo no',
        GameState.hasSiren?   'Sirena pronta'  : 'Sirena no',
        GameState.hasTornado? 'Tornado pronto' : 'Tornado no',
        GameState.crabsFriendly? 'Granchi amici' : 'Granchi neutrali'
      ];
      const distractLeft = Math.max(0, Math.ceil((this.lifeguard.distractedUntil - time)/1000));
      this.uiText.setText(`Cacchette: ${this.poops.countActive(true)}`);
      this.statusText.setText(status.join('  ‚Ä¢  ') + (distractLeft>0?`  ‚Ä¢  Bagnino distratto: ${distractLeft}s`:''));      

      if (Phaser.Input.Keyboard.JustDown(this.keySpace)) { this.dropPoop(); SFX.drop(); }
      if (Phaser.Input.Keyboard.JustDown(this.keyS)) { this.triggerSiren(); }
      if (Phaser.Input.Keyboard.JustDown(this.keyN)) { this.triggerNarwhal(); }
      if (Phaser.Input.Keyboard.JustDown(this.keyT)) { this.triggerTornado(); }

      // ALI: se vai molto in alto sopra l‚Äôacqua -> vola (ali visibili, braccia nascoste)
      const flyThreshold = pr.y + 80; // ‚Äúmolto in alto‚Äù
      const flying = this.player.y < flyThreshold;
      this.wings.setVisible(flying);
      Object.values(this.playerLimbs.parts).forEach(p=>p.setVisible(!flying));
      if (flying) this.wings.update(this.player.x, this.player.y, time/1000);

      const moving = body.velocity.length() > 5;
      if (!flying) updateLimbs(this.playerLimbs, this.player.x, this.player.y, moving, time/1000);
    }

    drawCone(gfx, x, y, dir, fov, range, color, alpha){
      gfx.fillStyle(color, alpha);
      const a1 = dir - fov/2, a2 = dir + fov/2;
      const p1 = { x: x + Math.cos(a1)*range, y: y + Math.sin(a1)*range };
      const p2 = { x: x + Math.cos(a2)*range, y: y + Math.sin(a2)*range };
      gfx.beginPath(); gfx.moveTo(x,y); gfx.lineTo(p1.x, p1.y); gfx.arc(x,y,range,a1,a2); gfx.lineTo(x,y); gfx.closePath(); gfx.fillPath();
    }

    isAnyPoopDetected(){
      for (const p of this.poops.getChildren()){
        if (!p.active) continue;
        if (isInVisionCone({x:this.lifeguard.x,y:this.lifeguard.y}, this.lifeguard.dir, this.lifeguard.fov, this.lifeguard.range, {x:p.x,y:p.y})) return true;
      }
      for (const s of this.swimmers){
        for (const p of this.poops.getChildren()){
          if (!p.active) continue;
          if (isInVisionCone({x:s.sprite.x,y:s.sprite.y}, s.dir, s.fov, s.range, {x:p.x,y:p.y})) return true;
        }
      }
      if (!GameState.crabsFriendly){
        for (const c of this.crabs){
          for (const p of this.poops.getChildren()){
            if (!p.active) continue;
            if (isInVisionCone({x:c.sprite.x,y:c.sprite.y}, c.dir, Phaser.Math.DegToRad(35), 80, {x:p.x,y:p.y})) return true;
          }
        }
      }
      return false;
    }

    updateStatusTexts(){ /* placeholder */ }

    shutdown(){
      this.playerLimbs?.destroy?.();
      this.wings?.destroy?.();
    }
  }

  /* ============================================================
   * BOSS SCENE ‚Äî UI SAFE + SHOOT BUTTON COMODO + SCORE + WINGS
   * ============================================================ */
  class BossScene extends Phaser.Scene {
    constructor(){ super('BossScene'); }

    create(){
      const { width, height } = this.scale;
      const pr = setWorldBoundsToPlayable(this);

      this.cameras.main.setBackgroundColor('#0d1117');

      this.playerHp = 1;
      this.bossHp   = 1;

      const bg = this.add.graphics();
      bg.fillStyle(0x0b3d91,1); bg.fillRect(0,0,width,pr.y*0.6);
      bg.fillStyle(0x1976d2,1); bg.fillRect(0,pr.y*0.6,width,pr.y*0.6);
      bg.fillStyle(0xf4e2b5,1); bg.fillRect(0,pr.y, width, pr.h);

      const key = `char_${GameState.selected.specie}_${GameState.selected.eta}_${GameState.selected.genere}`;
      if (!this.textures.exists(key)) createCharacterTexture(this, key, GameState.selected);

      this.player = this.add.image(width*0.2, pr.y + pr.h*0.72, key).setDepth(50);
      this.physics.add.existing(this.player);
      this.player.body.setCircle(this.player.displayWidth/2);
      this.player.body.setCollideWorldBounds(true);

      this.playerLimbs = makeLimbs(this, 0x000000);
      Object.values(this.playerLimbs.parts).forEach(p=>p.setDepth(51));
      this.wings = makeWings(this);
      this.wings.setDepth(52);

      const lifekey = 'lifeguard_tex';
      if (!this.textures.exists(lifekey)) createLifeguardTexture(this, lifekey);

      this.bossSprite = this.add.image(width*0.78, pr.y + pr.h*0.32, lifekey).setDepth(60);
      this.physics.add.existing(this.bossSprite);
      this.bossSprite.body.setCircle(this.bossSprite.displayWidth/2);
      this.bossSprite.body.setImmovable(true);

      this.bossBase = { x: this.bossSprite.x, y: this.bossSprite.y };
      this.bossBobT = 0;

      this.bossFrozenUntil = 0;
      this.lastBossShot = 0;
      this.bossShotInterval = 950;

      this.playerProjectiles = this.physics.add.group({ allowGravity:false, immovable:false });
      this.bossProjectiles   = this.physics.add.group({ allowGravity:false, immovable:false });

      this.canUseNarwhal = !!GameState.hasNarwhal;
      this.canUseSiren   = !!GameState.hasSiren;
      this.canUseTornado = !!GameState.hasTornado;
      this.canUseCrabs   = !!GameState.crabsFriendly;

      // consumati nel boss
      GameState.hasNarwhal = false;
      GameState.hasSiren   = false;
      GameState.hasTornado = false;
      GameState.crabsFriendly = false;

      // HUD top
      this.ui = this.add.graphics().setDepth(1000);
      this.playerHpText = this.add.text(16, 12, '', { fontFamily:FONT, fontSize: 14, color:'#ffffff' }).setDepth(1001);
      this.bossHpText   = this.add.text(width-16, 12, '', { fontFamily:FONT, fontSize: 14, color:'#ffffff' }).setOrigin(1,0).setDepth(1001);
      this.scoreText    = this.add.text(16, 36, '', { fontFamily:FONT, fontSize: 16, color:'#ffffff' }).setDepth(1001);

      this.infoText = this.add.text(width/2, 52,
        'Ultimo livello! Evita gli oggetti del bagnino, lancia üí© e usa i bonus rimasti!',
        { fontFamily:FONT, fontSize: 16, color:'#e3f2fd', align:'center', wordWrap:{ width: Math.min(760, width-40) } }
      ).setOrigin(0.5).setDepth(1001);

      // banda UI bottom
      this.btnMenu = makeUIButton(this,'‚¨Ö Menu', { bg:'#444' }).on('pointerdown',()=>{ resetForNewRun(); this.scene.start('MenuScene'); });
      this.btnRestart = makeUIButton(this,'‚ü≤ Ricomincia', { bg:'#444' }).on('pointerdown',()=>{ resetForNewRun(); this.scene.start('LandScene'); });

      // BONUS buttons
      this.btnNar = makeUIButton(this,'üêã', { fontSize: 22, bg: this.canUseNarwhal ? '#6a1b9a':'#555', padding:{left:12,right:12,top:8,bottom:8} })
        .on('pointerdown',()=> this.useNarwhal());
      this.btnSir = makeUIButton(this,'üßú‚Äç‚ôÄÔ∏è', { fontSize: 22, bg: this.canUseSiren ? '#2947a3':'#555', padding:{left:12,right:12,top:8,bottom:8} })
        .on('pointerdown',()=> this.useSiren());
      this.btnTor = makeUIButton(this,'üåÄ', { fontSize: 22, bg: this.canUseTornado ? '#00695c':'#555', padding:{left:12,right:12,top:8,bottom:8} })
        .on('pointerdown',()=> this.useTornado());
      this.btnCrab = makeUIButton(this,'ü¶Ä', { fontSize: 22, bg: this.canUseCrabs ? '#8B4513':'#555', padding:{left:12,right:12,top:8,bottom:8} })
        .on('pointerdown',()=> this.useCrabs());

      // ‚úÖ pulsante SPARA comodo: grande in basso a destra
      this.btnPoop = makeUIButton(this,'üí© SPARA', {
        fontSize: 22,
        bg:'#a34a00',
        padding:{left:16,right:16,top:10,bottom:10}
      }).on('pointerdown', ()=> this.shootPoop());

      // Tornado
      this.tornadoUntil = 0;
      this.tornadoGfx = this.add.graphics().setDepth(999);

      // Input
      this.cursors = this.input.keyboard.createCursorKeys();
      this.wasd = this.input.keyboard.addKeys('W,A,S,D');
      this.keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
      this.keyN = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.N);
      this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
      this.keyT = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.T);
      this.keyC = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.C);

      this.pointerTarget = null;
      this.pointerMarker = this.add.circle(0,0,8,0x000000,0.3).setVisible(false).setDepth(1000);
      const setPointerTarget = (p)=>{
        this.pointerTarget = { x:p.worldX, y:p.worldY };
        this.pointerMarker.setPosition(this.pointerTarget.x, this.pointerTarget.y).setVisible(true);
      };
      this.input.on('pointerdown', setPointerTarget);
      this.input.on('pointermove', (p)=>{ if (p.isDown) setPointerTarget(p); });

      // Collisioni
      this.physics.add.overlap(this.player, this.bossProjectiles, this.onPlayerHit, null, this);
      this.physics.add.overlap(this.bossSprite, this.playerProjectiles, this.onBossHit, null, this);

      this._lastPlayerShot = 0;

      this.scale.on('resize', ()=> this.layoutUI());
      this.layoutUI();
      this.updateHud();
    }

    layoutUI(){
      const pr = setWorldBoundsToPlayable(this);
      const { width } = this.scale;

      const bandY = pr.y + pr.h;
      const bandH = pr.band;

      const band = this._bandGfx || (this._bandGfx = this.add.graphics().setDepth(900));
      band.clear();
      band.fillStyle(0x0b0f16, 0.75);
      band.fillRect(0, bandY, width, bandH);
      band.lineStyle(2, 0x223344, 0.9);
      band.strokeRect(0, bandY, width, bandH);

      // a sinistra: menu/restart/bonus ‚Äî a destra: SPARA grande
      // posizionamento manuale per dare ‚Äúcomfort‚Äù su touch
      const pad = 10;
      const poopW = this.btnPoop.displayWidth + 10;
      const leftArea = { x:0, y:bandY, w: Math.max(200, width - poopW - 2*pad), h: bandH };
      layoutButtonRow(this, [this.btnMenu, this.btnRestart, this.btnNar, this.btnSir, this.btnTor, this.btnCrab], leftArea);

      // SPARA in basso a destra centrato verticalmente
      const y = bandY + Math.floor((bandH - this.btnPoop.displayHeight)/2);
      this.btnPoop.setPosition(width - pad - this.btnPoop.displayWidth - 10, y);

      // clamp player nel play
      clampToPlayable(this, this.player);
    }

    updateHud(){
      const { width } = this.scale;
      const barW = (width/2) - 40, barH = 20;

      this.ui.clear();
      drawProgressBar(this.ui, 16, 32, barW, barH, this.playerHp, 0x4caf50);
      drawProgressBar(this.ui, width - barW - 16, 32, barW, barH, this.bossHp, 0xe53935);

      this.playerHpText.setText(`Vita: ${Math.round(this.playerHp*100)}%`);
      this.bossHpText.setText(`Vita bagnino: ${Math.round(this.bossHp*100)}%`);
      this.scoreText.setText(`Score: ${GameState.score}`);
    }

    spawnProjectile({ x, y, emoji, fontSize, vx, vy, group, radius=16, depth=200 }){
      const p = this.add.text(x, y, emoji, { fontFamily:FONT, fontSize }).setOrigin(0.5).setDepth(depth);
      this.physics.add.existing(p);
      p.body.setAllowGravity(false);
      p.body.setCircle(radius).setOffset(-radius, -radius);
      p.body.setVelocity(vx, vy);
      p._vx = vx; p._vy = vy;
      group.add(p);
      return p;
    }

    bossShoot(time){
      if (time < this.lastBossShot + this.bossShotInterval) return;
      if (time < this.bossFrozenUntil) return;

      this.lastBossShot = time;
      const emojis = ['ü©¥','üõü','üèê','ü™£','üèñÔ∏è'];
      const emoji = Phaser.Utils.Array.GetRandom(emojis);

      const dx = this.player.x - this.bossSprite.x;
      const dy = this.player.y - this.bossSprite.y;
      const dist = Math.hypot(dx,dy) || 1;
      const speed = 260;

      this.spawnProjectile({
        x: this.bossSprite.x,
        y: this.bossSprite.y,
        emoji,
        fontSize: 28,
        vx: (dx/dist)*speed,
        vy: (dy/dist)*speed,
        group: this.bossProjectiles,
        radius: 18,
        depth: 220
      });
    }

    shootPoop(){
      const now = this.time.now;
      if (now < this._lastPlayerShot + 210) return;
      this._lastPlayerShot = now;

      const dx = this.bossSprite.x - this.player.x;
      const dy = this.bossSprite.y - this.player.y;
      const dist = Math.hypot(dx,dy) || 1;
      const speed = 320;

      this.spawnProjectile({
        x: this.player.x,
        y: this.player.y,
        emoji: 'üí©',
        fontSize: 24,
        vx: (dx/dist)*speed,
        vy: (dy/dist)*speed,
        group: this.playerProjectiles,
        radius: 14,
        depth: 230
      });

      addScore(+8,'shoot');
      SFX.drop();
    }

    useNarwhal(){
      if (!this.canUseNarwhal) return;
      this.canUseNarwhal = false;
      this.btnNar.setStyle({ backgroundColor:'#555' });

      GameState.stats.bonusUsed++;
      addScore(-120,'bonus_used');

      const fx = this.add.text(this.player.x, this.player.y - 40, 'üêã', { fontFamily:FONT, fontSize: 32 }).setOrigin(0.5).setDepth(1000);
      this.tweens.add({ targets: fx, y: fx.y - 18, alpha: 0, duration: 550, onComplete:()=>fx.destroy() });

      this.bossProjectiles.getChildren().forEach(p=>p.destroy());
      SFX.narwhal();
    }

    useSiren(){
      if (!this.canUseSiren) return;
      this.canUseSiren = false;
      this.btnSir.setStyle({ backgroundColor:'#555' });

      GameState.stats.bonusUsed++;
      addScore(-120,'bonus_used');

      this.bossFrozenUntil = this.time.now + 6500;
      const sir = this.add.text(this.bossSprite.x, this.bossSprite.y - 64, 'üßú‚Äç‚ôÄÔ∏è', { fontFamily:FONT, fontSize: 28 }).setOrigin(0.5).setDepth(1000);
      this.tweens.add({ targets:sir, y: sir.y - 22, alpha: 0, duration: 1400, onComplete:()=> sir.destroy() });

      SFX.siren();
    }

    useTornado(){
      if (!this.canUseTornado) return;
      this.canUseTornado = false;
      this.btnTor.setStyle({ backgroundColor:'#555' });

      GameState.stats.bonusUsed++;
      addScore(-120,'bonus_used');

      this.tornadoUntil = this.time.now + 5200;
      SFX.tornado();
    }

    useCrabs(){
      if (!this.canUseCrabs) return;
      this.canUseCrabs = false;
      this.btnCrab.setStyle({ backgroundColor:'#555' });

      GameState.stats.bonusUsed++;
      addScore(-120,'bonus_used');

      for (let i=0;i<3;i++){
        const startX = 60 + i*34;
        const startY = playableRectFor(this).y + playableRectFor(this).h - 40;

        const dx = this.bossSprite.x - startX;
        const dy = this.bossSprite.y - startY;
        const dist = Math.hypot(dx,dy) || 1;
        const speed = 340;

        this.spawnProjectile({
          x: startX,
          y: startY,
          emoji: 'ü¶Ä',
          fontSize: 24,
          vx: (dx/dist)*speed,
          vy: (dy/dist)*speed,
          group: this.playerProjectiles,
          radius: 14,
          depth: 230
        });
      }

      SFX.crab();
    }

    onPlayerHit(player, projectile){
      projectile.destroy();
      this.playerHp = Math.max(0, this.playerHp - 0.18);
      GameState.stats.bossHitsTaken++;
      addScore(-180,'hit_taken');

      this.updateHud();
      if (this.playerHp <= 0) this.endLose();
      else SFX.wrong();
    }

    onBossHit(boss, projectile){
      projectile.destroy();
      this.bossHp = Math.max(0, this.bossHp - 0.12);
      addScore(+90,'boss_hit');

      this.updateHud();
      if (this.bossHp <= 0) this.endWin();
      else SFX.eat();
    }

    endWin(){
      SFX.win();
      GameState.stats.didWin = true;
      GameState.stats.totalTimeSec = (performance.now() - GameState.stats.startMs)/1000;
      this.scene.start('WinScene');
    }

    endLose(){
      SFX.lose();
      GameState.stats.didWin = false;
      GameState.stats.totalTimeSec = (performance.now() - GameState.stats.startMs)/1000;
      this.scene.start('LoseScene', { reason:'boss' });
    }

    update(time, delta){
      const dt = delta/1000;
      const pr = playableRectFor(this);
      const { width, height } = this.scale;

      this.bossBobT += dt;
      this.bossSprite.x = this.bossBase.x + Math.sin(this.bossBobT*1.1)*10;
      this.bossSprite.y = this.bossBase.y + Math.cos(this.bossBobT*1.5)*6;

      // movimento player
      const body = this.player.body;
      body.setVelocity(0);
      const speed = 200;

      if (this.cursors.left.isDown || this.wasd.A.isDown) body.setVelocityX(-speed);
      else if (this.cursors.right.isDown || this.wasd.D.isDown) body.setVelocityX(speed);
      if (this.cursors.up.isDown || this.wasd.W.isDown) body.setVelocityY(-speed);
      else if (this.cursors.down.isDown || this.wasd.S.isDown) body.setVelocityY(speed);

      if (this.pointerTarget){
        const dx = this.pointerTarget.x - this.player.x;
        const dy = this.pointerTarget.y - this.player.y;
        const dist = Math.hypot(dx,dy);
        if (dist > 6) body.setVelocity((dx/dist)*speed, (dy/dist)*speed);
        else { this.pointerTarget = null; this.pointerMarker.setVisible(false); }
      }

      // clamp in play area
      clampToPlayable(this, this.player);

      if (Phaser.Input.Keyboard.JustDown(this.keySpace)) this.shootPoop();

      if (Phaser.Input.Keyboard.JustDown(this.keyN)) this.useNarwhal();
      if (Phaser.Input.Keyboard.JustDown(this.keyS)) this.useSiren();
      if (Phaser.Input.Keyboard.JustDown(this.keyT)) this.useTornado();
      if (Phaser.Input.Keyboard.JustDown(this.keyC)) this.useCrabs();

      this.bossShoot(time);

      // FIX: proiettili sempre con velocity
      this.playerProjectiles.getChildren().forEach(p=>{
        if (!p.active) return;
        if (p.body.velocity.lengthSq() < 1 && (p._vx || p._vy)) p.body.setVelocity(p._vx, p._vy);
      });
      this.bossProjectiles.getChildren().forEach(p=>{
        if (!p.active) return;
        if (p.body.velocity.lengthSq() < 1 && (p._vx || p._vy)) p.body.setVelocity(p._vx, p._vy);
      });

      this.tornadoGfx.clear();
      if (time < this.tornadoUntil){
        this.tornadoGfx.lineStyle(2, 0x00695c, 0.9);
        this.tornadoGfx.strokeCircle(this.player.x, this.player.y, 42);
        this.tornadoGfx.strokeCircle(this.player.x, this.player.y, 26);

        this.bossProjectiles.getChildren().forEach(p=>{
          if (!p.active) return;
          const dx = p.x - this.player.x;
          const dy = p.y - this.player.y;
          const dist = Math.hypot(dx,dy) || 1;
          const push = 340;
          p.body.setVelocity((dx/dist)*push, (dy/dist)*push);
          p._vx = p.body.velocity.x; p._vy = p.body.velocity.y;
        });
      }

      const killOut = (obj)=>{
        if (obj.x < -60 || obj.x > width+60 || obj.y < pr.y-80 || obj.y > pr.y+pr.h+80) obj.destroy();
      };
      this.playerProjectiles.getChildren().forEach(killOut);
      this.bossProjectiles.getChildren().forEach(killOut);

      // ALI: se vai molto in alto dentro area gioco -> vola
      const flyThreshold = pr.y + 70;
      const flying = this.player.y < flyThreshold;
      this.wings.setVisible(flying);
      Object.values(this.playerLimbs.parts).forEach(p=>p.setVisible(!flying));
      if (flying) this.wings.update(this.player.x, this.player.y, time/1000);

      const moving = body.velocity.length() > 5;
      if (!flying) updateLimbs(this.playerLimbs, this.player.x, this.player.y, moving, time/1000);

      this.updateHud();
    }

    shutdown(){
      this.playerLimbs?.destroy?.();
      this.wings?.destroy?.();
    }
  }

  class LoseScene extends Phaser.Scene {
    constructor(){ super('LoseScene'); }
    create(data){
      const { width, height } = this.scale;
      this.cameras.main.setBackgroundColor('#222');

      // ‚úÖ Messaggi corretti
      let title = 'Ops! Sei stato scoperto! üö®';
      if (data?.reason==='overeat' || data?.reason==='stomachache'){
        title = 'Oh no! Hai mangiato troppo e ti sei fatto cacca addosso! üí•üí©';
      }
      if (data?.reason==='detected'){
        title = 'Ops! Ti hanno visto! üö®üí©';
      }
      if (data?.reason==='boss'){
        title = 'Sei stato sconfitto dal bagnino! ü©¥üí•';
      }

      // calcola score finale run (anche in caso di lose)
      GameState.stats.didWin = false;
      GameState.stats.totalTimeSec = (performance.now() - GameState.stats.startMs)/1000;
      const finalScore = computeFinalScore(GameState.stats);

      this.add.text(width/2, height/2 - 80, title, { fontFamily:FONT, fontSize: 24, color:'#ffffff', align:'center', wordWrap:{ width: Math.min(680, width-40) } }).setOrigin(0.5);

      this.add.text(width/2, height/2 - 30, `Score finale: ${finalScore}`, { fontFamily:FONT, fontSize: 22, color:'#e3f2fd' }).setOrigin(0.5);

      // input nome + leaderboard (DOM)
      const container = document.getElementById('game-container');
      const wrap = document.createElement('div');
      wrap.style.position = 'absolute';
      wrap.style.left = '50%';
      wrap.style.top = '62%';
      wrap.style.transform = 'translate(-50%,-50%)';
      wrap.style.background = 'rgba(0,0,0,0.55)';
      wrap.style.padding = '12px 14px';
      wrap.style.borderRadius = '14px';
      wrap.style.color = 'white';
      wrap.style.fontFamily = 'system-ui, Arial, sans-serif';
      wrap.style.width = 'min(520px, 92vw)';
      wrap.style.boxShadow = '0 10px 24px rgba(0,0,0,0.35)';

      wrap.innerHTML = `
        <div style="font-size:14px; opacity:0.9; margin-bottom:8px;">Salva in classifica (facoltativo)</div>
        <div style="display:flex; gap:8px; align-items:center; margin-bottom:10px;">
          <input id="lb-name" placeholder="Il tuo nome" maxlength="18" style="flex:1; padding:10px 12px; border-radius:10px; border:0; outline:none; font-size:16px;">
          <button id="lb-save" style="padding:10px 12px; border-radius:10px; border:0; background:#0a7d33; color:#fff; font-size:16px; cursor:pointer;">Salva</button>
        </div>
        <div id="lb-table" style="font-size:14px; line-height:1.4;"></div>
      `;
      container.style.position = 'relative';
      container.appendChild(wrap);

      const renderTable = (list)=>{
        const rows = list.map((e,i)=>`<div style="display:flex; justify-content:space-between; gap:8px;">
          <div>${i+1}. <b>${escapeHtml(e.name)}</b></div><div>${e.score}</div>
        </div>`).join('');
        wrap.querySelector('#lb-table').innerHTML =
          `<div style="opacity:0.85; margin-bottom:6px;">Top 10</div>` +
          (rows || `<div style="opacity:0.7;">Nessun punteggio salvato ancora.</div>`);
      };
      const escapeHtml = (s)=> String(s).replace(/[&<>"']/g, (m)=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
      renderTable(Leaderboard.load());

      wrap.querySelector('#lb-save').addEventListener('click', ()=>{
        const inp = wrap.querySelector('#lb-name');
        const name = (inp.value || '').trim();
        if (!name) return;
        const list = Leaderboard.add({ name, score: finalScore, when: Date.now() });
        renderTable(list);
        inp.value = '';
      });

      const cleanupDom = ()=>{
        try { wrap.remove(); } catch(_) {}
      };

      this.add.text(width/2 - 130, height - 60, '‚¨Ö Menu', { fontFamily:FONT, fontSize:22, color:'#fff', backgroundColor:'#444', padding:{left:10,right:10,top:6,bottom:6} })
        .setOrigin(0.5).setInteractive({useHandCursor:true})
        .on('pointerdown', ()=>{ cleanupDom(); resetForNewRun(); this.scene.start('MenuScene'); });

      this.add.text(width/2 + 130, height - 60, '‚ü≤ Riprova', { fontFamily:FONT, fontSize:22, color:'#fff', backgroundColor:'#444', padding:{left:10,right:10,top:6,bottom:6} })
        .setOrigin(0.5).setInteractive({useHandCursor:true})
        .on('pointerdown', ()=>{ cleanupDom(); resetForNewRun(); this.scene.start('LandScene'); });

      // se cambi scena via tasti/back, pulisci
      this.events.once('shutdown', cleanupDom);
      this.events.once('destroy', cleanupDom);
    }
  }

  class WinScene extends Phaser.Scene {
    constructor(){ super('WinScene'); }
    create(){
      const { width, height } = this.scale;
      this.cameras.main.setBackgroundColor('#1b5e20');

      GameState.stats.didWin = true;
      GameState.stats.totalTimeSec = (performance.now() - GameState.stats.startMs)/1000;
      const finalScore = computeFinalScore(GameState.stats);

      this.add.text(width/2, height/2 - 80, 'Ce l\'hai fatta! ü§´üåä', { fontFamily:FONT, fontSize: 28, color:'#ffffff' }).setOrigin(0.5);
      this.add.text(width/2, height/2 - 40, 'Hai sconfitto il boss finale! Bravo stratega!', { fontFamily:FONT, fontSize: 16, color:'#e8f5e9' }).setOrigin(0.5);
      this.add.text(width/2, height/2 + 5, `Score finale: ${finalScore}`, { fontFamily:FONT, fontSize: 24, color:'#e3f2fd' }).setOrigin(0.5);

      // input nome + leaderboard (DOM)
      const container = document.getElementById('game-container');
      const wrap = document.createElement('div');
      wrap.style.position = 'absolute';
      wrap.style.left = '50%';
      wrap.style.top = '62%';
      wrap.style.transform = 'translate(-50%,-50%)';
      wrap.style.background = 'rgba(0,0,0,0.45)';
      wrap.style.padding = '12px 14px';
      wrap.style.borderRadius = '14px';
      wrap.style.color = 'white';
      wrap.style.fontFamily = 'system-ui, Arial, sans-serif';
      wrap.style.width = 'min(520px, 92vw)';
      wrap.style.boxShadow = '0 10px 24px rgba(0,0,0,0.25)';

      wrap.innerHTML = `
        <div style="font-size:14px; opacity:0.9; margin-bottom:8px;">Salva in classifica</div>
        <div style="display:flex; gap:8px; align-items:center; margin-bottom:10px;">
          <input id="lb-name" placeholder="Il tuo nome" maxlength="18" style="flex:1; padding:10px 12px; border-radius:10px; border:0; outline:none; font-size:16px;">
          <button id="lb-save" style="padding:10px 12px; border-radius:10px; border:0; background:#0a7d33; color:#fff; font-size:16px; cursor:pointer;">Salva</button>
        </div>
        <div id="lb-table" style="font-size:14px; line-height:1.4;"></div>
      `;
      container.style.position = 'relative';
      container.appendChild(wrap);

      const renderTable = (list)=>{
        const rows = list.map((e,i)=>`<div style="display:flex; justify-content:space-between; gap:8px;">
          <div>${i+1}. <b>${escapeHtml(e.name)}</b></div><div>${e.score}</div>
        </div>`).join('');
        wrap.querySelector('#lb-table').innerHTML =
          `<div style="opacity:0.85; margin-bottom:6px;">Top 10</div>` +
          (rows || `<div style="opacity:0.7;">Nessun punteggio salvato ancora.</div>`);
      };
      const escapeHtml = (s)=> String(s).replace(/[&<>"']/g, (m)=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
      renderTable(Leaderboard.load());

      wrap.querySelector('#lb-save').addEventListener('click', ()=>{
        const inp = wrap.querySelector('#lb-name');
        const name = (inp.value || '').trim();
        if (!name) return;
        const list = Leaderboard.add({ name, score: finalScore, when: Date.now() });
        renderTable(list);
        inp.value = '';
      });

      const cleanupDom = ()=>{
        try { wrap.remove(); } catch(_) {}
      };

      this.add.text(width/2 - 130, height - 60, '‚¨Ö Menu', { fontFamily:FONT, fontSize:22, color:'#fff', backgroundColor:'#2e7d32', padding:{left:10,right:10,top:6,bottom:6} })
        .setOrigin(0.5).setInteractive({useHandCursor:true})
        .on('pointerdown', ()=>{ cleanupDom(); resetForNewRun(); this.scene.start('MenuScene'); });

      this.add.text(width/2 + 130, height - 60, '‚ü≤ Gioca ancora', { fontFamily:FONT, fontSize:22, color:'#fff', backgroundColor:'#2e7d32', padding:{left:10,right:10,top:6,bottom:6} })
        .setOrigin(0.5).setInteractive({useHandCursor:true})
        .on('pointerdown', ()=>{ cleanupDom(); resetForNewRun(); this.scene.start('LandScene'); });

      this.events.once('shutdown', cleanupDom);
      this.events.once('destroy', cleanupDom);
    }
  }

  // ========== BOOT ==========
  function setupAudioUnlock(){
    const gate = document.getElementById('audio-gate');
    const btn  = document.getElementById('audio-btn');
    if (!gate || !btn) return;
    gate.style.display = 'flex';
    const unlock = () => {
      try { ensureAudioContext().resume(); } catch(_) {}
      gate.style.display = 'none';
      window.removeEventListener('pointerdown', unlock);
    };
    btn.addEventListener('click', unlock);
    window.addEventListener('pointerdown', unlock, { once:true });
  }

  function createGame(options={}){
    const parent = options.parent || 'game-container';
    setupAudioUnlock();
    const config = {
      type: Phaser.AUTO,
      width: 960,
      height: 540,
      backgroundColor: '#0d1117',
      parent,
      // ‚úÖ manteniamo FIT, ma con UI interna che si adatta sempre
      scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
      physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
      scene: [MenuScene, LandScene, SeaScene, BossScene, LoseScene, WinScene]
    };
    return new Phaser.Game(config);
  }

  window.PooPooPanda = { createGame };

  window.addEventListener('DOMContentLoaded', ()=>{
    const el = document.getElementById('game-container');
    if (el) window.PooPooPanda._game = createGame({ parent: 'game-container' });
  });
  </script>
</body>
</html>
