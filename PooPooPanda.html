<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Poo Poo Panda ‚Äî Single-file (versione base + nuove feature)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0d1117; }
    body { font-family: 'Segoe UI Emoji','Apple Color Emoji','Noto Color Emoji', system-ui, Arial, sans-serif; }
    #game-container { width:100vw; height:100vh; display:flex; align-items:center; justify-content:center; }
    .audio-unlock { position: fixed; inset: 0; display: none; align-items:center; justify-content:center; background: rgba(0,0,0,0.6); z-index: 999; }
    .audio-unlock > button { font-size: 18px; padding: 10px 14px; border-radius: 12px; border: 0; background: #0a7d33; color: #fff; box-shadow: 0 6px 16px rgba(0,0,0,0.35); cursor:pointer; }
    .hint { position: fixed; bottom: 8px; left: 8px; background: rgba(255,255,255,0.9); padding: 6px 8px; border-radius: 8px; font-size: 12px; z-index: 50; }
  </style>
</head>
<body>
  <div id="game-container"></div>
  <div id="audio-gate" class="audio-unlock"><button id="audio-btn">üîà Tocca per attivare audio</button></div>
  <div class="hint">Tocco/click per muovere ‚Ä¢ SPAZIO: üí© ‚Ä¢ N: üêã ‚Ä¢ S: üßú‚Äç‚ôÄÔ∏è ‚Ä¢ T: üåÄ</div>

  <!-- Phaser UMD -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.87.0/dist/phaser.min.js"></script>

  <script type="module">
  /*
   * Poo Poo Panda ‚Äî Single-file (spacchettabile)
   * Base: versione precedente stabile (senza overlay Pausa/Impostazioni, n√© mission timer).
   * Modifiche richieste incluse:
   * 1) Barra Pup√π spostata in alto a destra (anche in mare) + nuova barra ‚ÄúMal di pancia‚Äù.
   * 2) Fase Terra: sconfitta per ‚Äúaver mangiato troppo‚Äù (Pup√π=100%) con messaggio corretto.
   * 3) Fase Terra: ‚ÄúMal di pancia‚Äù sale mangiando cibi non adatti; a 100% sconfitta con stesso messaggio.
   * 4) Menu: contrasto selezione migliorato + anteprime che cambiano al cambio genere.
   * 5) Fase Terra: nella fascia azzurra ‚Äúmare‚Äù il personaggio ‚Äúnuota‚Äù (velocit√† ridotta + effetto üí¶); su sabbia cammina.
   * 6) Fase Mare: scena con fascia di spiaggia in basso; la üí© si arena l√¨ (resta, non ‚Äúscivola via‚Äù).
   * 7) Fase Mare: il personaggio pu√≤ camminare sulla spiaggia e raccogliere ‚ÄúBonus Granchio‚Äù.
   * 8) Fase Mare: granchietti ü¶Ä sulla sabbia con piccoli coni visivi: se vedono la üí© ‚Üí sconfitta; dopo il bonus, diventano amici e mangiano la üí© (come i narvali).
   */

  const Phaser = window.Phaser;
  const FONT = "Segoe UI Emoji, Apple Color Emoji, Noto Color Emoji, Arial, sans-serif";
const GAME_VERSION = "v1.1.0 - Boss Bagnino";

  // ========== DOMAIN ==========
  const Characters = {
    PANDA_PICCOLO: { specie: 'panda', eta: 'piccolo' },
    PANDA_ADULTO:  { specie: 'panda', eta: 'adulto'  },
    BAMBINO:       { specie: 'umano', eta: 'piccolo' },
    ADULTO:        { specie: 'umano', eta: 'adulto'  }
  };
  const Foods = { BAMBOO: 'bamboo', PASTA: 'pasta', PIZZA: 'pizza', GELATO: 'gelato' }; // gelato = ‚Äúok-ish‚Äù (non fa male)
  function allowedFoodsFor(character){
    if (character.specie === 'panda') return new Set([Foods.BAMBOO]);
    if (character.specie === 'umano' && character.eta === 'piccolo') return new Set([Foods.PASTA]);
    if (character.specie === 'umano' && character.eta === 'adulto') return new Set([Foods.PIZZA]);
    return new Set();
  }
  function poopGain(character, food){
    const allowed = allowedFoodsFor(character);
    if (allowed.has(food)) return 0.18;
    if (food === Foods.GELATO) return 0.06; // un po' di ‚Äúcarica‚Äù extra
    return 0.00; // cibo non adatto ‚Üí niente ‚Äúpoop‚Äù, ma far√† salire ‚Äúmal di pancia‚Äù
  }
  function defaultRng(){ return { int(min, max){ return Math.floor(Math.random()*(max-min+1)) + min; } }; }
  function randomPointAvoiding(center, minDist, bounds, rng = defaultRng()){
    // spawn point ‚Äúlontano abbastanza‚Äù dal player
    const maxTry = 50;
    for (let i=0;i<maxTry;i++){
      const x = rng.int(bounds.xMin, bounds.xMax);
      const y = rng.int(bounds.yMin, bounds.yMax);
      const dx = x - center.x, dy = y - center.y;
      if (Math.hypot(dx,dy) >= minDist) return { x, y };
    }
    return { x: rng.int(bounds.xMin, bounds.xMax), y: rng.int(bounds.yMin, bounds.yMax) };
  }
  function isInVisionCone(observer, dirAngle, fovRad, range, target){
    const dx = target.x - observer.x, dy = target.y - observer.y;
    const dist = Math.hypot(dx, dy); if (dist > range) return false;
    const ang = Math.atan2(dy, dx);
    let diff = ang - dirAngle; // normalizza a [-pi, pi]
    diff = Math.atan2(Math.sin(diff), Math.cos(diff));
    return Math.abs(diff) <= fovRad/2;
  }

  const GameState = {
    selected:   { specie: 'panda', eta: 'piccolo', genere: 'm' },
    poopMeter:  0,   // 0..1
    stomach:    0,   // 0..1 (nuova barra ‚Äúmal di pancia‚Äù)
    hasNarwhal: false,
    hasSiren:   false,
    hasTornado: false,
    crabsFriendly: false, // dopo il bonus granchio diventano amici
    transitioning: false
  };
  function resetForNewRun(){
    GameState.poopMeter = 0;
    GameState.stomach   = 0;
    GameState.hasNarwhal = false;
    GameState.hasSiren   = false;
    GameState.hasTornado = false;
    GameState.crabsFriendly = false;
    GameState.transitioning = false;
  }
  function labelForFood(foodType){
    switch(foodType){
      case Foods.BAMBOO: return 'üéã Bamboo';
      case Foods.PASTA:  return 'üçù Pasta';
      case Foods.PIZZA:  return 'üçï Pizza';
      case Foods.GELATO: return 'üç¶ Gelato';
      default:           return 'Cibo';
    }
  }
  function colorForFood(foodType){
    switch(foodType){
      case Foods.BAMBOO: return '#1f7a1f';
      case Foods.PASTA:  return '#7a5d1f';
      case Foods.PIZZA:  return '#a83232';
      case Foods.GELATO: return '#7a1f6a';
      default:           return '#333333';
    }
  }

  // ========== SFX ==========
  let _audioCtx = null;
  function ensureAudioContext(){ if (!_audioCtx) _audioCtx = new (window.AudioContext || window.webkitAudioContext)(); return _audioCtx; }
  function tone({ freq=440, dur=0.12, type='sine', vol=0.22 }){
    const ctx = ensureAudioContext();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = type; osc.frequency.value = freq;
    osc.connect(gain); gain.connect(ctx.destination);
    gain.gain.setValueAtTime(vol, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + dur);
    osc.start(); osc.stop(ctx.currentTime + dur);
  }
  const SFX = {
    play: (f,d,t,v)=> tone({ freq:f, dur:d, type:t, vol:v }),
    eat(){ this.play(520,0.08,'triangle',0.22); this.play(660,0.06,'sine',0.18); },
    wrong(){ this.play(220,0.10,'sawtooth',0.18); },
    drop(){ this.play(180,0.14,'square',0.22); },
    narwhal(){ this.play(400,0.10,'sine',0.2); this.play(300,0.20,'triangle',0.15); },
    siren(){ this.play(900,0.08,'square',0.2); this.play(700,0.12,'square',0.2); },
    tornado(){ this.play(120,0.3,'sawtooth',0.2); },
    crab(){ this.play(760,0.06,'square',0.22); this.play(640,0.08,'triangle',0.18); }, // bonus granchi
    win(){ [523,659,783].forEach((f,i)=>setTimeout(()=>this.play(f,0.12,'sine',0.22), i*120)); },
    lose(){ [196,185,174].forEach((f,i)=>setTimeout(()=>this.play(f,0.12,'triangle',0.22), i*120)); },
    button(){ this.play(540,0.08,'sine',0.22); }
  };

  // ========== UI helpers ==========
  function drawProgressBar(graphics, x, y, w, h, progress, fillColor=0x9b5a1a){
    graphics.lineStyle(2, 0x222222, 1);
    graphics.strokeRoundedRect(x, y, w, h, 8);
    graphics.fillStyle(0x333333, 1);
    graphics.fillRoundedRect(x, y, w, h, 8);
    const innerPad = 4, iw = (w - innerPad*2) * Math.max(0, Math.min(1, progress));
    graphics.fillStyle(fillColor, 1);
    graphics.fillRoundedRect(x + innerPad, y + innerPad, iw, h - innerPad*2, 6);
  }
  function makeBamboo(scene, x, baseY, totalH){
    const c = scene.add.container(x, baseY);
    const g = scene.add.graphics(); c.add(g);
    const stemW = 16; const segments = Math.max(3, Math.floor(totalH/36));
    let y = 0;
    for (let i=0;i<segments;i++){
      g.fillStyle(0x2e7d32,1); g.fillRoundedRect(-stemW/2, -y-36, stemW, 36, 6);
      g.lineStyle(3,0x1b5e20,1); g.strokeLineShape(new Phaser.Geom.Line(-stemW/2, -y-18, stemW/2, -y-18));
      const leaf = (lx,ly,ang,sz=12)=>{ g.fillStyle(0x66bb6a,1); const ax=Math.cos(ang), ay=Math.sin(ang); g.fillTriangle(lx,ly, lx-ax*sz, ly-ay*sz, lx-ay*sz*0.6, ly+ax*sz*0.6); };
      if (i%2===0) leaf(stemW/2, -y-24, 0.2); else leaf(-stemW/2, -y-10, Math.PI-0.2);
      y += 36;
    }
    c.setSize(stemW, totalH);
    scene.tweens.add({ targets:c, angle:2, yoyo:true, repeat:-1, duration:2200, ease:'Sine.easeInOut' });
    return c;
  }

  // ========== TEXTURES ==========
  function drawBow(g, cx, cy, col=0xff3da7){ g.fillStyle(col,1); g.fillEllipse(cx-6,cy,8,10); g.fillEllipse(cx+6,cy,8,10); g.fillCircle(cx,cy,3); }
  function drawCap(g, cx, cy, col=0x1f4d7a){ g.fillStyle(col,1); g.fillEllipse(cx,cy,26,12); g.fillRect(cx-13, cy, 26, 5); }
  function drawGlasses(g, cx, cy){ g.lineStyle(2,0x000000,1); g.strokeCircle(cx-8,cy,6); g.strokeCircle(cx+8,cy,6); g.lineBetween(cx-2,cy, cx+2,cy); }
  function createCharacterTexture(scene, key, sel){
    const g = scene.add.graphics();
    const isPanda = sel.specie === 'panda';
    const isBaby  = sel.eta === 'piccolo';
    const size = isBaby ? 22 : 28;
    const pad = 22;
    const cx = pad + size, cy = pad + size;
    if (isPanda) {
      g.fillStyle(0xffffff, 1); g.fillCircle(cx, cy, size);
      g.fillStyle(0x000000, 1);
      g.fillCircle(cx-12, cy-18, isBaby?6:7); g.fillCircle(cx+12, cy-18, isBaby?6:7);
      g.fillEllipse(cx-7, cy-2, 10, 14); g.fillEllipse(cx+7, cy-2, 10, 14);
      g.fillStyle(0xffffff, 1); g.fillCircle(cx-7, cy-2, 3); g.fillCircle(cx+7, cy-2, 3);
      g.fillStyle(0x000000, 1); g.fillCircle(cx, cy+5, 3);
      if (isBaby) { g.fillStyle(0xffa3a3,0.8); g.fillCircle(cx-12, cy+10, 3); g.fillCircle(cx+12, cy+10, 3); }
      else { if (sel.genere==='m'){ g.fillStyle(0xa00000,1); g.fillTriangle(cx, cy+18, cx-6, cy+28, cx+6, cy+28); } else { g.fillStyle(0xffe066,1); g.fillCircle(cx, cy+26, 4); } }
      if (sel.genere==='f') drawBow(g, cx-14, cy-26, 0xff3da7); else drawCap(g, cx, cy-28, 0x1f4d7a);
    } else {
      const skin = 0xffe0bd; g.fillStyle(skin, 1); g.fillCircle(cx, cy, size);
      const hairCol = 0x3b2e2a;
      if (isBaby) { g.fillStyle(hairCol, 1); g.fillEllipse(cx, cy-10, size*1.6, size*0.8); }
      else { g.fillStyle(hairCol, 1); if (sel.genere==='f') g.fillEllipse(cx, cy-6, size*1.8, size*1.6); else g.fillEllipse(cx, cy-8, size*1.8, size*1.0); }
      g.fillStyle(0x000000, 1); g.fillCircle(cx-7, cy-2, 3); g.fillCircle(cx+7, cy-2, 3); g.lineStyle(2, 0x000000, 1); g.strokeCircle(cx, cy+6, 6);
      if (sel.genere==='f') drawBow(g, cx-14, cy-26, 0xff3da7); else drawCap(g, cx, cy-28, 0x1f4d7a);
      if (!isBaby && sel.genere==='m') drawGlasses(g, cx, cy-2);
    }
    const w = (size+pad)*2, h = (size+pad)*2; g.generateTexture(key, w, h); g.destroy();
  }
  function createSwimmerTexture(scene, key, tint=0x00a3c4){
    const g = scene.add.graphics(); const pad=10; const r=12, cx=pad+r, cy=pad+r;
    g.fillStyle(0xffe0bd,1); g.fillCircle(cx, cy, r);
    g.fillStyle(tint,1); g.fillEllipse(cx, cy-6, r*1.8, r*1.0);
    g.lineStyle(2,0x000000,1); g.strokeRect(cx-8, cy-2, 16, 4);
    g.fillStyle(0xc0dff4,1); g.fillEllipse(cx, cy+16, r*1.2, r*0.8);
    g.generateTexture(key, pad*2+r*2, pad*2+r*2+16); g.destroy();
  }
  function createLifeguardTexture(scene, key){
    const g = scene.add.graphics(); const pad=10; const r=14, cx=pad+r, cy=pad+r;
    g.fillStyle(0xffe0bd,1); g.fillCircle(cx, cy, r);
    g.fillStyle(0xc62828,1); g.fillEllipse(cx, cy-8, r*1.8, r*1.0); g.fillRect(cx-12, cy-8, 24, 5);
    g.fillStyle(0x808080,1); g.fillRect(cx-2, cy+6, 4, 6);
    g.fillStyle(0xffffff,1); g.fillEllipse(cx, cy+18, r*1.4, r*1.0);
    g.fillStyle(0xc62828,1); g.fillRect(cx-2, cy+14, 4, 8); g.fillRect(cx-6, cy+16, 12, 4);
    g.generateTexture(key, pad*2+r*2, pad*2+r*2+18); g.destroy();
  }

  // ========== LIMBS ==========
  function makeLimbs(scene, color=0x000000){
    const parts = ['LA','RA','LL','RL'].reduce((acc,k)=>{ acc[k]=scene.add.graphics(); return acc; },{});
    const draw = (g,x,y,rot)=>{ g.clear(); g.fillStyle(color,1); g.save(); g.translateCanvas(x,y); g.rotateCanvas(rot); g.fillRoundedRect(-2,-8,4,16,2); g.restore(); };
    return { parts, draw, setVisible(v){ Object.values(parts).forEach(p=>p.setVisible(v)); }, destroy(){ Object.values(parts).forEach(p=>p.destroy()); } };
  }
  function updateLimbs(limbs, px, py, moving, t){
    const amp = moving? 0.8 : 0.2; const speed = moving? 10 : 2; const s = Math.sin(t*speed);
    limbs.draw(limbs.parts.LA, px-12, py+6,  s*amp);
    limbs.draw(limbs.parts.RA, px+12, py+6, -s*amp);
    limbs.draw(limbs.parts.LL, px-8,  py+20, -s*amp);
    limbs.draw(limbs.parts.RL, px+8,  py+20,  s*amp);
  }

  // ========== SCENES ==========
  class MenuScene extends Phaser.Scene {
    constructor(){ super('MenuScene'); }
    create(){
      resetForNewRun();
      const { width, height } = this.scale;

      // Sfondo ‚Äúspiaggia + mare‚Äù come prima
      const bg = this.add.graphics();
      bg.fillStyle(0x0b3d91,1); bg.fillRect(0,0,width,height*0.35);      // cielo
      bg.fillStyle(0x1976d2,1); bg.fillRect(0,height*0.35,width,height*0.25); // mare
      bg.fillStyle(0xf4e2b5,1); bg.fillRect(0,height*0.60,width,height*0.40); // sabbia
      makeBamboo(this, 54, height-20, height*0.75);
      makeBamboo(this, width-54, height-20, height*0.68);

      const title = this.add.text(width/2, 60, 'Poo Poo Panda', { fontFamily: FONT, fontSize: 54, color:'#ffffff' }).setOrigin(0.5);
      title.setShadow(3,3,'#000000',6,true,true);

      const panelW = Math.min(720, width-60), panelH = 300;
      const panel = this.add.graphics();
      panel.fillStyle(0x1b2838, 0.95); panel.fillRoundedRect((width-panelW)/2, 150, panelW, panelH, 20);
      panel.lineStyle(3, 0x64b5f6, 1.0); panel.strokeRoundedRect((width-panelW)/2, 150, panelW, panelH, 20);
      this.add.text(width/2, 165, 'Scegli il personaggio e il genere', { fontFamily: FONT, fontSize: 22, color:'#e3f2fd' }).setOrigin(0.5);

      const options = [
        { label: 'Panda piccolo', value: Characters.PANDA_PICCOLO },
        { label: 'Panda adulto',  value: Characters.PANDA_ADULTO  },
        { label: 'Bambino umano', value: Characters.BAMBINO       },
        { label: 'Adulto umano',  value: Characters.ADULTO        },
      ];
      const cards = []; let selectedIdx = 0; let gender = 'm';
      const startX = (width-panelW)/2 + 28; const startY = 205; const gapX = (panelW-56)/4; const cardW = gapX-14; const cardH = 110;

      const makeCard = (i)=>{
        const x = startX + i*gapX; const y = startY; const c = this.add.container(x, y);
        const g = this.add.graphics(); c.add(g);
        const k = ()=>`menu_prev_${i}_${gender}`;
        const drawCardBG = (active=false)=>{
          g.clear();
          if (active){ g.fillStyle(0x143d5b,1); g.fillRoundedRect(0,0,cardW,cardH,16); g.lineStyle(3,0x64b5f6,1); g.strokeRoundedRect(0,0,cardW,cardH,16); }
          else       { g.fillStyle(0x102131,1); g.fillRoundedRect(0,0,cardW,cardH,16); g.lineStyle(2,0x5dade2,1); g.strokeRoundedRect(0,0,cardW,cardH,16); }
        };
        drawCardBG(i===selectedIdx);

        const ensureTex = ()=>{
          if (!this.textures.exists(k())) createCharacterTexture(this, k(), { ...options[i].value, genere: gender });
        };
        ensureTex();
        const img = this.add.image(cardW/2, 46, k()).setScale(0.9); c.add(img);
        const txt = this.add.text(cardW/2, cardH-20, options[i].label, { fontFamily: FONT, fontSize: 16, color:'#e3f2fd' }).setOrigin(0.5); txt.setShadow(2,2,'#000',4,true,true); c.add(txt);

        c.setSize(cardW, cardH);
        c.setInteractive(new Phaser.Geom.Rectangle(0,0,cardW,cardH), Phaser.Geom.Rectangle.Contains)
          .on('pointerover', ()=> drawCardBG(true))
          .on('pointerout',  ()=> drawCardBG(i===selectedIdx))
          .on('pointerdown', ()=>{ SFX.button(); selectedIdx=i; cards.forEach((card, idx)=>card.drawBG(idx===selectedIdx)); });

        cards.push({c,g,img,txt,drawBG:drawCardBG, refreshTexture:()=>{ ensureTex(); img.setTexture(k()); }});
      };
      for (let i=0;i<options.length;i++) makeCard(i);

      const pillW = 220, pillH = 40; const pillX = width/2 - pillW/2, pillY = 325;
      const pill = this.add.graphics();
      const drawPill = ()=>{
        pill.clear();
        pill.fillStyle(0x102131,1); pill.fillRoundedRect(pillX, pillY, pillW, pillH, 20);
        pill.lineStyle(2,0x90caf9,1); pill.strokeRoundedRect(pillX, pillY, pillW, pillH, 20);
        const knobX = gender==='m'? pillX+pillW*0.25 : pillX+pillW*0.75;
        pill.fillStyle(0x64b5f6,1); pill.fillRoundedRect(knobX-44, pillY+6, 88, pillH-12, 16);
      };
      drawPill();
      this.add.text(pillX+pillW*0.25, pillY+pillH/2, '‚ôÇÔ∏è Maschio', { fontFamily: FONT, fontSize:16, color:'#e3f2fd' }).setOrigin(0.5);
      this.add.text(pillX+pillW*0.75, pillY+pillH/2, '‚ôÄÔ∏è Femmina', { fontFamily: FONT, fontSize:16, color:'#e3f2fd' }).setOrigin(0.5);
      this.add.zone(pillX, pillY, pillW, pillH).setOrigin(0).setInteractive().on('pointerdown', ()=>{
        SFX.button();
        gender = gender==='m' ? 'f' : 'm'; drawPill();
        cards.forEach(c=>c.refreshTexture()); // aggiorna anteprime al cambio genere
      });

      this.add.text(width/2, height - 110, 'Consiglio: Panda‚ÜíBamboo | Bimbo‚ÜíPasta | Adulto‚ÜíPizza', { fontFamily: FONT, fontSize: 16, color: '#0b0b0b', backgroundColor:'#e3f2fd', padding:{left:10,right:10,top:4,bottom:4} }).setOrigin(0.5);

      const start = this.add.text(width/2, height - 60, 'Inizia ‚ñ∂', { fontFamily: FONT, fontSize: 30, color: '#ffffff', backgroundColor:'#43a047', padding:{ left:18, right:18, top:8, bottom:8 } }).setOrigin(0.5);
      start.setShadow(3,3,'#1b5e20',6,true,true);
      start.setInteractive({ useHandCursor: true })
        .on('pointerover', ()=> start.setStyle({ backgroundColor:'#2e7d32' }))
        .on('pointerout',  ()=> start.setStyle({ backgroundColor:'#43a047' }))
        .on('pointerdown', ()=>{
          if (GameState.transitioning) return; GameState.transitioning = true; SFX.button();
          const chosen = options[selectedIdx].value; GameState.selected = { specie: chosen.specie, eta: chosen.eta, genere: gender };
          this.scene.start('LandScene');
        });
		// Versione in basso a destra
this.add.text(
  width - 10,
  height - 10,
  `Versione ${GAME_VERSION}`,
  {
    fontFamily: FONT,
    fontSize: 14,
    color: "#FF0000"
  }
).setOrigin(1, 1).setAlpha(0.8);
    }
  }

  class LandScene extends Phaser.Scene {
    constructor(){ super('LandScene'); }
    create(){
      GameState.transitioning = false; const { width, height } = this.scale;
      // Sfondo: cielo + mare (fascia azzurra) + sabbia
      this.cameras.main.setBackgroundColor('#87CEEB');
      this.bg = this.add.graphics();
      this.bg.fillStyle(0x1976d2,1); this.bg.fillRect(0,height*0.35,width,height*0.25); // fascia mare
      this.bg.fillStyle(0xF4E2B5, 1); this.bg.fillRect(0, height*0.60, width, height*0.40); // sabbia

      this.add.text(10, 10, `Personaggio: ${GameState.selected.specie} ${GameState.selected.eta} (${GameState.selected.genere==='m'?'M':'F'})`, { fontFamily: FONT, fontSize: 16, color: '#000' });

      const key = `char_${GameState.selected.specie}_${GameState.selected.eta}_${GameState.selected.genere}`; createCharacterTexture(this, key, GameState.selected);
      this.player = this.add.image(width/2, height*0.6, key);
      this.physics.add.existing(this.player);
      this.player.body.setCircle(this.player.displayWidth/2);
      this.player.body.setCollideWorldBounds(true);

      this.playerLimbs = makeLimbs(this, 0x000000);
      this.foods = this.physics.add.group(); this.bonuses = this.physics.add.group();

      // UI: barre in alto a DESTRA (non coprono freccia vento della scena mare)
      this.ui = this.add.graphics();
      this.poopText = this.add.text(0, 0, '', { fontFamily: FONT, fontSize: 14, color: '#111' }).setOrigin(1,0);
      this.stomachText = this.add.text(0, 0, '', { fontFamily: FONT, fontSize: 14, color: '#111' }).setOrigin(1,0);

      this.promptText = this.add.text(width/2, 48, '', { fontFamily: FONT, fontSize: 18, color: '#111' }).setOrigin(0.5);
      this.seaBtn = this.add.text(width - 190, 42, 'Vai al Mare ‚ñ∂', { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#0a7d33', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({ useHandCursor:true }).on('pointerdown', () => this.tryGoSea()); this.seaBtn.visible = false;
      this.restartBtn = this.add.text(16, height - 44, '‚ü≤ Ricomincia (R)', { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#444', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({ useHandCursor:true }).on('pointerdown', () => this.restartLand());

      this.sceneStartMs = this.time.now; this.GRACE_MS = 1000; this.EAT_COOLDOWN_MS = 180; this.lastEatMs = 0;

      this.spawnFoodWave(); this.spawnBonusNarwhal();

      this.tut = this.add.text(width/2, height-90, 'Mangia i cibi giusti. Evita quelli sbagliati (mal di pancia). Riempi fino al 60% e vai al mare!', { fontFamily:FONT, fontSize: 16, color:'#001', backgroundColor:'#fff', padding:{left:8,right:8,top:6,bottom:6} }).setOrigin(0.5);
      this.time.delayedCall(5000, ()=> this.tut.setVisible(false));

      this.cursors = this.input.keyboard.createCursorKeys(); this.wasd = this.input.keyboard.addKeys('W,A,S,D');
      this.keyM = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.M);
      this.keyR = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);

      // Controllo touch/click con punto bersaglio
      this.pointerTarget = null; this.pointerMarker = this.add.circle(0, 0, 8, 0x000000, 0.3).setVisible(false);
      const setPointerTarget = (p)=>{ this.pointerTarget = { x: p.worldX, y: p.worldY }; this.pointerMarker.setPosition(this.pointerTarget.x, this.pointerTarget.y).setVisible(true); };
      this.input.on('pointerdown', setPointerTarget); this.input.on('pointermove', (p)=>{ if (p.isDown) setPointerTarget(p); });

      this.physics.add.overlap(this.player, this.foods, this.onEatFood, null, this); this.physics.add.overlap(this.player, this.bonuses, this.onTakeBonus, null, this);

      // Effetto ‚Äúnuoto‚Äù in fascia mare
      this.swimFX = this.add.text(0,0,'üí¶',{ fontFamily:FONT, fontSize:20 }).setVisible(false);
    }
    restartLand(){ resetForNewRun(); this.scene.start('LandScene'); }
    getSafeSpawn(minDist=120){ const { width, height } = this.scale; const b = { xMin: 40, xMax: width-40, yMin: height*0.4, yMax: height-40 }; return randomPointAvoiding({x:this.player.x,y:this.player.y}, minDist, b); }
    spawnFoodWave(){ const types=[Foods.BAMBOO,Foods.PASTA,Foods.PIZZA,Foods.GELATO]; for(let i=0;i<8;i++){ const t=Phaser.Utils.Array.GetRandom(types); const p=this.getSafeSpawn(140); this.spawnFoodAt(p.x,p.y,t);} }
    spawnFoodAt(x,y,t){ const food=this.add.text(x,y,labelForFood(t),{ fontFamily:FONT, fontSize:18, color:colorForFood(t)}).setOrigin(0.5); this.physics.add.existing(food); food.body.setCircle(24).setOffset(-24,-24); food.body.setImmovable(true); food.foodType=t; this.foods.add(food);}  
    spawnSingleFood(){ const types=[Foods.BAMBOO,Foods.PASTA,Foods.PIZZA,Foods.GELATO]; const t=Phaser.Utils.Array.GetRandom(types); const p=this.getSafeSpawn(120); this.spawnFoodAt(p.x,p.y,t); }
    spawnBonusNarwhal(){ if (GameState.hasNarwhal) return; const p=this.getSafeSpawn(160); const b=this.add.text(p.x,p.y,'üêã Narvalo',{ fontFamily:FONT, fontSize:18, color:'#551a8b'}).setOrigin(0.5); this.physics.add.existing(b); b.body.setCircle(26).setOffset(-26,-26); b.body.setImmovable(true); b.bonusType='narwhal'; this.bonuses.add(b);}  
    onEatFood(player, food){
      const now=this.time.now; if (now-this.sceneStartMs< this.GRACE_MS) return; if (now-this.lastEatMs<this.EAT_COOLDOWN_MS) return; this.lastEatMs=now;
      const gain=poopGain(GameState.selected, food.foodType);
      if (gain===0){
        // Cibo NON adatto ‚Üí aumenta ‚Äúmal di pancia‚Äù
        GameState.stomach = Math.min(1, GameState.stomach + 0.22);
        this.tweens.add({targets:food, angle:10, yoyo:true, duration:120, onComplete:()=>food.destroy()});
        SFX.wrong();
      } else {
        GameState.poopMeter = Math.min(1, GameState.poopMeter + gain);
        this.tweens.add({targets:food, scale:1.25, yoyo:true, duration:120, onComplete:()=>food.destroy()});
        SFX.eat();
      }
      this.time.delayedCall(300, ()=>this.spawnSingleFood());
    }
    onTakeBonus(player, bonus){ if (bonus.bonusType==='narwhal'){ GameState.hasNarwhal=true; this.tweens.add({ targets:bonus, angle:360, scale:1.5, duration:240, onComplete:()=>bonus.destroy() }); SFX.narwhal(); } }
    tryGoSea(){ if (GameState.poopMeter<0.6 || GameState.transitioning) return; GameState.transitioning=true; this.scene.start('SeaScene'); }
    update(time, delta){
      const { width, height } = this.scale;
      const body=this.player.body; body.setVelocity(0);

      // Cammina su sabbia, ‚Äúnuota‚Äù in fascia mare (altezza 35%-60%)
      const inWater = (this.player.y >= height*0.35 && this.player.y <= height*0.60);
      const speed = inWater ? 110 : 160;

      // Movimenti
      if (this.cursors.left.isDown||this.wasd.A.isDown) body.setVelocityX(-speed); else if (this.cursors.right.isDown||this.wasd.D.isDown) body.setVelocityX(speed);
      if (this.cursors.up.isDown||this.wasd.W.isDown) body.setVelocityY(-speed); else if (this.cursors.down.isDown||this.wasd.S.isDown) body.setVelocityY(speed);
      if (this.pointerTarget){
        const dx=this.pointerTarget.x-this.player.x, dy=this.pointerTarget.y-this.player.y, dist=Math.hypot(dx,dy);
        if (dist>6) body.setVelocity((dx/dist)*speed, (dy/dist)*speed); else { this.pointerTarget=null; this.pointerMarker.setVisible(false);}
      }

      // UI barre a destra
      const barW=220, barH=22, pad=16;
      const xRight = width - barW - pad;
      this.ui.clear();
      drawProgressBar(this.ui, xRight, 12, barW, barH, GameState.poopMeter, 0x9b5a1a);
      drawProgressBar(this.ui, xRight, 12+barH+6, barW, barH, GameState.stomach,   0xcc3333);
      this.poopText.setPosition(xRight+barW, 12).setText(`Pup√π: ${Math.round(GameState.poopMeter*100)}%`);
      this.stomachText.setPosition(xRight+barW, 12+barH+6).setText(`Mal di pancia: ${Math.round(GameState.stomach*100)}%`);

      const canSea = GameState.poopMeter>=0.6;
      this.promptText.setText(canSea? 'Premi M o tocca ‚ñ∂ Vai al Mare':'Mangia i cibi adatti per riempire la barra'); this.seaBtn.visible=canSea;
      if (Phaser.Input.Keyboard.JustDown(this.keyM)) this.tryGoSea();
      if (Phaser.Input.Keyboard.JustDown(this.keyR)) this.restartLand();

      // Sconfitte in fase Terra:
      if (GameState.poopMeter>=1.0) { SFX.lose(); this.scene.start('LoseScene', { reason:'overeat' }); }
      if (GameState.stomach>=1.0)   { SFX.lose(); this.scene.start('LoseScene', { reason:'stomachache' }); }

      // Effetto nuoto
      this.swimFX.setVisible(inWater).setPosition(this.player.x, this.player.y - 34);

      const moving = body.velocity.length() > 5; updateLimbs(this.playerLimbs, this.player.x, this.player.y, moving, time/1000);
    }
    shutdown(){ this.playerLimbs?.destroy?.(); }
  }

  class SeaScene extends Phaser.Scene {
    constructor(){ super('SeaScene'); }
    create(){
      const { width, height } = this.scale; GameState.transitioning=false;

      // Layout: acqua in alto, SPIAGGIA in basso (dove sta il bagnino e si arena la üí©)
      this.cameras.main.setBackgroundColor('#3CB7E7');
      this.beachHeight = Math.floor(height * 0.26);
      this.beachTopY   = height - this.beachHeight;

      const bg = this.add.graphics();
      // mare pieno (sfondo)
      bg.fillStyle(0x3CB7E7,1); bg.fillRect(0,0,width,height);
      // spiaggia
      bg.fillStyle(0xF4E2B5,1); bg.fillRect(0, this.beachTopY, width, this.beachHeight);

      const key = `char_${GameState.selected.specie}_${GameState.selected.eta}_${GameState.selected.genere}`; createCharacterTexture(this, key, GameState.selected);
      this.player = this.add.image(width*0.5, this.beachTopY - 40, key); // parte vicino alla riva
      this.physics.add.existing(this.player); this.player.body.setCircle(this.player.displayWidth/2); this.player.body.setCollideWorldBounds(true);

      this.playerLimbs = makeLimbs(this, 0x001122);

      // Corrente marina (come versione precedente, senza timer missione)
      this.currentAngle = Phaser.Math.FloatBetween(-Math.PI, Math.PI);
      this.currentSpeed = 38;
      this.currentFrozen = false;
      this.currentArrow = this.add.graphics();

      // Nuvola che annuncia cambio corrente
      this.cloud = this.add.text(width/2, 36, '‚òÅÔ∏è‚òÅÔ∏è‚òÅÔ∏è', { fontFamily:FONT, fontSize: 40, color:'#ffffff' }).setOrigin(0.5).setVisible(false);
      this.tweens.add({ targets:this.cloud, scale:1.15, yoyo:true, repeat:-1, duration:450, ease:'Sine.easeInOut' });
      this.scheduleNextCurrentChange();

      this.poops = this.add.group(); this.narwhals = []; this.swimmers = [];

      // Bagnino sulla SPIAGGIA
      const lifekey = 'lifeguard_tex'; if (!this.textures.exists(lifekey)) createLifeguardTexture(this, lifekey);
      this.lifeguardSprite = this.add.image(width/2, this.beachTopY - 20, lifekey);

    this.lifeguard = {
  x: this.lifeguardSprite.x, 
  y: this.lifeguardSprite.y,
  dir: -Math.PI/2,
  sweepMin: -Math.PI/2 - Phaser.Math.DegToRad(35),
  sweepMax: -Math.PI/2 + Phaser.Math.DegToRad(35),
  speed: Phaser.Math.DegToRad(20),
  fov: Phaser.Math.DegToRad(50),
  range: 360,
  distractedUntil: 0
};

      this.visionGfx = this.add.graphics();

      // Nuotatori in mare
      const capColors = [0x00a3c4,0xffa726,0x8e24aa,0x2e7d32,0xd32f2f,0x455a64];
      for (let i=0; i<6; i++) this.spawnSwimmer(Phaser.Utils.Array.GetRandom(capColors));

      // Bonus di mare (narvalo/sirena/tornado) + bonus GRANCHIO sulla spiaggia
      this.seaBonuses = this.physics.add.group();
      if (!GameState.hasNarwhal) this.spawnSeaBonus('narwhal');
      if (!GameState.hasSiren)   this.spawnSeaBonus('siren');
      if (!GameState.hasTornado) this.spawnSeaBonus('tornado');
      this.spawnCrabBonus();

      // Tornado
      this.tornado = null; this.tornadoGfx = this.add.graphics();

      // UI (barre a destra)
      this.ui = this.add.graphics();
      this.uiText = this.add.text(16, 12, '', { fontFamily:FONT, fontSize: 16, color:'#001' });
      this.statusText = this.add.text(width/2, 12, '', { fontFamily:FONT, fontSize: 16, color:'#001' }).setOrigin(0.5);
      this.poopText = this.add.text(0, 0, '', { fontFamily:FONT, fontSize: 14, color:'#001' }).setOrigin(1,0);
      this.stomachText = this.add.text(0, 0, '', { fontFamily:FONT, fontSize: 14, color:'#001' }).setOrigin(1,0);

      // Controlli
      this.dropBtn   = this.add.text(16, height - 44, 'Sgancia üí© (SPAZIO)', { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#a34a00', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ this.dropPoop(); SFX.drop(); });
      this.narBtn    = this.add.text(260, height - 44, 'Narvalo üêã (N)',     { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#6a1b9a', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ this.triggerNarwhal(); SFX.narwhal(); });
      this.sirenBtn  = this.add.text(440, height - 44, 'Sirena ‚ú® (S)',      { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#2947a3', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ this.triggerSiren(); SFX.siren(); });
      this.tornBtn   = this.add.text(600, height - 44, 'Tornado üåÄ (T)',     { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#00695c', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ this.triggerTornado(); SFX.tornado(); });
      this.menuBtn   = this.add.text(width - 280, height - 44, '‚¨Ö Menu',     { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#444', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ resetForNewRun(); this.scene.start('MenuScene'); });
      this.restartBtn= this.add.text(width - 140, height - 44, '‚ü≤ Ricomincia',{ fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#444', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ resetForNewRun(); this.scene.start('LandScene'); });

      this.tut = this.add.text(width/2, height-90, 'Lascia la üí© in mare e aspetta che si arena. Evita i coni (bagnino/nuotatori/granchi). Prendi il bonus ü¶Ä sulla spiaggia!', { fontFamily:FONT, fontSize: 16, color:'#001', backgroundColor:'#fff', padding:{left:8,right:8,top:6,bottom:6} }).setOrigin(0.5);
      this.time.delayedCall(7000, ()=> this.tut.setVisible(false));

      this.cursors = this.input.keyboard.createCursorKeys(); this.wasd = this.input.keyboard.addKeys('W,A,S,D');
      this.keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
      this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
      this.keyN = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.N);
      this.keyT = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.T);
      this.pointerTarget = null; this.pointerMarker = this.add.circle(0,0,8,0x000000,0.3).setVisible(false);
      const setPointerTarget = (p)=>{ this.pointerTarget = { x: p.worldX, y: p.worldY }; this.pointerMarker.setPosition(this.pointerTarget.x, this.pointerTarget.y).setVisible(true); };
      this.input.on('pointerdown', setPointerTarget); this.input.on('pointermove', (p)=>{ if (p.isDown) setPointerTarget(p); });

      this.physics.add.overlap(this.player, this.seaBonuses, (player, b)=>{
        if (b.type==='narwhal'){ GameState.hasNarwhal = true; SFX.narwhal(); }
        if (b.type==='siren')  { GameState.hasSiren = true;   SFX.siren(); }
        if (b.type==='tornado'){ GameState.hasTornado = true; SFX.tornado(); }
        if (b.type==='crab')   { GameState.crabsFriendly = true; SFX.crab(); this.onCrabsBefriend(); }
        this.tweens.add({ targets:b, angle:360, scale:1.5, duration:240, onComplete:()=>b.destroy() });
      });

      // Crea granchi sulla spiaggia
      this.crabs = []; this.crabGfx = this.add.graphics();
      this.spawnCrabs(6); // numero granchi

      // Delay breve per inizializzare
      this.time.delayedCall(300, ()=> this.updateStatusTexts());
    }
    scheduleNextCurrentChange(){
      const nextMs = Phaser.Math.Between(12000, 20000);
      this._cloudTimer1 = this.time.delayedCall(nextMs - 2500, ()=>{ if (!this.currentFrozen) this.cloud.setVisible(true); });
      this._cloudTimer2 = this.time.delayedCall(nextMs, ()=>{
        if (this.currentFrozen) { this.cloud.setVisible(false); this.scheduleNextCurrentChange(); return; }
        this.currentAngle = Phaser.Math.FloatBetween(-Math.PI, Math.PI);
        this.cloud.setVisible(false);
        this.scheduleNextCurrentChange();
      });
    }
    spawnSeaBonus(type){
      const { width } = this.scale;
      // bonus in ACQUA (non in spiaggia)
      const x = Phaser.Math.Between(40, width-40), y = Phaser.Math.Between(90, this.beachTopY-60);
      const label = type==='narwhal' ? 'üêã Narvalo' : type==='siren' ? 'üßú‚Äç‚ôÄÔ∏è Sirena' : 'üåÄ Tornado';
      const color = type==='narwhal' ? '#6a1b9a' : type==='siren' ? '#0a4abf' : '#00695c';
      const b = this.add.text(x, y, label, { fontFamily:FONT, fontSize: 18, color: color }).setOrigin(0.5);
      this.physics.add.existing(b); b.body.setCircle(26).setOffset(-26,-26); b.body.setImmovable(true); b.type = type;
      this.seaBonuses.add(b);
    }
    spawnCrabBonus(){
      const { width } = this.scale;
      const x = Phaser.Math.Between(40, width-40), y = Phaser.Math.Between(this.beachTopY+20, this.beachTopY + this.beachHeight - 30);
      const b = this.add.text(x, y, 'ü¶Ä Bonus', { fontFamily:FONT, fontSize: 18, color:'#8B4513' }).setOrigin(0.5);
      this.physics.add.existing(b); b.body.setCircle(26).setOffset(-26,-26); b.body.setImmovable(true); b.type='crab';
      this.seaBonuses.add(b);
    }
    spawnSwimmer(tint){ const { width } = this.scale; const x = Phaser.Math.Between(60, width-60), y = Phaser.Math.Between(90, this.beachTopY-80); const key = `swim_${tint}`; if (!this.textures.exists(key)) createSwimmerTexture(this, key, tint); const s = this.add.image(x,y,key); this.physics.add.existing(s); s.body.setCircle(s.displayWidth/2); s.body.setCollideWorldBounds(true); const limbs = makeLimbs(this, 0x223344); const data = { sprite:s, dir: Phaser.Math.FloatBetween(-Math.PI, Math.PI), speed: 40, fov: Phaser.Math.DegToRad(40), range: 140, changeAt: 0, limbs }; this.swimmers.push(data); }
    spawnCrabs(n=5){
      for (let i=0;i<n;i++){
        const x = Phaser.Math.Between(40, this.scale.width-40);
        const y = Phaser.Math.Between(this.beachTopY+16, this.scale.height-32);
        const t = this.add.text(x, y, 'ü¶Ä', { fontFamily:FONT, fontSize: 22 }); this.physics.add.existing(t); t.body.setCircle(12).setCollideWorldBounds(true);
        const crab = { sprite:t, dir: Phaser.Math.FloatBetween(-Math.PI, Math.PI), speed: 34, fov: Phaser.Math.DegToRad(35), range: 110, changeAt: 0, friend:false };
        this.crabs.push(crab);
      }
    }
    onCrabsBefriend(){
      // Tutti amici!
      this.crabs.forEach(c=>c.friend=true);
    }
    nearestPoop(from){ let best=null, bestD=1e9; this.poops.getChildren().forEach(p=>{ if(!p.active) return; const d=Phaser.Math.Distance.Between(from.x,from.y,p.x,p.y); if(d<bestD){ best=p; bestD=d; } }); return best; }
    triggerNarwhal(){ if (!GameState.hasNarwhal) return; const n = this.add.text(this.player.x, this.player.y, 'üêã', { fontFamily:FONT, fontSize: 26 }); n._speed = 90; n._target = this.nearestPoop(n); this.narwhals.push(n); GameState.hasNarwhal = false; SFX.narwhal(); }
    triggerSiren(){ if (!GameState.hasSiren) return; GameState.hasSiren = false; const siren = this.add.text(this.player.x, this.player.y, 'üßú‚Äç‚ôÄÔ∏è', { fontFamily:FONT, fontSize: 26 }); this.lifeguard.distractedUntil = this.time.now + 15000; this.time.delayedCall(15000, ()=>{ siren.destroy(); }); SFX.siren(); }
    triggerTornado(){ if (!GameState.hasTornado) return; GameState.hasTornado = false; this.tornado = { x: this.player.x, y: this.player.y, until: this.time.now + 15000 }; SFX.tornado(); }
    dropPoop(){
      if (GameState.poopMeter <= 0) return;
      const chunk = Math.min(GameState.poopMeter, 0.2);
      GameState.poopMeter = Math.max(0, Math.min(1, GameState.poopMeter - chunk));
      const p = this.add.text(this.player.x, this.player.y, 'üí©', { fontFamily:FONT, fontSize: 20});
      p._tDrop = this.time.now; p._ttlMs = 60000; p._stranded=false;
      p._label = this.add.text(p.x, p.y-18, '60', { fontFamily:FONT, fontSize: 12, color:'#001' }).setOrigin(0.5);
      this.poops.add(p); SFX.drop();
    }
    update(time, delta){
      const dt = delta/1000; const { width, height } = this.scale;
      const body=this.player.body; body.setVelocity(0);

      // Player: in acqua -> corrente; su SPIAGGIA -> niente corrente
      const onBeach = (this.player.y >= this.beachTopY);
      const speed = onBeach ? 150 : 120;

      if (this.cursors.left.isDown||this.wasd.A.isDown) body.setVelocityX(-speed); else if (this.cursors.right.isDown||this.wasd.D.isDown) body.setVelocityX(speed);
      if (this.cursors.up.isDown||this.wasd.W.isDown) body.setVelocityY(-speed); else if (this.cursors.down.isDown||this.wasd.S.isDown) body.setVelocityY(speed);
      if (this.pointerTarget){ const dx=this.pointerTarget.x-this.player.x, dy=this.pointerTarget.y-this.player.y, dist=Math.hypot(dx,dy); if (dist>6) body.setVelocity((dx/dist)*speed,(dy/dist)*speed); else { this.pointerTarget=null; this.pointerMarker.setVisible(false);} }

      // Corrente marina (solo acqua)
      const cx = Math.cos(this.currentAngle)*this.currentSpeed;
      const cy = Math.sin(this.currentAngle)*this.currentSpeed;
      if (!onBeach){ body.velocity.x += cx; body.velocity.y += cy; }

      // Freccia corrente in alto a SINISTRA
      this.currentArrow.clear(); this.currentArrow.fillStyle(0x002244, 0.15); this.currentArrow.fillCircle(40, 40, 18); this.currentArrow.lineStyle(5, 0xfff176, 0.95);
      const ax=40, ay=40; const ex=ax + Math.cos(this.currentAngle)*32, ey=ay + Math.sin(this.currentAngle)*32; this.currentArrow.lineBetween(ax, ay, ex, ey);
      this.currentArrow.fillStyle(0xfff176, 1); this.currentArrow.fillTriangle(ex, ey, ex - Math.cos(this.currentAngle+0.5)*10, ey - Math.sin(this.currentAngle+0.5)*10, ex - Math.cos(this.currentAngle-0.5)*10, ey - Math.sin(this.currentAngle-0.5)*10);

      // Sweep bagnino (se non distratto)
      if (time >= this.lifeguard.distractedUntil){
        this.lifeguard.dir += this.lifeguard.speed * dt;
        if (this.lifeguard.dir > this.lifeguard.sweepMax || this.lifeguard.dir < this.lifeguard.sweepMin){
          this.lifeguard.speed *= -1; 
          this.lifeguard.dir = Phaser.Math.Clamp(this.lifeguard.dir, this.lifeguard.sweepMin, this.lifeguard.sweepMax);
        }
      }

      // Nuotatori casuali + tornado
      for (const s of this.swimmers){
        if (time > s.changeAt){ s.dir = Phaser.Math.FloatBetween(-Math.PI, Math.PI); s.changeAt = time + Phaser.Math.Between(1200, 2600); }
        let vx = Math.cos(s.dir)*s.speed + cx, vy = Math.sin(s.dir)*s.speed + cy;
        if (this.tornado && time < this.tornado.until){
          const dx = this.tornado.x - s.sprite.x, dy = this.tornado.y - s.sprite.y; const d = Math.hypot(dx,dy)||1; const pull = 120;
          vx += (dx/d)*pull; vy += (dy/d)*pull;
        }
        s.sprite.body.setVelocity(vx, vy);
        const moving = Math.hypot(vx,vy)>5; updateLimbs(s.limbs, s.sprite.x, s.sprite.y, moving, time/1000);
      }
      if (this.tornado && time >= this.tornado.until){ this.tornado=null; this.tornadoGfx.clear(); }
      this.tornadoGfx.clear(); if (this.tornado){ this.tornadoGfx.lineStyle(3, 0x00695c, 0.9); this.tornadoGfx.strokeCircle(this.tornado.x, this.tornado.y, 24); this.tornadoGfx.strokeCircle(this.tornado.x, this.tornado.y, 12); this.tornadoGfx.strokeCircle(this.tornado.x, this.tornado.y, 36); }

      // Narvali che puliscono
      for (const n of this.narwhals){
        if (!n.active) continue;
        if (!n._target || !n._target.active) n._target = this.nearestPoop(n);
        if (n._target){
          const dx = n._target.x - n.x, dy = n._target.y - n.y; const d = Math.hypot(dx,dy)||1;
          n.x += (dx/d)*n._speed*dt + cx*dt; n.y += (dy/d)*n._speed*dt + cy*dt;
          if (d<10 && n._target.active){ n._target._label?.destroy(); n._target.destroy(); n._target = this.nearestPoop(n); SFX.narwhal(); }
        } else {
          n.x += cx*dt; n.y += cy*dt; n._despawnAt = n._despawnAt || (time+2000); if (time>=n._despawnAt){ n.destroy(); }
        }
      }

      // üí©: si muove in acqua con la corrente; su SPIAGGIA si ‚Äúarena‚Äù e resta ferma
      this.poops.getChildren().forEach(p=>{
        const wasBeach = p._stranded;
        const nowBeach = (p.y >= this.beachTopY);
        if (!p._stranded && !nowBeach){ p.x += cx*dt; p.y += cy*dt; }
        if (nowBeach) p._stranded = true;
        p._label?.setPosition(p.x, p.y-18);
        const left = Math.max(0, Math.ceil((p._ttlMs - (time - p._tDrop))/1000));
        p._label?.setText(left.toString());
        if (left<=0 && p.active){ p._label?.destroy(); p.destroy(); }
        // Limita ai bordi
        p.x = Phaser.Math.Clamp(p.x, 8, width-8);
        p.y = Phaser.Math.Clamp(p.y, 60, height-8);
      });

      // Granchi: pattuglia spiaggia; se amici, mangiano la üí©
      for (const c of this.crabs){
        if (time > c.changeAt){ c.dir = Phaser.Math.FloatBetween(-Math.PI, Math.PI); c.changeAt = time + Phaser.Math.Between(1000, 2200); }
        let vx = Math.cos(c.dir)*c.speed, vy = Math.sin(c.dir)*c.speed;
        // resta su SPIAGGIA
        const nx = c.sprite.x + vx*dt, ny = c.sprite.y + vy*dt;
        if (ny < this.beachTopY+10 || ny > height-16) { c.dir = -c.dir; continue; }
        c.sprite.x = Phaser.Math.Clamp(nx, 16, width-16);
        c.sprite.y = Phaser.Math.Clamp(ny, this.beachTopY+10, height-16);

        if (c.friend){
          // ‚ÄúAmico‚Äù: cerca la üí© pi√π vicina e la mangia
          const target = this.nearestPoop(c.sprite);
          if (target){
            const dx=target.x-c.sprite.x, dy=target.y-c.sprite.y, d=Math.hypot(dx,dy)||1;
            c.sprite.x += (dx/d)*50*dt; c.sprite.y += (dy/d)*50*dt;
            if (d<12 && target.active){ target._label?.destroy(); target.destroy(); SFX.crab(); }
          }
        }
      }

      // Disegna coni di visione: bagnino + nuotatori + (granchi se NON amici)
      this.visionGfx.clear();
      this.drawCone(this.visionGfx, this.lifeguard.x, this.lifeguard.y, this.lifeguard.dir, this.lifeguard.fov, this.lifeguard.range, 0xff0000, 0.15);
      for (const s of this.swimmers){ this.drawCone(this.visionGfx, s.sprite.x, s.sprite.y, s.dir, s.fov, s.range, 0xff8800, 0.12); }
      if (!GameState.crabsFriendly){
        for (const c of this.crabs){
          // piccolissimo cono
          const dir = c.dir, fov = Phaser.Math.DegToRad(35), range = 80;
          this.drawCone(this.visionGfx, c.sprite.x, c.sprite.y, dir, fov, range, 0xaa5500, 0.12);
        }
      }

      // Sconfitta se QUALCUNO vede una üí© (bagnino, nuotatori, granchi non amici)
      if (this.isAnyPoopDetected()){ SFX.lose(); resetForNewRun(); this.scene.start('LoseScene', { reason:'detected' }); return; }

     // Vittoria: niente pi√π ‚Äúcarico‚Äù e nessuna üí© attiva ‚Üí si va al livello BOSS
if (GameState.poopMeter <= 0 && this.poops.countActive(true) === 0){
  SFX.win();
  // NON facciamo resetForNewRun: ci servono ancora i bonus nel livello finale
  this.scene.start('BossScene');
  return;
}
      // HUD (barre a destra + stato bonus)
      const barW=220, barH=22, pad=16, xRight = width - barW - pad;
      this.ui.clear();
      drawProgressBar(this.ui, xRight, 12, barW, barH, GameState.poopMeter, 0x9b5a1a);
      drawProgressBar(this.ui, xRight, 12+barH+6, barW, barH, GameState.stomach,   0xcc3333);
      this.poopText.setPosition(xRight+barW, 12).setText(`Pup√π: ${Math.round(GameState.poopMeter*100)}%`);
      this.stomachText.setPosition(xRight+barW, 12+barH+6).setText(`Mal di pancia: ${Math.round(GameState.stomach*100)}%`);

      const status = [
        GameState.hasNarwhal? 'Narvalo pronto' : 'Narvalo no',
        GameState.hasSiren?   'Sirena pronta'  : 'Sirena no',
        GameState.hasTornado? 'Tornado pronto' : 'Tornado no',
        GameState.crabsFriendly? 'Granchi amici' : 'Granchi neutrali'
      ];
      const distractLeft = Math.max(0, Math.ceil((this.lifeguard.distractedUntil - time)/1000));
      this.uiText.setText(`Cacchette: ${this.poops.countActive(true)}`);
      this.statusText.setText(status.join('  ‚Ä¢  ') + (distractLeft>0?`  ‚Ä¢  Bagnino distratto: ${distractLeft}s`:''));

      // Scorciatoie tastiera
      if (Phaser.Input.Keyboard.JustDown(this.keySpace)) { this.dropPoop(); SFX.drop(); }
      if (Phaser.Input.Keyboard.JustDown(this.keyS)) { this.triggerSiren(); SFX.siren(); }
      if (Phaser.Input.Keyboard.JustDown(this.keyN)) { this.triggerNarwhal(); SFX.narwhal(); }
      if (Phaser.Input.Keyboard.JustDown(this.keyT)) { this.triggerTornado(); SFX.tornado(); }

      const moving = body.velocity.length() > 5; updateLimbs(this.playerLimbs, this.player.x, this.player.y, moving, time/1000);
    }
    drawCone(gfx, x, y, dir, fov, range, color, alpha){
      gfx.fillStyle(color, alpha);
      const a1 = dir - fov/2, a2 = dir + fov/2;
      const p1 = { x: x + Math.cos(a1)*range, y: y + Math.sin(a1)*range };
      const p2 = { x: x + Math.cos(a2)*range, y: y + Math.sin(a2)*range };
      gfx.beginPath(); gfx.moveTo(x,y); gfx.lineTo(p1.x, p1.y); gfx.arc(x,y,range,a1,a2); gfx.lineTo(x,y); gfx.closePath(); gfx.fillPath();
    }
    isAnyPoopDetected(){
      // Bagnino
      for (const p of this.poops.getChildren()){
        if (!p.active) continue;
        if (isInVisionCone({x:this.lifeguard.x,y:this.lifeguard.y}, this.lifeguard.dir, this.lifeguard.fov, this.lifeguard.range, {x:p.x,y:p.y})) return true;
      }
      // Nuotatori
      for (const s of this.swimmers){
        for (const p of this.poops.getChildren()){
          if (!p.active) continue;
          if (isInVisionCone({x:s.sprite.x,y:s.sprite.y}, s.dir, s.fov, s.range, {x:p.x,y:p.y})) return true;
        }
      }
      // Granchi (se non amici)
      if (!GameState.crabsFriendly){
        for (const c of this.crabs){
          for (const p of this.poops.getChildren()){
            if (!p.active) continue;
            if (isInVisionCone({x:c.sprite.x,y:c.sprite.y}, c.dir, Phaser.Math.DegToRad(35), 80, {x:p.x,y:p.y})) return true;
          }
        }
      }
      return false;
    }
    updateStatusTexts(){ /* placeholder se servisse aggiornare testi subito */ }
  }
   class BossScene extends Phaser.Scene {
  constructor(){ super('BossScene'); }

  create(){
    const { width, height } = this.scale;
    this.cameras.main.setBackgroundColor('#102131');

    // --- STATI VITA (0..1) ---
    this.playerHp = 1;
    this.bossHp   = 1;

    // --- SFONDO SEMPLICE SPIAGGIA/MARE ---
    const bg = this.add.graphics();
    bg.fillStyle(0x0b3d91,1); bg.fillRect(0,0,width,height*0.35);      // cielo
    bg.fillStyle(0x1976d2,1); bg.fillRect(0,height*0.35,width,height*0.25); // mare
    bg.fillStyle(0xf4e2b5,1); bg.fillRect(0,height*0.60,width,height*0.40); // sabbia

    // --- PLAYER ---
    const key = `char_${GameState.selected.specie}_${GameState.selected.eta}_${GameState.selected.genere}`;
    if (!this.textures.exists(key)) createCharacterTexture(this, key, GameState.selected);

    this.player = this.add.image(width*0.2, height*0.7, key);
    this.physics.add.existing(this.player);
    this.player.body.setCircle(this.player.displayWidth/2);
    this.player.body.setCollideWorldBounds(true);

    this.playerLimbs = makeLimbs(this, 0x000000);

    // --- BOSS (BAGNINO) ---
    const lifekey = 'lifeguard_tex';
    if (!this.textures.exists(lifekey)) createLifeguardTexture(this, lifekey);
    this.bossSprite = this.add.image(width*0.75, height*0.45, lifekey);
    this.physics.add.existing(this.bossSprite);
    this.bossSprite.body.setCircle(this.bossSprite.displayWidth/2);
    this.bossSprite.body.setImmovable(true);

    this.bossFrozenUntil = 0;
    this.lastBossShot = 0;
    this.bossShotInterval = 1400; // ms

    // --- PROIETTILI ---
    this.playerProjectiles = this.physics.add.group();
    this.bossProjectiles   = this.physics.add.group();

    // --- BONUS DISPONIBILI DAL MARE ---
    this.canUseNarwhal = !!GameState.hasNarwhal;
    this.canUseSiren   = !!GameState.hasSiren;
    this.canUseTornado = !!GameState.hasTornado;
    this.canUseCrabs   = !!GameState.crabsFriendly; // qui diventano attacco speciale

    // Li consideriamo "consumati" a prescindere dopo questo livello
    GameState.hasNarwhal = false;
    GameState.hasSiren   = false;
    GameState.hasTornado = false;
    GameState.crabsFriendly = false;

    // --- UI BARRE VITA ---
    this.ui = this.add.graphics();
    this.playerHpText = this.add.text(16, 12, '', { fontFamily:FONT, fontSize: 14, color:'#ffffff' });
    this.bossHpText   = this.add.text(width-16, 12, '', { fontFamily:FONT, fontSize: 14, color:'#ffffff' }).setOrigin(1,0);

    // Istruzioni
    this.infoText = this.add.text(width/2, 52,
      'Ultimo livello! Evita gli oggetti del bagnino, lancia üí© e usa i bonus rimasti!',
      { fontFamily:FONT, fontSize: 16, color:'#e3f2fd', align:'center', wordWrap:{ width: Math.min(700, width-40) } }
    ).setOrigin(0.5);

    // Pulsanti testo bonus (solo visivi, la logica √® via tastiera)
    const bottomY = height - 50;
    this.btnPoop = this.add.text(16, bottomY, 'Spara üí© (SPAZIO)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff', backgroundColor:'#a34a00',
      padding:{left:10,right:10,top:6,bottom:6}
    });

    let xCursor = 260;
    this.btnNar = this.add.text(xCursor, bottomY, 'Narvalo üêã (N)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff',
      backgroundColor:this.canUseNarwhal ? '#6a1b9a' : '#555',
      padding:{left:10,right:10,top:6,bottom:6}
    }); xCursor += 170;

    this.btnSir = this.add.text(xCursor, bottomY, 'Sirena üßú‚Äç‚ôÄÔ∏è (S)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff',
      backgroundColor:this.canUseSiren ? '#2947a3' : '#555',
      padding:{left:10,right:10,top:6,bottom:6}
    }); xCursor += 170;

    this.btnTor = this.add.text(xCursor, bottomY, 'Tornado üåÄ (T)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff',
      backgroundColor:this.canUseTornado ? '#00695c' : '#555',
      padding:{left:10,right:10,top:6,bottom:6}
    }); xCursor += 170;

    this.btnCrab = this.add.text(xCursor, bottomY, 'Granchi ü¶Ä (C)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff',
      backgroundColor:this.canUseCrabs ? '#8B4513' : '#555',
      padding:{left:10,right:10,top:6,bottom:6}
    });

    // --- TORNADO VISIVO ---
    this.tornadoUntil = 0;
    this.tornadoGfx = this.add.graphics();

    // --- INPUT ---
    this.cursors = this.input.keyboard.createCursorKeys();
    this.wasd = this.input.keyboard.addKeys('W,A,S,D');
    this.keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
    this.keyN = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.N);
    this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
    this.keyT = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.T);
    this.keyC = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.C);

    this.pointerTarget = null;
    this.pointerMarker = this.add.circle(0,0,8,0x000000,0.3).setVisible(false);
    const setPointerTarget = (p)=>{
      this.pointerTarget = { x:p.worldX, y:p.worldY };
      this.pointerMarker.setPosition(this.pointerTarget.x, this.pointerTarget.y).setVisible(true);
    };
    this.input.on('pointerdown', setPointerTarget);
    this.input.on('pointermove', (p)=>{ if (p.isDown) setPointerTarget(p); });

    // --- COLLISIONI ---
    this.physics.add.overlap(this.player, this.bossProjectiles, this.onPlayerHit, null, this);
    this.physics.add.overlap(this.bossSprite, this.playerProjectiles, this.onBossHit, null, this);

    // --- HUD iniziale ---
    this.updateHud();
  }

  // --- HUD ---
  updateHud(){
    const { width } = this.scale;
    const barW = (width/2) - 40, barH = 20;

    this.ui.clear();
    // barra player (sinistra)
    drawProgressBar(this.ui, 16, 32, barW, barH, this.playerHp, 0x4caf50);
    // barra boss (destra)
    drawProgressBar(this.ui, width - barW - 16, 32, barW, barH, this.bossHp, 0xe53935);

    this.playerHpText.setText(`Vita: ${Math.round(this.playerHp*100)}%`);
    this.bossHpText.setText(`Vita bagnino: ${Math.round(this.bossHp*100)}%`);
  }

  // --- LOGICA SPARO BOSS ---
bossShoot(time){
  if (time < this.lastBossShot + this.bossShotInterval) return;
  if (time < this.bossFrozenUntil) return;

  this.lastBossShot = time;

  const emojis = ['ü©¥','üõü','üèê','ü™£','üèñÔ∏è'];
  const emoji = Phaser.Utils.Array.GetRandom(emojis);

  const proj = this.add.text(this.bossSprite.x, this.bossSprite.y, emoji, {
    fontFamily:FONT, fontSize: 26
  }).setOrigin(0.5);
  this.physics.add.existing(proj);
  proj.body.setCircle(18).setOffset(-18,-18);
  proj.body.setAllowGravity(false);

  // direzione verso il player
  const dx = this.player.x - this.bossSprite.x;
  const dy = this.player.y - this.bossSprite.y;
  const dist = Math.hypot(dx,dy) || 1;
  const speed = 220;

  // salviamo le velocit√† "a mano"
  proj._vx = (dx/dist)*speed;
  proj._vy = (dy/dist)*speed;

  this.bossProjectiles.add(proj);
}

  // --- LOGICA SPARO PLAYER (üí©) ---
 shootPoop(){
  const now = this.time.now;
  if (this._lastPoop && now < this._lastPoop + 220) return;
  this._lastPoop = now;

  const proj = this.add.text(this.player.x, this.player.y, 'üí©', {
    fontFamily:FONT, fontSize: 22
  }).setOrigin(0.5);
  this.physics.add.existing(proj);
  proj.body.setCircle(14).setOffset(-14,-14);
  proj.body.setAllowGravity(false);

  const dx = this.bossSprite.x - this.player.x;
  const dy = this.bossSprite.y - this.player.y;
  const dist = Math.hypot(dx,dy) || 1;
  const speed = 260;

  proj._vx = (dx/dist)*speed;
  proj._vy = (dy/dist)*speed;

  this.playerProjectiles.add(proj);
  SFX.drop();
}

  // --- BONUS: NARVALO ---
  useNarwhal(){
    if (!this.canUseNarwhal) return;
    this.canUseNarwhal = false;
    this.btnNar.setStyle({ backgroundColor:'#555' });

    // Effetto: mangia TUTTI i proiettili del bagnino
    this.add.text(this.player.x, this.player.y - 40, 'üêã', {
      fontFamily:FONT, fontSize: 30
    }).setOrigin(0.5);

    this.bossProjectiles.getChildren().forEach(p=>p.destroy());
    SFX.narwhal();
  }

  // --- BONUS: SIRENA ---
  useSiren(){
    if (!this.canUseSiren) return;
    this.canUseSiren = false;
    this.btnSir.setStyle({ backgroundColor:'#555' });

    this.bossFrozenUntil = this.time.now + 6000; // 6 secondi
    const sir = this.add.text(this.bossSprite.x, this.bossSprite.y - 60, 'üßú‚Äç‚ôÄÔ∏è', {
      fontFamily:FONT, fontSize: 26
    }).setOrigin(0.5);

    this.tweens.add({
      targets:sir,
      y: sir.y - 20,
      alpha: 0,
      duration: 1500,
      onComplete:()=> sir.destroy()
    });

    SFX.siren();
  }

  // --- BONUS: GRANCHI ---
  useCrabs(){
    if (!this.canUseCrabs) return;
    this.canUseCrabs = false;
    this.btnCrab.setStyle({ backgroundColor:'#555' });

    // 3 granchi che caricano il bagnino come mini-cacche
   // 3 granchi che caricano il bagnino come mini-cacche
for (let i=0;i<3;i++){
  const crab = this.add.text(40 + i*30, this.scale.height - 70, 'ü¶Ä', {
    fontFamily:FONT, fontSize: 22
  }).setOrigin(0.5);
  this.physics.add.existing(crab);
  crab.body.setCircle(14).setOffset(-14,-14);
  crab.body.setAllowGravity(false);

  const dx = this.bossSprite.x - crab.x;
  const dy = this.bossSprite.y - crab.y;
  const dist = Math.hypot(dx,dy) || 1;
  const speed = 260;

  crab._vx = (dx/dist)*speed;
  crab._vy = (dy/dist)*speed;

  this.playerProjectiles.add(crab);
}

SFX.crab();


    SFX.crab();
  }

  // --- BONUS: TORNADO ---
  useTornado(){
    if (!this.canUseTornado) return;
    this.canUseTornado = false;
    this.btnTor.setStyle({ backgroundColor:'#555' });

    this.tornadoUntil = this.time.now + 5000; // 5 secondi
    SFX.tornado();
  }

  // --- COLLISIONI ---
  onPlayerHit(player, projectile){
    projectile.destroy();
    this.playerHp = Math.max(0, this.playerHp - 0.18);
    this.updateHud();
    if (this.playerHp <= 0){
      this.endLose();
    } else {
      SFX.wrong();
    }
  }

  onBossHit(boss, projectile){
    projectile.destroy();
    this.bossHp = Math.max(0, this.bossHp - 0.12);
    this.updateHud();
    if (this.bossHp <= 0){
      this.endWin();
    } else {
      SFX.eat();
    }
  }

  endWin(){
    SFX.win();
    resetForNewRun();
    this.scene.start('WinScene');
  }

  endLose(){
    SFX.lose();
    resetForNewRun();
    this.scene.start('LoseScene', { reason:'boss' });
  }

  update(time, delta){
    const dt = delta/1000;
    const { width, height } = this.scale;
    const body = this.player.body;
    body.setVelocity(0);

    const speed = 180;

    // movimento tastiera
    if (this.cursors.left.isDown || this.wasd.A.isDown) body.setVelocityX(-speed);
    else if (this.cursors.right.isDown || this.wasd.D.isDown) body.setVelocityX(speed);

    if (this.cursors.up.isDown || this.wasd.W.isDown) body.setVelocityY(-speed);
    else if (this.cursors.down.isDown || this.wasd.S.isDown) body.setVelocityY(speed);

    // movimento touch/click
    if (this.pointerTarget){
      const dx = this.pointerTarget.x - this.player.x;
      const dy = this.pointerTarget.y - this.player.y;
      const dist = Math.hypot(dx,dy);
      if (dist > 6){
        body.setVelocity((dx/dist)*speed, (dy/dist)*speed);
      } else {
        this.pointerTarget = null;
        this.pointerMarker.setVisible(false);
      }
    }

    // sparo player
    if (Phaser.Input.Keyboard.JustDown(this.keySpace)){
      this.shootPoop();
    }

    // bonus input
    if (Phaser.Input.Keyboard.JustDown(this.keyN)) this.useNarwhal();
    if (Phaser.Input.Keyboard.JustDown(this.keyS)) this.useSiren();
    if (Phaser.Input.Keyboard.JustDown(this.keyT)) this.useTornado();
    if (Phaser.Input.Keyboard.JustDown(this.keyC)) this.useCrabs();

    // sparo boss
    this.bossShoot(time);

    // effetto tornado: allontana i proiettili del bagnino dal player
    this.tornadoGfx.clear();
    if (time < this.tornadoUntil){
      this.tornadoGfx.lineStyle(2, 0x00695c, 0.9);
      this.tornadoGfx.strokeCircle(this.player.x, this.player.y, 40);
      this.tornadoGfx.strokeCircle(this.player.x, this.player.y, 24);

      this.bossProjectiles.getChildren().forEach(p=>{
        const dx = p.x - this.player.x;
        const dy = p.y - this.player.y;
        const dist = Math.hypot(dx,dy) || 1;
        const speed = 260;
        p.body.setVelocity((dx/dist)*speed, (dy/dist)*speed);
      });
    }

    // cleanup proiettili fuori schermo
    this.playerProjectiles.getChildren().forEach(p=>{
      if (p.x < -40 || p.x > width+40 || p.y < -40 || p.y > height+40) p.destroy();
    });
    this.bossProjectiles.getChildren().forEach(p=>{
      if (p.x < -40 || p.x > width+40 || p.y < -40 || p.y > height+40) p.destroy();
    });

    // animazione arti player
    const moving = body.velocity.length() > 5;
    updateLimbs(this.playerLimbs, this.player.x, this.player.y, moving, time/1000);
  }

  shutdown(){
    this.playerLimbs?.destroy?.();
  }
}

class BossScene extends Phaser.Scene {
  constructor(){ super('BossScene'); }

  create(){
    const { width, height } = this.scale;
    this.cameras.main.setBackgroundColor('#102131');

    // --- STATI VITA (0..1) ---
    this.playerHp = 1;
    this.bossHp   = 1;

    // --- SFONDO SEMPLICE SPIAGGIA/MARE ---
    const bg = this.add.graphics();
    bg.fillStyle(0x0b3d91,1); bg.fillRect(0,0,width,height*0.35);      // cielo
    bg.fillStyle(0x1976d2,1); bg.fillRect(0,height*0.35,width,height*0.25); // mare
    bg.fillStyle(0xf4e2b5,1); bg.fillRect(0,height*0.60,width,height*0.40); // sabbia

    // --- PLAYER ---
    const key = `char_${GameState.selected.specie}_${GameState.selected.eta}_${GameState.selected.genere}`;
    if (!this.textures.exists(key)) createCharacterTexture(this, key, GameState.selected);

    this.player = this.add.image(width*0.2, height*0.7, key);
    this.physics.add.existing(this.player);
    this.player.body.setCircle(this.player.displayWidth/2);
    this.player.body.setCollideWorldBounds(true);

    this.playerLimbs = makeLimbs(this, 0x000000);

    // --- BOSS (BAGNINO) ---
    const lifekey = 'lifeguard_tex';
    if (!this.textures.exists(lifekey)) createLifeguardTexture(this, lifekey);
    this.bossSprite = this.add.image(width*0.75, height*0.45, lifekey);
    this.physics.add.existing(this.bossSprite);
    this.bossSprite.body.setCircle(this.bossSprite.displayWidth/2);
    this.bossSprite.body.setImmovable(true);

    this.bossFrozenUntil = 0;
    this.lastBossShot = 0;
    this.bossShotInterval = 1400; // ms

    // --- PROIETTILI ---
    this.playerProjectiles = this.physics.add.group();
    this.bossProjectiles   = this.physics.add.group();

    // --- BONUS DISPONIBILI DAL MARE ---
    this.canUseNarwhal = !!GameState.hasNarwhal;
    this.canUseSiren   = !!GameState.hasSiren;
    this.canUseTornado = !!GameState.hasTornado;
    this.canUseCrabs   = !!GameState.crabsFriendly; // qui diventano attacco speciale

    // Li consideriamo "consumati" a prescindere dopo questo livello
    GameState.hasNarwhal = false;
    GameState.hasSiren   = false;
    GameState.hasTornado = false;
    GameState.crabsFriendly = false;

    // --- UI BARRE VITA ---
    this.ui = this.add.graphics();
    this.playerHpText = this.add.text(16, 12, '', { fontFamily:FONT, fontSize: 14, color:'#ffffff' });
    this.bossHpText   = this.add.text(width-16, 12, '', { fontFamily:FONT, fontSize: 14, color:'#ffffff' }).setOrigin(1,0);

    // Istruzioni
    this.infoText = this.add.text(width/2, 52,
      'Ultimo livello! Evita gli oggetti del bagnino, lancia üí© e usa i bonus rimasti!',
      { fontFamily:FONT, fontSize: 16, color:'#e3f2fd', align:'center', wordWrap:{ width: Math.min(700, width-40) } }
    ).setOrigin(0.5);

    // Pulsanti testo bonus (solo visivi, la logica √® via tastiera)
    const bottomY = height - 50;
    this.btnPoop = this.add.text(16, bottomY, 'Spara üí© (SPAZIO)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff', backgroundColor:'#a34a00',
      padding:{left:10,right:10,top:6,bottom:6}
    });

    let xCursor = 260;
    this.btnNar = this.add.text(xCursor, bottomY, 'Narvalo üêã (N)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff',
      backgroundColor:this.canUseNarwhal ? '#6a1b9a' : '#555',
      padding:{left:10,right:10,top:6,bottom:6}
    }); xCursor += 170;

    this.btnSir = this.add.text(xCursor, bottomY, 'Sirena üßú‚Äç‚ôÄÔ∏è (S)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff',
      backgroundColor:this.canUseSiren ? '#2947a3' : '#555',
      padding:{left:10,right:10,top:6,bottom:6}
    }); xCursor += 170;

    this.btnTor = this.add.text(xCursor, bottomY, 'Tornado üåÄ (T)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff',
      backgroundColor:this.canUseTornado ? '#00695c' : '#555',
      padding:{left:10,right:10,top:6,bottom:6}
    }); xCursor += 170;

    this.btnCrab = this.add.text(xCursor, bottomY, 'Granchi ü¶Ä (C)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff',
      backgroundColor:this.canUseCrabs ? '#8d6e63' : '#555',
      padding:{left:10,right:10,top:6,bottom:6}
    });

    // --- TORNADO VISIVO ---
    this.tornadoUntil = 0;
    this.tornadoGfx = this.add.graphics();

    // --- INPUT ---
    this.cursors = this.input.keyboard.createCursorKeys();
    this.wasd = this.input.keyboard.addKeys('W,A,S,D');
    this.keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
    this.keyN = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.N);
    this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
    this.keyT = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.T);
    this.keyC = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.C);

    this.pointerTarget = null;
    this.pointerMarker = this.add.circle(0,0,8,0x000000,0.3).setVisible(false);
    const setPointerTarget = (p)=>{
      this.pointerTarget = { x:p.worldX, y:p.worldY };
      this.pointerMarker.setPosition(this.pointerTarget.x, this.pointerTarget.y).setVisible(true);
    };
    this.input.on('pointerdown', setPointerTarget);
    this.input.on('pointermove', (p)=>{ if (p.isDown) setPointerTarget(p); });

    // --- COLLISIONI ---
    this.physics.add.overlap(this.player, this.bossProjectiles, this.onPlayerHit, null, this);
    this.physics.add.overlap(this.bossSprite, this.playerProjectiles, this.onBossHit, null, this);

    // --- HUD iniziale ---
    this.updateHud();
  }

  // --- HUD ---
  updateHud(){
    const { width } = this.scale;
    const barW = (width/2) - 40, barH = 20;

    this.ui.clear();
    // barra player (sinistra)
    drawProgressBar(this.ui, 16, 32, barW, barH, this.playerHp, 0x4caf50);
    // barra boss (destra)
    drawProgressBar(this.ui, width - barW - 16, 32, barW, barH, this.bossHp, 0xe53935);

    this.playerHpText.setText(`Vita: ${Math.round(this.playerHp*100)}%`);
    this.bossHpText.setText(`Vita bagnino: ${Math.round(this.bossHp*100)}%`);
  }

  // --- LOGICA SPARO BOSS ---
  bossShoot(time){
    if (time < this.lastBossShot + this.bossShotInterval) return;
    if (time < this.bossFrozenUntil) return;

    this.lastBossShot = time;

    const emojis = ['ü©¥','üõü','üèê','ü™£','üèñÔ∏è'];
    const emoji = Phaser.Utils.Array.GetRandom(emojis);

    const proj = this.add.text(this.bossSprite.x, this.bossSprite.y, emoji, {
      fontFamily:FONT, fontSize: 26
    }).setOrigin(0.5);
    this.physics.add.existing(proj);
    proj.body.setCircle(18).setOffset(-18,-18);
    proj.body.setAllowGravity(false);

    // direzione verso il player
    const dx = this.player.x - this.bossSprite.x;
    const dy = this.player.y - this.bossSprite.y;
    const dist = Math.hypot(dx,dy) || 1;
    const speed = 220;

    // salviamo le velocit√† "a mano"
    proj._vx = (dx/dist)*speed;
    proj._vy = (dy/dist)*speed;

    this.bossProjectiles.add(proj);
  }

  // --- LOGICA SPARO PLAYER (üí©) ---
  shootPoop(){
    const now = this.time.now;
    if (this._lastPoop && now < this._lastPoop + 220) return;
    this._lastPoop = now;

    const proj = this.add.text(this.player.x, this.player.y, 'üí©', {
      fontFamily:FONT, fontSize: 22
    }).setOrigin(0.5);
    this.physics.add.existing(proj);
    proj.body.setCircle(14).setOffset(-14,-14);
    proj.body.setAllowGravity(false);

    const dx = this.bossSprite.x - this.player.x;
    const dy = this.bossSprite.y - this.player.y;
    const dist = Math.hypot(dx,dy) || 1;
    const speed = 260;

    proj._vx = (dx/dist)*speed;
    proj._vy = (dy/dist)*speed;

    this.playerProjectiles.add(proj);
    SFX.drop();
  }

  // --- BONUS: NARVALO ---
  useNarwhal(){
    if (!this.canUseNarwhal) return;
    this.canUseNarwhal = false;
    this.btnNar.setStyle({ backgroundColor:'#555' });

    // Effetto: mangia TUTTI i proiettili del bagnino
    this.add.text(this.player.x, this.player.y - 40, 'üêã', {
      fontFamily:FONT, fontSize: 30
    }).setOrigin(0.5);

    this.bossProjectiles.getChildren().forEach(p=>p.destroy());
    SFX.narwhal();
  }

  // --- BONUS: SIRENA ---
  useSiren(){
    if (!this.canUseSiren) return;
    this.canUseSiren = false;
    this.btnSir.setStyle({ backgroundColor:'#555' });

    this.bossFrozenUntil = this.time.now + 6000; // 6 secondi
    const sir = this.add.text(this.bossSprite.x, this.bossSprite.y - 60, 'üßú‚Äç‚ôÄÔ∏è', {
      fontFamily:FONT, fontSize: 26
    }).setOrigin(0.5);

    this.tweens.add({
      targets:sir,
      y: sir.y - 20,
      alpha: 0,
      duration: 1500,
      onComplete:()=> sir.destroy()
    });

    SFX.siren();
  }

  // --- BONUS: GRANCHI ---
  useCrabs(){
    if (!this.canUseCrabs) return;
    this.canUseCrabs = false;
    this.btnCrab.setStyle({ backgroundColor:'#555' });

    // 3 granchi che caricano il bagnino come mini-cacche
    for (let i=0;i<3;i++){
      const crab = this.add.text(40 + i*30, this.scale.height - 70, 'ü¶Ä', {
        fontFamily:FONT, fontSize: 22
      }).setOrigin(0.5);
      this.physics.add.existing(crab);
      crab.body.setCircle(14).setOffset(-14,-14);
      crab.body.setAllowGravity(false);

      const dx = this.bossSprite.x - crab.x;
      const dy = this.bossSprite.y - crab.y;
      const dist = Math.hypot(dx,dy) || 1;
      const speed = 260;

      crab._vx = (dx/dist)*speed;
      crab._vy = (dy/dist)*speed;

      // li tratto come proiettili del player cos√¨ danneggiano il boss
      this.playerProjectiles.add(crab);
    }

    SFX.crab();
  }

  // --- BONUS: TORNADO ---
  useTornado(){
    if (!this.canUseTornado) return;
    this.canUseTornado = false;
    this.btnTor.setStyle({ backgroundColor:'#555' });

    this.tornadoUntil = this.time.now + 5000; // 5 secondi
    SFX.tornado();
  }

  // --- COLLISIONI ---
  onPlayerHit(player, projectile){
    projectile.destroy();
    this.playerHp = Math.max(0, this.playerHp - 0.18);
    this.updateHud();
    if (this.playerHp <= 0){
      this.endLose();
    } else {
      SFX.wrong();
    }
  }

  onBossHit(boss, projectile){
    projectile.destroy();
    this.bossHp = Math.max(0, this.bossHp - 0.12);
    this.updateHud();
    if (this.bossHp <= 0){
      this.endWin();
    } else {
      SFX.eat();
    }
  }

  endWin(){
    SFX.win();
    resetForNewRun();
    this.scene.start('WinScene');
  }

  endLose(){
    SFX.lose();
    resetForNewRun();
    this.scene.start('LoseScene', { reason:'boss' });
  }

  update(time, delta){
    const dt = delta/1000;
    const { width, height } = this.scale;
    const body = this.player.body;
    body.setVelocity(0);

    const speed = 180;

    // movimento tastiera
    if (this.cursors.left.isDown || this.wasd.A.isDown) body.setVelocityX(-speed);
    else if (this.cursors.right.isDown || this.wasd.D.isDown) body.setVelocityX(speed);

    if (this.cursors.up.isDown || this.wasd.W.isDown) body.setVelocityY(-speed);
    else if (this.cursors.down.isDown || this.wasd.S.isDown) body.setVelocityY(speed);

    // movimento touch/click
    if (this.pointerTarget){
      const dx = this.pointerTarget.x - this.player.x;
      const dy = this.pointerTarget.y - this.player.y;
      const dist = Math.hypot(dx,dy);
      if (dist > 6){
        body.setVelocity((dx/dist)*speed, (dy/dist)*speed);
      } else {
        this.pointerTarget = null;
        this.pointerMarker.setVisible(false);
      }
    }

    // sparo player
    if (Phaser.Input.Keyboard.JustDown(this.keySpace)){
      this.shootPoop();
    }

    // bonus input
    if (Phaser.Input.Keyboard.JustDown(this.keyN)) this.useNarwhal();
    if (Phaser.Input.Keyboard.JustDown(this.keyS)) this.useSiren();
    if (Phaser.Input.Keyboard.JustDown(this.keyT)) this.useTornado();
    if (Phaser.Input.Keyboard.JustDown(this.keyC)) this.useCrabs();

    // sparo boss
    this.bossShoot(time);

    // APPLICAZIONE VELOCIT√Ä PROIETTILI (fix principale)
    this.playerProjectiles.getChildren().forEach(p=>{
      if (!p.body || typeof p._vx !== 'number') return;
      p.body.setVelocity(p._vx, p._vy);
    });

    this.bossProjectiles.getChildren().forEach(p=>{
      if (!p.body || typeof p._vx !== 'number') return;
      p.body.setVelocity(p._vx, p._vy);
    });

    // effetto tornado: allontana i proiettili del bagnino dal player
    this.tornadoGfx.clear();
    if (time < this.tornadoUntil){
      this.tornadoGfx.lineStyle(2, 0x00695c, 0.9);
      this.tornadoGfx.strokeCircle(this.player.x, this.player.y, 40);
      this.tornadoGfx.strokeCircle(this.player.x, this.player.y, 24);

      this.bossProjectiles.getChildren().forEach(p=>{
        const dx = p.x - this.player.x;
        const dy = p.y - this.player.y;
        const dist = Math.hypot(dx,dy) || 1;
        const baseSpeed = Math.hypot(p._vx || 0, p._vy || 0) || 220;
        const factor = 1.3;
        p._vx = (dx/dist)*baseSpeed*factor;
        p._vy = (dy/dist)*baseSpeed*factor;
        p.body.setVelocity(p._vx, p._vy);
      });
    }

    // cleanup proiettili fuori schermo
    this.playerProjectiles.getChildren().forEach(p=>{
      if (p.x < -40 || p.x > width+40 || p.y < -40 || p.y > height+40) p.destroy();
    });
    this.bossProjectiles.getChildren().forEach(p=>{
      if (p.x < -40 || p.x > width+40 || p.y < -40 || p.y > height+40) p.destroy();
    });

    // animazione arti player
    const moving = body.velocity.length() > 5;
    updateLimbs(this.playerLimbs, this.player.x, this.player.y, moving, time/1000);
  }

  shutdown(){
    this.playerLimbs?.destroy?.();
  }
}


  class WinScene extends Phaser.Scene {
    constructor(){ super('WinScene'); }
    create(){
      const { width, height } = this.scale;
      this.cameras.main.setBackgroundColor('#1b5e20');
      this.add.text(width/2, height/2 - 40, 'Ce l\'hai fatta! ü§´üåä', { fontFamily:FONT, fontSize: 28, color:'#ffffff' }).setOrigin(0.5);
      this.add.text(width/2, height/2 + 10, 'Nessuno ha scoperto nulla e hai sconfitto il boss finale! Bravo stratega!', { fontFamily:FONT, fontSize: 16, color:'#e8f5e9' }).setOrigin(0.5);
      this.add.text(width/2 - 130, height - 60, '‚¨Ö Menu', { fontFamily:FONT, fontSize:22, color:'#fff', backgroundColor:'#2e7d32', padding:{left:10,right:10,top:6,bottom:6} }).setOrigin(0.5).setInteractive({useHandCursor:true}).on('pointerdown', ()=>{ resetForNewRun(); this.scene.start('MenuScene'); });
      this.add.text(width/2 + 130, height - 60, '‚ü≤ Gioca ancora', { fontFamily:FONT, fontSize:22, color:'#fff', backgroundColor:'#2e7d32', padding:{left:10,right:10,top:6,bottom:6} }).setOrigin(0.5).setInteractive({useHandCursor:true}).on('pointerdown', ()=>{ resetForNewRun(); this.scene.start('LandScene'); });
    }
  }

  // ========== BOOT ==========
  function setupAudioUnlock(){
    const gate = document.getElementById('audio-gate');
    const btn  = document.getElementById('audio-btn');
    if (!gate || !btn) return;
    gate.style.display = 'flex';
    const unlock = () => {
      try { ensureAudioContext().resume(); } catch(_) {}
      gate.style.display = 'none';
      window.removeEventListener('pointerdown', unlock);
    };
    btn.addEventListener('click', unlock);
    window.addEventListener('pointerdown', unlock, { once:true });
  }

  function createGame(options={}){
    const parent = options.parent || 'game-container';
    setupAudioUnlock();
    const config = {
      type: Phaser.AUTO,
      width: 960,
      height: 540,
      backgroundColor: '#0d1117',
      parent,
      scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
      physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
     scene: [MenuScene, LandScene, SeaScene, BossScene, LoseScene, WinScene]
    };
    return new Phaser.Game(config);
  }

  window.PooPooPanda = { createGame };

  window.addEventListener('DOMContentLoaded', ()=>{
    const el = document.getElementById('game-container');
    if (el) window.PooPooPanda._game = createGame({ parent: 'game-container' });
  });
  </script>
</body>
</html>   */

  const Phaser = window.Phaser;
  const FONT = "Segoe UI Emoji, Apple Color Emoji, Noto Color Emoji, Arial, sans-serif";
const GAME_VERSION = "v1.1.0 - Boss Bagnino";

  // ========== DOMAIN ==========
  const Characters = {
    PANDA_PICCOLO: { specie: 'panda', eta: 'piccolo' },
    PANDA_ADULTO:  { specie: 'panda', eta: 'adulto'  },
    BAMBINO:       { specie: 'umano', eta: 'piccolo' },
    ADULTO:        { specie: 'umano', eta: 'adulto'  }
  };
  const Foods = { BAMBOO: 'bamboo', PASTA: 'pasta', PIZZA: 'pizza', GELATO: 'gelato' }; // gelato = ‚Äúok-ish‚Äù (non fa male)
  function allowedFoodsFor(character){
    if (character.specie === 'panda') return new Set([Foods.BAMBOO]);
    if (character.specie === 'umano' && character.eta === 'piccolo') return new Set([Foods.PASTA]);
    if (character.specie === 'umano' && character.eta === 'adulto') return new Set([Foods.PIZZA]);
    return new Set();
  }
  function poopGain(character, food){
    const allowed = allowedFoodsFor(character);
    if (allowed.has(food)) return 0.18;
    if (food === Foods.GELATO) return 0.06; // un po' di ‚Äúcarica‚Äù extra
    return 0.00; // cibo non adatto ‚Üí niente ‚Äúpoop‚Äù, ma far√† salire ‚Äúmal di pancia‚Äù
  }
  function defaultRng(){ return { int(min, max){ return Math.floor(Math.random()*(max-min+1)) + min; } }; }
  function randomPointAvoiding(center, minDist, bounds, rng = defaultRng()){
    // spawn point ‚Äúlontano abbastanza‚Äù dal player
    const maxTry = 50;
    for (let i=0;i<maxTry;i++){
      const x = rng.int(bounds.xMin, bounds.xMax);
      const y = rng.int(bounds.yMin, bounds.yMax);
      const dx = x - center.x, dy = y - center.y;
      if (Math.hypot(dx,dy) >= minDist) return { x, y };
    }
    return { x: rng.int(bounds.xMin, bounds.xMax), y: rng.int(bounds.yMin, bounds.yMax) };
  }
  function isInVisionCone(observer, dirAngle, fovRad, range, target){
    const dx = target.x - observer.x, dy = target.y - observer.y;
    const dist = Math.hypot(dx, dy); if (dist > range) return false;
    const ang = Math.atan2(dy, dx);
    let diff = ang - dirAngle; // normalizza a [-pi, pi]
    diff = Math.atan2(Math.sin(diff), Math.cos(diff));
    return Math.abs(diff) <= fovRad/2;
  }

  const GameState = {
    selected:   { specie: 'panda', eta: 'piccolo', genere: 'm' },
    poopMeter:  0,   // 0..1
    stomach:    0,   // 0..1 (nuova barra ‚Äúmal di pancia‚Äù)
    hasNarwhal: false,
    hasSiren:   false,
    hasTornado: false,
    crabsFriendly: false, // dopo il bonus granchio diventano amici
    transitioning: false
  };
  function resetForNewRun(){
    GameState.poopMeter = 0;
    GameState.stomach   = 0;
    GameState.hasNarwhal = false;
    GameState.hasSiren   = false;
    GameState.hasTornado = false;
    GameState.crabsFriendly = false;
    GameState.transitioning = false;
  }
  function labelForFood(foodType){
    switch(foodType){
      case Foods.BAMBOO: return 'üéã Bamboo';
      case Foods.PASTA:  return 'üçù Pasta';
      case Foods.PIZZA:  return 'üçï Pizza';
      case Foods.GELATO: return 'üç¶ Gelato';
      default:           return 'Cibo';
    }
  }
  function colorForFood(foodType){
    switch(foodType){
      case Foods.BAMBOO: return '#1f7a1f';
      case Foods.PASTA:  return '#7a5d1f';
      case Foods.PIZZA:  return '#a83232';
      case Foods.GELATO: return '#7a1f6a';
      default:           return '#333333';
    }
  }

  // ========== SFX ==========
  let _audioCtx = null;
  function ensureAudioContext(){ if (!_audioCtx) _audioCtx = new (window.AudioContext || window.webkitAudioContext)(); return _audioCtx; }
  function tone({ freq=440, dur=0.12, type='sine', vol=0.22 }){
    const ctx = ensureAudioContext();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = type; osc.frequency.value = freq;
    osc.connect(gain); gain.connect(ctx.destination);
    gain.gain.setValueAtTime(vol, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + dur);
    osc.start(); osc.stop(ctx.currentTime + dur);
  }
  const SFX = {
    play: (f,d,t,v)=> tone({ freq:f, dur:d, type:t, vol:v }),
    eat(){ this.play(520,0.08,'triangle',0.22); this.play(660,0.06,'sine',0.18); },
    wrong(){ this.play(220,0.10,'sawtooth',0.18); },
    drop(){ this.play(180,0.14,'square',0.22); },
    narwhal(){ this.play(400,0.10,'sine',0.2); this.play(300,0.20,'triangle',0.15); },
    siren(){ this.play(900,0.08,'square',0.2); this.play(700,0.12,'square',0.2); },
    tornado(){ this.play(120,0.3,'sawtooth',0.2); },
    crab(){ this.play(760,0.06,'square',0.22); this.play(640,0.08,'triangle',0.18); }, // bonus granchi
    win(){ [523,659,783].forEach((f,i)=>setTimeout(()=>this.play(f,0.12,'sine',0.22), i*120)); },
    lose(){ [196,185,174].forEach((f,i)=>setTimeout(()=>this.play(f,0.12,'triangle',0.22), i*120)); },
    button(){ this.play(540,0.08,'sine',0.22); }
  };

  // ========== UI helpers ==========
  function drawProgressBar(graphics, x, y, w, h, progress, fillColor=0x9b5a1a){
    graphics.lineStyle(2, 0x222222, 1);
    graphics.strokeRoundedRect(x, y, w, h, 8);
    graphics.fillStyle(0x333333, 1);
    graphics.fillRoundedRect(x, y, w, h, 8);
    const innerPad = 4, iw = (w - innerPad*2) * Math.max(0, Math.min(1, progress));
    graphics.fillStyle(fillColor, 1);
    graphics.fillRoundedRect(x + innerPad, y + innerPad, iw, h - innerPad*2, 6);
  }
  function makeBamboo(scene, x, baseY, totalH){
    const c = scene.add.container(x, baseY);
    const g = scene.add.graphics(); c.add(g);
    const stemW = 16; const segments = Math.max(3, Math.floor(totalH/36));
    let y = 0;
    for (let i=0;i<segments;i++){
      g.fillStyle(0x2e7d32,1); g.fillRoundedRect(-stemW/2, -y-36, stemW, 36, 6);
      g.lineStyle(3,0x1b5e20,1); g.strokeLineShape(new Phaser.Geom.Line(-stemW/2, -y-18, stemW/2, -y-18));
      const leaf = (lx,ly,ang,sz=12)=>{ g.fillStyle(0x66bb6a,1); const ax=Math.cos(ang), ay=Math.sin(ang); g.fillTriangle(lx,ly, lx-ax*sz, ly-ay*sz, lx-ay*sz*0.6, ly+ax*sz*0.6); };
      if (i%2===0) leaf(stemW/2, -y-24, 0.2); else leaf(-stemW/2, -y-10, Math.PI-0.2);
      y += 36;
    }
    c.setSize(stemW, totalH);
    scene.tweens.add({ targets:c, angle:2, yoyo:true, repeat:-1, duration:2200, ease:'Sine.easeInOut' });
    return c;
  }

  // ========== TEXTURES ==========
  function drawBow(g, cx, cy, col=0xff3da7){ g.fillStyle(col,1); g.fillEllipse(cx-6,cy,8,10); g.fillEllipse(cx+6,cy,8,10); g.fillCircle(cx,cy,3); }
  function drawCap(g, cx, cy, col=0x1f4d7a){ g.fillStyle(col,1); g.fillEllipse(cx,cy,26,12); g.fillRect(cx-13, cy, 26, 5); }
  function drawGlasses(g, cx, cy){ g.lineStyle(2,0x000000,1); g.strokeCircle(cx-8,cy,6); g.strokeCircle(cx+8,cy,6); g.lineBetween(cx-2,cy, cx+2,cy); }
  function createCharacterTexture(scene, key, sel){
    const g = scene.add.graphics();
    const isPanda = sel.specie === 'panda';
    const isBaby  = sel.eta === 'piccolo';
    const size = isBaby ? 22 : 28;
    const pad = 22;
    const cx = pad + size, cy = pad + size;
    if (isPanda) {
      g.fillStyle(0xffffff, 1); g.fillCircle(cx, cy, size);
      g.fillStyle(0x000000, 1);
      g.fillCircle(cx-12, cy-18, isBaby?6:7); g.fillCircle(cx+12, cy-18, isBaby?6:7);
      g.fillEllipse(cx-7, cy-2, 10, 14); g.fillEllipse(cx+7, cy-2, 10, 14);
      g.fillStyle(0xffffff, 1); g.fillCircle(cx-7, cy-2, 3); g.fillCircle(cx+7, cy-2, 3);
      g.fillStyle(0x000000, 1); g.fillCircle(cx, cy+5, 3);
      if (isBaby) { g.fillStyle(0xffa3a3,0.8); g.fillCircle(cx-12, cy+10, 3); g.fillCircle(cx+12, cy+10, 3); }
      else { if (sel.genere==='m'){ g.fillStyle(0xa00000,1); g.fillTriangle(cx, cy+18, cx-6, cy+28, cx+6, cy+28); } else { g.fillStyle(0xffe066,1); g.fillCircle(cx, cy+26, 4); } }
      if (sel.genere==='f') drawBow(g, cx-14, cy-26, 0xff3da7); else drawCap(g, cx, cy-28, 0x1f4d7a);
    } else {
      const skin = 0xffe0bd; g.fillStyle(skin, 1); g.fillCircle(cx, cy, size);
      const hairCol = 0x3b2e2a;
      if (isBaby) { g.fillStyle(hairCol, 1); g.fillEllipse(cx, cy-10, size*1.6, size*0.8); }
      else { g.fillStyle(hairCol, 1); if (sel.genere==='f') g.fillEllipse(cx, cy-6, size*1.8, size*1.6); else g.fillEllipse(cx, cy-8, size*1.8, size*1.0); }
      g.fillStyle(0x000000, 1); g.fillCircle(cx-7, cy-2, 3); g.fillCircle(cx+7, cy-2, 3); g.lineStyle(2, 0x000000, 1); g.strokeCircle(cx, cy+6, 6);
      if (sel.genere==='f') drawBow(g, cx-14, cy-26, 0xff3da7); else drawCap(g, cx, cy-28, 0x1f4d7a);
      if (!isBaby && sel.genere==='m') drawGlasses(g, cx, cy-2);
    }
    const w = (size+pad)*2, h = (size+pad)*2; g.generateTexture(key, w, h); g.destroy();
  }
  function createSwimmerTexture(scene, key, tint=0x00a3c4){
    const g = scene.add.graphics(); const pad=10; const r=12, cx=pad+r, cy=pad+r;
    g.fillStyle(0xffe0bd,1); g.fillCircle(cx, cy, r);
    g.fillStyle(tint,1); g.fillEllipse(cx, cy-6, r*1.8, r*1.0);
    g.lineStyle(2,0x000000,1); g.strokeRect(cx-8, cy-2, 16, 4);
    g.fillStyle(0xc0dff4,1); g.fillEllipse(cx, cy+16, r*1.2, r*0.8);
    g.generateTexture(key, pad*2+r*2, pad*2+r*2+16); g.destroy();
  }
  function createLifeguardTexture(scene, key){
    const g = scene.add.graphics(); const pad=10; const r=14, cx=pad+r, cy=pad+r;
    g.fillStyle(0xffe0bd,1); g.fillCircle(cx, cy, r);
    g.fillStyle(0xc62828,1); g.fillEllipse(cx, cy-8, r*1.8, r*1.0); g.fillRect(cx-12, cy-8, 24, 5);
    g.fillStyle(0x808080,1); g.fillRect(cx-2, cy+6, 4, 6);
    g.fillStyle(0xffffff,1); g.fillEllipse(cx, cy+18, r*1.4, r*1.0);
    g.fillStyle(0xc62828,1); g.fillRect(cx-2, cy+14, 4, 8); g.fillRect(cx-6, cy+16, 12, 4);
    g.generateTexture(key, pad*2+r*2, pad*2+r*2+18); g.destroy();
  }

  // ========== LIMBS ==========
  function makeLimbs(scene, color=0x000000){
    const parts = ['LA','RA','LL','RL'].reduce((acc,k)=>{ acc[k]=scene.add.graphics(); return acc; },{});
    const draw = (g,x,y,rot)=>{ g.clear(); g.fillStyle(color,1); g.save(); g.translateCanvas(x,y); g.rotateCanvas(rot); g.fillRoundedRect(-2,-8,4,16,2); g.restore(); };
    return { parts, draw, setVisible(v){ Object.values(parts).forEach(p=>p.setVisible(v)); }, destroy(){ Object.values(parts).forEach(p=>p.destroy()); } };
  }
  function updateLimbs(limbs, px, py, moving, t){
    const amp = moving? 0.8 : 0.2; const speed = moving? 10 : 2; const s = Math.sin(t*speed);
    limbs.draw(limbs.parts.LA, px-12, py+6,  s*amp);
    limbs.draw(limbs.parts.RA, px+12, py+6, -s*amp);
    limbs.draw(limbs.parts.LL, px-8,  py+20, -s*amp);
    limbs.draw(limbs.parts.RL, px+8,  py+20,  s*amp);
  }

  // ========== SCENES ==========
  class MenuScene extends Phaser.Scene {
    constructor(){ super('MenuScene'); }
    create(){
      resetForNewRun();
      const { width, height } = this.scale;

      // Sfondo ‚Äúspiaggia + mare‚Äù come prima
      const bg = this.add.graphics();
      bg.fillStyle(0x0b3d91,1); bg.fillRect(0,0,width,height*0.35);      // cielo
      bg.fillStyle(0x1976d2,1); bg.fillRect(0,height*0.35,width,height*0.25); // mare
      bg.fillStyle(0xf4e2b5,1); bg.fillRect(0,height*0.60,width,height*0.40); // sabbia
      makeBamboo(this, 54, height-20, height*0.75);
      makeBamboo(this, width-54, height-20, height*0.68);

      const title = this.add.text(width/2, 60, 'Poo Poo Panda', { fontFamily: FONT, fontSize: 54, color:'#ffffff' }).setOrigin(0.5);
      title.setShadow(3,3,'#000000',6,true,true);

      const panelW = Math.min(720, width-60), panelH = 300;
      const panel = this.add.graphics();
      panel.fillStyle(0x1b2838, 0.95); panel.fillRoundedRect((width-panelW)/2, 150, panelW, panelH, 20);
      panel.lineStyle(3, 0x64b5f6, 1.0); panel.strokeRoundedRect((width-panelW)/2, 150, panelW, panelH, 20);
      this.add.text(width/2, 165, 'Scegli il personaggio e il genere', { fontFamily: FONT, fontSize: 22, color:'#e3f2fd' }).setOrigin(0.5);

      const options = [
        { label: 'Panda piccolo', value: Characters.PANDA_PICCOLO },
        { label: 'Panda adulto',  value: Characters.PANDA_ADULTO  },
        { label: 'Bambino umano', value: Characters.BAMBINO       },
        { label: 'Adulto umano',  value: Characters.ADULTO        },
      ];
      const cards = []; let selectedIdx = 0; let gender = 'm';
      const startX = (width-panelW)/2 + 28; const startY = 205; const gapX = (panelW-56)/4; const cardW = gapX-14; const cardH = 110;

      const makeCard = (i)=>{
        const x = startX + i*gapX; const y = startY; const c = this.add.container(x, y);
        const g = this.add.graphics(); c.add(g);
        const k = ()=>`menu_prev_${i}_${gender}`;
        const drawCardBG = (active=false)=>{
          g.clear();
          if (active){ g.fillStyle(0x143d5b,1); g.fillRoundedRect(0,0,cardW,cardH,16); g.lineStyle(3,0x64b5f6,1); g.strokeRoundedRect(0,0,cardW,cardH,16); }
          else       { g.fillStyle(0x102131,1); g.fillRoundedRect(0,0,cardW,cardH,16); g.lineStyle(2,0x5dade2,1); g.strokeRoundedRect(0,0,cardW,cardH,16); }
        };
        drawCardBG(i===selectedIdx);

        const ensureTex = ()=>{
          if (!this.textures.exists(k())) createCharacterTexture(this, k(), { ...options[i].value, genere: gender });
        };
        ensureTex();
        const img = this.add.image(cardW/2, 46, k()).setScale(0.9); c.add(img);
        const txt = this.add.text(cardW/2, cardH-20, options[i].label, { fontFamily: FONT, fontSize: 16, color:'#e3f2fd' }).setOrigin(0.5); txt.setShadow(2,2,'#000',4,true,true); c.add(txt);

        c.setSize(cardW, cardH);
        c.setInteractive(new Phaser.Geom.Rectangle(0,0,cardW,cardH), Phaser.Geom.Rectangle.Contains)
          .on('pointerover', ()=> drawCardBG(true))
          .on('pointerout',  ()=> drawCardBG(i===selectedIdx))
          .on('pointerdown', ()=>{ SFX.button(); selectedIdx=i; cards.forEach((card, idx)=>card.drawBG(idx===selectedIdx)); });

        cards.push({c,g,img,txt,drawBG:drawCardBG, refreshTexture:()=>{ ensureTex(); img.setTexture(k()); }});
      };
      for (let i=0;i<options.length;i++) makeCard(i);

      const pillW = 220, pillH = 40; const pillX = width/2 - pillW/2, pillY = 325;
      const pill = this.add.graphics();
      const drawPill = ()=>{
        pill.clear();
        pill.fillStyle(0x102131,1); pill.fillRoundedRect(pillX, pillY, pillW, pillH, 20);
        pill.lineStyle(2,0x90caf9,1); pill.strokeRoundedRect(pillX, pillY, pillW, pillH, 20);
        const knobX = gender==='m'? pillX+pillW*0.25 : pillX+pillW*0.75;
        pill.fillStyle(0x64b5f6,1); pill.fillRoundedRect(knobX-44, pillY+6, 88, pillH-12, 16);
      };
      drawPill();
      this.add.text(pillX+pillW*0.25, pillY+pillH/2, '‚ôÇÔ∏è Maschio', { fontFamily: FONT, fontSize:16, color:'#e3f2fd' }).setOrigin(0.5);
      this.add.text(pillX+pillW*0.75, pillY+pillH/2, '‚ôÄÔ∏è Femmina', { fontFamily: FONT, fontSize:16, color:'#e3f2fd' }).setOrigin(0.5);
      this.add.zone(pillX, pillY, pillW, pillH).setOrigin(0).setInteractive().on('pointerdown', ()=>{
        SFX.button();
        gender = gender==='m' ? 'f' : 'm'; drawPill();
        cards.forEach(c=>c.refreshTexture()); // aggiorna anteprime al cambio genere
      });

      this.add.text(width/2, height - 110, 'Consiglio: Panda‚ÜíBamboo | Bimbo‚ÜíPasta | Adulto‚ÜíPizza', { fontFamily: FONT, fontSize: 16, color: '#0b0b0b', backgroundColor:'#e3f2fd', padding:{left:10,right:10,top:4,bottom:4} }).setOrigin(0.5);

      const start = this.add.text(width/2, height - 60, 'Inizia ‚ñ∂', { fontFamily: FONT, fontSize: 30, color: '#ffffff', backgroundColor:'#43a047', padding:{ left:18, right:18, top:8, bottom:8 } }).setOrigin(0.5);
      start.setShadow(3,3,'#1b5e20',6,true,true);
      start.setInteractive({ useHandCursor: true })
        .on('pointerover', ()=> start.setStyle({ backgroundColor:'#2e7d32' }))
        .on('pointerout',  ()=> start.setStyle({ backgroundColor:'#43a047' }))
        .on('pointerdown', ()=>{
          if (GameState.transitioning) return; GameState.transitioning = true; SFX.button();
          const chosen = options[selectedIdx].value; GameState.selected = { specie: chosen.specie, eta: chosen.eta, genere: gender };
          this.scene.start('LandScene');
        });
		// Versione in basso a destra
this.add.text(
  width - 10,
  height - 10,
  `Versione ${GAME_VERSION}`,
  {
    fontFamily: FONT,
    fontSize: 14,
    color: "#FF0000"
  }
).setOrigin(1, 1).setAlpha(0.8);
    }
  }

  class LandScene extends Phaser.Scene {
    constructor(){ super('LandScene'); }
    create(){
      GameState.transitioning = false; const { width, height } = this.scale;
      // Sfondo: cielo + mare (fascia azzurra) + sabbia
      this.cameras.main.setBackgroundColor('#87CEEB');
      this.bg = this.add.graphics();
      this.bg.fillStyle(0x1976d2,1); this.bg.fillRect(0,height*0.35,width,height*0.25); // fascia mare
      this.bg.fillStyle(0xF4E2B5, 1); this.bg.fillRect(0, height*0.60, width, height*0.40); // sabbia

      this.add.text(10, 10, `Personaggio: ${GameState.selected.specie} ${GameState.selected.eta} (${GameState.selected.genere==='m'?'M':'F'})`, { fontFamily: FONT, fontSize: 16, color: '#000' });

      const key = `char_${GameState.selected.specie}_${GameState.selected.eta}_${GameState.selected.genere}`; createCharacterTexture(this, key, GameState.selected);
      this.player = this.add.image(width/2, height*0.6, key);
      this.physics.add.existing(this.player);
      this.player.body.setCircle(this.player.displayWidth/2);
      this.player.body.setCollideWorldBounds(true);

      this.playerLimbs = makeLimbs(this, 0x000000);
      this.foods = this.physics.add.group(); this.bonuses = this.physics.add.group();

      // UI: barre in alto a DESTRA (non coprono freccia vento della scena mare)
      this.ui = this.add.graphics();
      this.poopText = this.add.text(0, 0, '', { fontFamily: FONT, fontSize: 14, color: '#111' }).setOrigin(1,0);
      this.stomachText = this.add.text(0, 0, '', { fontFamily: FONT, fontSize: 14, color: '#111' }).setOrigin(1,0);

      this.promptText = this.add.text(width/2, 48, '', { fontFamily: FONT, fontSize: 18, color: '#111' }).setOrigin(0.5);
      this.seaBtn = this.add.text(width - 190, 42, 'Vai al Mare ‚ñ∂', { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#0a7d33', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({ useHandCursor:true }).on('pointerdown', () => this.tryGoSea()); this.seaBtn.visible = false;
      this.restartBtn = this.add.text(16, height - 44, '‚ü≤ Ricomincia (R)', { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#444', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({ useHandCursor:true }).on('pointerdown', () => this.restartLand());

      this.sceneStartMs = this.time.now; this.GRACE_MS = 1000; this.EAT_COOLDOWN_MS = 180; this.lastEatMs = 0;

      this.spawnFoodWave(); this.spawnBonusNarwhal();

      this.tut = this.add.text(width/2, height-90, 'Mangia i cibi giusti. Evita quelli sbagliati (mal di pancia). Riempi fino al 60% e vai al mare!', { fontFamily:FONT, fontSize: 16, color:'#001', backgroundColor:'#fff', padding:{left:8,right:8,top:6,bottom:6} }).setOrigin(0.5);
      this.time.delayedCall(5000, ()=> this.tut.setVisible(false));

      this.cursors = this.input.keyboard.createCursorKeys(); this.wasd = this.input.keyboard.addKeys('W,A,S,D');
      this.keyM = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.M);
      this.keyR = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);

      // Controllo touch/click con punto bersaglio
      this.pointerTarget = null; this.pointerMarker = this.add.circle(0, 0, 8, 0x000000, 0.3).setVisible(false);
      const setPointerTarget = (p)=>{ this.pointerTarget = { x: p.worldX, y: p.worldY }; this.pointerMarker.setPosition(this.pointerTarget.x, this.pointerTarget.y).setVisible(true); };
      this.input.on('pointerdown', setPointerTarget); this.input.on('pointermove', (p)=>{ if (p.isDown) setPointerTarget(p); });

      this.physics.add.overlap(this.player, this.foods, this.onEatFood, null, this); this.physics.add.overlap(this.player, this.bonuses, this.onTakeBonus, null, this);

      // Effetto ‚Äúnuoto‚Äù in fascia mare
      this.swimFX = this.add.text(0,0,'üí¶',{ fontFamily:FONT, fontSize:20 }).setVisible(false);
    }
    restartLand(){ resetForNewRun(); this.scene.start('LandScene'); }
    getSafeSpawn(minDist=120){ const { width, height } = this.scale; const b = { xMin: 40, xMax: width-40, yMin: height*0.4, yMax: height-40 }; return randomPointAvoiding({x:this.player.x,y:this.player.y}, minDist, b); }
    spawnFoodWave(){ const types=[Foods.BAMBOO,Foods.PASTA,Foods.PIZZA,Foods.GELATO]; for(let i=0;i<8;i++){ const t=Phaser.Utils.Array.GetRandom(types); const p=this.getSafeSpawn(140); this.spawnFoodAt(p.x,p.y,t);} }
    spawnFoodAt(x,y,t){ const food=this.add.text(x,y,labelForFood(t),{ fontFamily:FONT, fontSize:18, color:colorForFood(t)}).setOrigin(0.5); this.physics.add.existing(food); food.body.setCircle(24).setOffset(-24,-24); food.body.setImmovable(true); food.foodType=t; this.foods.add(food);}  
    spawnSingleFood(){ const types=[Foods.BAMBOO,Foods.PASTA,Foods.PIZZA,Foods.GELATO]; const t=Phaser.Utils.Array.GetRandom(types); const p=this.getSafeSpawn(120); this.spawnFoodAt(p.x,p.y,t); }
    spawnBonusNarwhal(){ if (GameState.hasNarwhal) return; const p=this.getSafeSpawn(160); const b=this.add.text(p.x,p.y,'üêã Narvalo',{ fontFamily:FONT, fontSize:18, color:'#551a8b'}).setOrigin(0.5); this.physics.add.existing(b); b.body.setCircle(26).setOffset(-26,-26); b.body.setImmovable(true); b.bonusType='narwhal'; this.bonuses.add(b);}  
    onEatFood(player, food){
      const now=this.time.now; if (now-this.sceneStartMs< this.GRACE_MS) return; if (now-this.lastEatMs<this.EAT_COOLDOWN_MS) return; this.lastEatMs=now;
      const gain=poopGain(GameState.selected, food.foodType);
      if (gain===0){
        // Cibo NON adatto ‚Üí aumenta ‚Äúmal di pancia‚Äù
        GameState.stomach = Math.min(1, GameState.stomach + 0.22);
        this.tweens.add({targets:food, angle:10, yoyo:true, duration:120, onComplete:()=>food.destroy()});
        SFX.wrong();
      } else {
        GameState.poopMeter = Math.min(1, GameState.poopMeter + gain);
        this.tweens.add({targets:food, scale:1.25, yoyo:true, duration:120, onComplete:()=>food.destroy()});
        SFX.eat();
      }
      this.time.delayedCall(300, ()=>this.spawnSingleFood());
    }
    onTakeBonus(player, bonus){ if (bonus.bonusType==='narwhal'){ GameState.hasNarwhal=true; this.tweens.add({ targets:bonus, angle:360, scale:1.5, duration:240, onComplete:()=>bonus.destroy() }); SFX.narwhal(); } }
    tryGoSea(){ if (GameState.poopMeter<0.6 || GameState.transitioning) return; GameState.transitioning=true; this.scene.start('SeaScene'); }
    update(time, delta){
      const { width, height } = this.scale;
      const body=this.player.body; body.setVelocity(0);

      // Cammina su sabbia, ‚Äúnuota‚Äù in fascia mare (altezza 35%-60%)
      const inWater = (this.player.y >= height*0.35 && this.player.y <= height*0.60);
      const speed = inWater ? 110 : 160;

      // Movimenti
      if (this.cursors.left.isDown||this.wasd.A.isDown) body.setVelocityX(-speed); else if (this.cursors.right.isDown||this.wasd.D.isDown) body.setVelocityX(speed);
      if (this.cursors.up.isDown||this.wasd.W.isDown) body.setVelocityY(-speed); else if (this.cursors.down.isDown||this.wasd.S.isDown) body.setVelocityY(speed);
      if (this.pointerTarget){
        const dx=this.pointerTarget.x-this.player.x, dy=this.pointerTarget.y-this.player.y, dist=Math.hypot(dx,dy);
        if (dist>6) body.setVelocity((dx/dist)*speed, (dy/dist)*speed); else { this.pointerTarget=null; this.pointerMarker.setVisible(false);}
      }

      // UI barre a destra
      const barW=220, barH=22, pad=16;
      const xRight = width - barW - pad;
      this.ui.clear();
      drawProgressBar(this.ui, xRight, 12, barW, barH, GameState.poopMeter, 0x9b5a1a);
      drawProgressBar(this.ui, xRight, 12+barH+6, barW, barH, GameState.stomach,   0xcc3333);
      this.poopText.setPosition(xRight+barW, 12).setText(`Pup√π: ${Math.round(GameState.poopMeter*100)}%`);
      this.stomachText.setPosition(xRight+barW, 12+barH+6).setText(`Mal di pancia: ${Math.round(GameState.stomach*100)}%`);

      const canSea = GameState.poopMeter>=0.6;
      this.promptText.setText(canSea? 'Premi M o tocca ‚ñ∂ Vai al Mare':'Mangia i cibi adatti per riempire la barra'); this.seaBtn.visible=canSea;
      if (Phaser.Input.Keyboard.JustDown(this.keyM)) this.tryGoSea();
      if (Phaser.Input.Keyboard.JustDown(this.keyR)) this.restartLand();

      // Sconfitte in fase Terra:
      if (GameState.poopMeter>=1.0) { SFX.lose(); this.scene.start('LoseScene', { reason:'overeat' }); }
      if (GameState.stomach>=1.0)   { SFX.lose(); this.scene.start('LoseScene', { reason:'stomachache' }); }

      // Effetto nuoto
      this.swimFX.setVisible(inWater).setPosition(this.player.x, this.player.y - 34);

      const moving = body.velocity.length() > 5; updateLimbs(this.playerLimbs, this.player.x, this.player.y, moving, time/1000);
    }
    shutdown(){ this.playerLimbs?.destroy?.(); }
  }

  class SeaScene extends Phaser.Scene {
    constructor(){ super('SeaScene'); }
    create(){
      const { width, height } = this.scale; GameState.transitioning=false;

      // Layout: acqua in alto, SPIAGGIA in basso (dove sta il bagnino e si arena la üí©)
      this.cameras.main.setBackgroundColor('#3CB7E7');
      this.beachHeight = Math.floor(height * 0.26);
      this.beachTopY   = height - this.beachHeight;

      const bg = this.add.graphics();
      // mare pieno (sfondo)
      bg.fillStyle(0x3CB7E7,1); bg.fillRect(0,0,width,height);
      // spiaggia
      bg.fillStyle(0xF4E2B5,1); bg.fillRect(0, this.beachTopY, width, this.beachHeight);

      const key = `char_${GameState.selected.specie}_${GameState.selected.eta}_${GameState.selected.genere}`; createCharacterTexture(this, key, GameState.selected);
      this.player = this.add.image(width*0.5, this.beachTopY - 40, key); // parte vicino alla riva
      this.physics.add.existing(this.player); this.player.body.setCircle(this.player.displayWidth/2); this.player.body.setCollideWorldBounds(true);

      this.playerLimbs = makeLimbs(this, 0x001122);

      // Corrente marina (come versione precedente, senza timer missione)
      this.currentAngle = Phaser.Math.FloatBetween(-Math.PI, Math.PI);
      this.currentSpeed = 38;
      this.currentFrozen = false;
      this.currentArrow = this.add.graphics();

      // Nuvola che annuncia cambio corrente
      this.cloud = this.add.text(width/2, 36, '‚òÅÔ∏è‚òÅÔ∏è‚òÅÔ∏è', { fontFamily:FONT, fontSize: 40, color:'#ffffff' }).setOrigin(0.5).setVisible(false);
      this.tweens.add({ targets:this.cloud, scale:1.15, yoyo:true, repeat:-1, duration:450, ease:'Sine.easeInOut' });
      this.scheduleNextCurrentChange();

      this.poops = this.add.group(); this.narwhals = []; this.swimmers = [];

      // Bagnino sulla SPIAGGIA
      const lifekey = 'lifeguard_tex'; if (!this.textures.exists(lifekey)) createLifeguardTexture(this, lifekey);
      this.lifeguardSprite = this.add.image(width/2, this.beachTopY - 20, lifekey);

    this.lifeguard = {
  x: this.lifeguardSprite.x, 
  y: this.lifeguardSprite.y,
  dir: -Math.PI/2,
  sweepMin: -Math.PI/2 - Phaser.Math.DegToRad(35),
  sweepMax: -Math.PI/2 + Phaser.Math.DegToRad(35),
  speed: Phaser.Math.DegToRad(20),
  fov: Phaser.Math.DegToRad(50),
  range: 360,
  distractedUntil: 0
};

      this.visionGfx = this.add.graphics();

      // Nuotatori in mare
      const capColors = [0x00a3c4,0xffa726,0x8e24aa,0x2e7d32,0xd32f2f,0x455a64];
      for (let i=0; i<6; i++) this.spawnSwimmer(Phaser.Utils.Array.GetRandom(capColors));

      // Bonus di mare (narvalo/sirena/tornado) + bonus GRANCHIO sulla spiaggia
      this.seaBonuses = this.physics.add.group();
      if (!GameState.hasNarwhal) this.spawnSeaBonus('narwhal');
      if (!GameState.hasSiren)   this.spawnSeaBonus('siren');
      if (!GameState.hasTornado) this.spawnSeaBonus('tornado');
      this.spawnCrabBonus();

      // Tornado
      this.tornado = null; this.tornadoGfx = this.add.graphics();

      // UI (barre a destra)
      this.ui = this.add.graphics();
      this.uiText = this.add.text(16, 12, '', { fontFamily:FONT, fontSize: 16, color:'#001' });
      this.statusText = this.add.text(width/2, 12, '', { fontFamily:FONT, fontSize: 16, color:'#001' }).setOrigin(0.5);
      this.poopText = this.add.text(0, 0, '', { fontFamily:FONT, fontSize: 14, color:'#001' }).setOrigin(1,0);
      this.stomachText = this.add.text(0, 0, '', { fontFamily:FONT, fontSize: 14, color:'#001' }).setOrigin(1,0);

      // Controlli
      this.dropBtn   = this.add.text(16, height - 44, 'Sgancia üí© (SPAZIO)', { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#a34a00', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ this.dropPoop(); SFX.drop(); });
      this.narBtn    = this.add.text(260, height - 44, 'Narvalo üêã (N)',     { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#6a1b9a', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ this.triggerNarwhal(); SFX.narwhal(); });
      this.sirenBtn  = this.add.text(440, height - 44, 'Sirena ‚ú® (S)',      { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#2947a3', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ this.triggerSiren(); SFX.siren(); });
      this.tornBtn   = this.add.text(600, height - 44, 'Tornado üåÄ (T)',     { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#00695c', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ this.triggerTornado(); SFX.tornado(); });
      this.menuBtn   = this.add.text(width - 280, height - 44, '‚¨Ö Menu',     { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#444', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ resetForNewRun(); this.scene.start('MenuScene'); });
      this.restartBtn= this.add.text(width - 140, height - 44, '‚ü≤ Ricomincia',{ fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#444', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ resetForNewRun(); this.scene.start('LandScene'); });

      this.tut = this.add.text(width/2, height-90, 'Lascia la üí© in mare e aspetta che si arena. Evita i coni (bagnino/nuotatori/granchi). Prendi il bonus ü¶Ä sulla spiaggia!', { fontFamily:FONT, fontSize: 16, color:'#001', backgroundColor:'#fff', padding:{left:8,right:8,top:6,bottom:6} }).setOrigin(0.5);
      this.time.delayedCall(7000, ()=> this.tut.setVisible(false));

      this.cursors = this.input.keyboard.createCursorKeys(); this.wasd = this.input.keyboard.addKeys('W,A,S,D');
      this.keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
      this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
      this.keyN = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.N);
      this.keyT = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.T);
      this.pointerTarget = null; this.pointerMarker = this.add.circle(0,0,8,0x000000,0.3).setVisible(false);
      const setPointerTarget = (p)=>{ this.pointerTarget = { x: p.worldX, y: p.worldY }; this.pointerMarker.setPosition(this.pointerTarget.x, this.pointerTarget.y).setVisible(true); };
      this.input.on('pointerdown', setPointerTarget); this.input.on('pointermove', (p)=>{ if (p.isDown) setPointerTarget(p); });

      this.physics.add.overlap(this.player, this.seaBonuses, (player, b)=>{
        if (b.type==='narwhal'){ GameState.hasNarwhal = true; SFX.narwhal(); }
        if (b.type==='siren')  { GameState.hasSiren = true;   SFX.siren(); }
        if (b.type==='tornado'){ GameState.hasTornado = true; SFX.tornado(); }
        if (b.type==='crab')   { GameState.crabsFriendly = true; SFX.crab(); this.onCrabsBefriend(); }
        this.tweens.add({ targets:b, angle:360, scale:1.5, duration:240, onComplete:()=>b.destroy() });
      });

      // Crea granchi sulla spiaggia
      this.crabs = []; this.crabGfx = this.add.graphics();
      this.spawnCrabs(6); // numero granchi

      // Delay breve per inizializzare
      this.time.delayedCall(300, ()=> this.updateStatusTexts());
    }
    scheduleNextCurrentChange(){
      const nextMs = Phaser.Math.Between(12000, 20000);
      this._cloudTimer1 = this.time.delayedCall(nextMs - 2500, ()=>{ if (!this.currentFrozen) this.cloud.setVisible(true); });
      this._cloudTimer2 = this.time.delayedCall(nextMs, ()=>{
        if (this.currentFrozen) { this.cloud.setVisible(false); this.scheduleNextCurrentChange(); return; }
        this.currentAngle = Phaser.Math.FloatBetween(-Math.PI, Math.PI);
        this.cloud.setVisible(false);
        this.scheduleNextCurrentChange();
      });
    }
    spawnSeaBonus(type){
      const { width } = this.scale;
      // bonus in ACQUA (non in spiaggia)
      const x = Phaser.Math.Between(40, width-40), y = Phaser.Math.Between(90, this.beachTopY-60);
      const label = type==='narwhal' ? 'üêã Narvalo' : type==='siren' ? 'üßú‚Äç‚ôÄÔ∏è Sirena' : 'üåÄ Tornado';
      const color = type==='narwhal' ? '#6a1b9a' : type==='siren' ? '#0a4abf' : '#00695c';
      const b = this.add.text(x, y, label, { fontFamily:FONT, fontSize: 18, color: color }).setOrigin(0.5);
      this.physics.add.existing(b); b.body.setCircle(26).setOffset(-26,-26); b.body.setImmovable(true); b.type = type;
      this.seaBonuses.add(b);
    }
    spawnCrabBonus(){
      const { width } = this.scale;
      const x = Phaser.Math.Between(40, width-40), y = Phaser.Math.Between(this.beachTopY+20, this.beachTopY + this.beachHeight - 30);
      const b = this.add.text(x, y, 'ü¶Ä Bonus', { fontFamily:FONT, fontSize: 18, color:'#8B4513' }).setOrigin(0.5);
      this.physics.add.existing(b); b.body.setCircle(26).setOffset(-26,-26); b.body.setImmovable(true); b.type='crab';
      this.seaBonuses.add(b);
    }
    spawnSwimmer(tint){ const { width } = this.scale; const x = Phaser.Math.Between(60, width-60), y = Phaser.Math.Between(90, this.beachTopY-80); const key = `swim_${tint}`; if (!this.textures.exists(key)) createSwimmerTexture(this, key, tint); const s = this.add.image(x,y,key); this.physics.add.existing(s); s.body.setCircle(s.displayWidth/2); s.body.setCollideWorldBounds(true); const limbs = makeLimbs(this, 0x223344); const data = { sprite:s, dir: Phaser.Math.FloatBetween(-Math.PI, Math.PI), speed: 40, fov: Phaser.Math.DegToRad(40), range: 140, changeAt: 0, limbs }; this.swimmers.push(data); }
    spawnCrabs(n=5){
      for (let i=0;i<n;i++){
        const x = Phaser.Math.Between(40, this.scale.width-40);
        const y = Phaser.Math.Between(this.beachTopY+16, this.scale.height-32);
        const t = this.add.text(x, y, 'ü¶Ä', { fontFamily:FONT, fontSize: 22 }); this.physics.add.existing(t); t.body.setCircle(12).setCollideWorldBounds(true);
        const crab = { sprite:t, dir: Phaser.Math.FloatBetween(-Math.PI, Math.PI), speed: 34, fov: Phaser.Math.DegToRad(35), range: 110, changeAt: 0, friend:false };
        this.crabs.push(crab);
      }
    }
    onCrabsBefriend(){
      // Tutti amici!
      this.crabs.forEach(c=>c.friend=true);
    }
    nearestPoop(from){ let best=null, bestD=1e9; this.poops.getChildren().forEach(p=>{ if(!p.active) return; const d=Phaser.Math.Distance.Between(from.x,from.y,p.x,p.y); if(d<bestD){ best=p; bestD=d; } }); return best; }
    triggerNarwhal(){ if (!GameState.hasNarwhal) return; const n = this.add.text(this.player.x, this.player.y, 'üêã', { fontFamily:FONT, fontSize: 26 }); n._speed = 90; n._target = this.nearestPoop(n); this.narwhals.push(n); GameState.hasNarwhal = false; SFX.narwhal(); }
    triggerSiren(){ if (!GameState.hasSiren) return; GameState.hasSiren = false; const siren = this.add.text(this.player.x, this.player.y, 'üßú‚Äç‚ôÄÔ∏è', { fontFamily:FONT, fontSize: 26 }); this.lifeguard.distractedUntil = this.time.now + 15000; this.time.delayedCall(15000, ()=>{ siren.destroy(); }); SFX.siren(); }
    triggerTornado(){ if (!GameState.hasTornado) return; GameState.hasTornado = false; this.tornado = { x: this.player.x, y: this.player.y, until: this.time.now + 15000 }; SFX.tornado(); }
    dropPoop(){
      if (GameState.poopMeter <= 0) return;
      const chunk = Math.min(GameState.poopMeter, 0.2);
      GameState.poopMeter = Math.max(0, Math.min(1, GameState.poopMeter - chunk));
      const p = this.add.text(this.player.x, this.player.y, 'üí©', { fontFamily:FONT, fontSize: 20});
      p._tDrop = this.time.now; p._ttlMs = 60000; p._stranded=false;
      p._label = this.add.text(p.x, p.y-18, '60', { fontFamily:FONT, fontSize: 12, color:'#001' }).setOrigin(0.5);
      this.poops.add(p); SFX.drop();
    }
    update(time, delta){
      const dt = delta/1000; const { width, height } = this.scale;
      const body=this.player.body; body.setVelocity(0);

      // Player: in acqua -> corrente; su SPIAGGIA -> niente corrente
      const onBeach = (this.player.y >= this.beachTopY);
      const speed = onBeach ? 150 : 120;

      if (this.cursors.left.isDown||this.wasd.A.isDown) body.setVelocityX(-speed); else if (this.cursors.right.isDown||this.wasd.D.isDown) body.setVelocityX(speed);
      if (this.cursors.up.isDown||this.wasd.W.isDown) body.setVelocityY(-speed); else if (this.cursors.down.isDown||this.wasd.S.isDown) body.setVelocityY(speed);
      if (this.pointerTarget){ const dx=this.pointerTarget.x-this.player.x, dy=this.pointerTarget.y-this.player.y, dist=Math.hypot(dx,dy); if (dist>6) body.setVelocity((dx/dist)*speed,(dy/dist)*speed); else { this.pointerTarget=null; this.pointerMarker.setVisible(false);} }

      // Corrente marina (solo acqua)
      const cx = Math.cos(this.currentAngle)*this.currentSpeed;
      const cy = Math.sin(this.currentAngle)*this.currentSpeed;
      if (!onBeach){ body.velocity.x += cx; body.velocity.y += cy; }

      // Freccia corrente in alto a SINISTRA
      this.currentArrow.clear(); this.currentArrow.fillStyle(0x002244, 0.15); this.currentArrow.fillCircle(40, 40, 18); this.currentArrow.lineStyle(5, 0xfff176, 0.95);
      const ax=40, ay=40; const ex=ax + Math.cos(this.currentAngle)*32, ey=ay + Math.sin(this.currentAngle)*32; this.currentArrow.lineBetween(ax, ay, ex, ey);
      this.currentArrow.fillStyle(0xfff176, 1); this.currentArrow.fillTriangle(ex, ey, ex - Math.cos(this.currentAngle+0.5)*10, ey - Math.sin(this.currentAngle+0.5)*10, ex - Math.cos(this.currentAngle-0.5)*10, ey - Math.sin(this.currentAngle-0.5)*10);

      // Sweep bagnino (se non distratto)
      if (time >= this.lifeguard.distractedUntil){
        this.lifeguard.dir += this.lifeguard.speed * dt;
        if (this.lifeguard.dir > this.lifeguard.sweepMax || this.lifeguard.dir < this.lifeguard.sweepMin){
          this.lifeguard.speed *= -1; 
          this.lifeguard.dir = Phaser.Math.Clamp(this.lifeguard.dir, this.lifeguard.sweepMin, this.lifeguard.sweepMax);
        }
      }

      // Nuotatori casuali + tornado
      for (const s of this.swimmers){
        if (time > s.changeAt){ s.dir = Phaser.Math.FloatBetween(-Math.PI, Math.PI); s.changeAt = time + Phaser.Math.Between(1200, 2600); }
        let vx = Math.cos(s.dir)*s.speed + cx, vy = Math.sin(s.dir)*s.speed + cy;
        if (this.tornado && time < this.tornado.until){
          const dx = this.tornado.x - s.sprite.x, dy = this.tornado.y - s.sprite.y; const d = Math.hypot(dx,dy)||1; const pull = 120;
          vx += (dx/d)*pull; vy += (dy/d)*pull;
        }
        s.sprite.body.setVelocity(vx, vy);
        const moving = Math.hypot(vx,vy)>5; updateLimbs(s.limbs, s.sprite.x, s.sprite.y, moving, time/1000);
      }
      if (this.tornado && time >= this.tornado.until){ this.tornado=null; this.tornadoGfx.clear(); }
      this.tornadoGfx.clear(); if (this.tornado){ this.tornadoGfx.lineStyle(3, 0x00695c, 0.9); this.tornadoGfx.strokeCircle(this.tornado.x, this.tornado.y, 24); this.tornadoGfx.strokeCircle(this.tornado.x, this.tornado.y, 12); this.tornadoGfx.strokeCircle(this.tornado.x, this.tornado.y, 36); }

      // Narvali che puliscono
      for (const n of this.narwhals){
        if (!n.active) continue;
        if (!n._target || !n._target.active) n._target = this.nearestPoop(n);
        if (n._target){
          const dx = n._target.x - n.x, dy = n._target.y - n.y; const d = Math.hypot(dx,dy)||1;
          n.x += (dx/d)*n._speed*dt + cx*dt; n.y += (dy/d)*n._speed*dt + cy*dt;
          if (d<10 && n._target.active){ n._target._label?.destroy(); n._target.destroy(); n._target = this.nearestPoop(n); SFX.narwhal(); }
        } else {
          n.x += cx*dt; n.y += cy*dt; n._despawnAt = n._despawnAt || (time+2000); if (time>=n._despawnAt){ n.destroy(); }
        }
      }

      // üí©: si muove in acqua con la corrente; su SPIAGGIA si ‚Äúarena‚Äù e resta ferma
      this.poops.getChildren().forEach(p=>{
        const wasBeach = p._stranded;
        const nowBeach = (p.y >= this.beachTopY);
        if (!p._stranded && !nowBeach){ p.x += cx*dt; p.y += cy*dt; }
        if (nowBeach) p._stranded = true;
        p._label?.setPosition(p.x, p.y-18);
        const left = Math.max(0, Math.ceil((p._ttlMs - (time - p._tDrop))/1000));
        p._label?.setText(left.toString());
        if (left<=0 && p.active){ p._label?.destroy(); p.destroy(); }
        // Limita ai bordi
        p.x = Phaser.Math.Clamp(p.x, 8, width-8);
        p.y = Phaser.Math.Clamp(p.y, 60, height-8);
      });

      // Granchi: pattuglia spiaggia; se amici, mangiano la üí©
      for (const c of this.crabs){
        if (time > c.changeAt){ c.dir = Phaser.Math.FloatBetween(-Math.PI, Math.PI); c.changeAt = time + Phaser.Math.Between(1000, 2200); }
        let vx = Math.cos(c.dir)*c.speed, vy = Math.sin(c.dir)*c.speed;
        // resta su SPIAGGIA
        const nx = c.sprite.x + vx*dt, ny = c.sprite.y + vy*dt;
        if (ny < this.beachTopY+10 || ny > height-16) { c.dir = -c.dir; continue; }
        c.sprite.x = Phaser.Math.Clamp(nx, 16, width-16);
        c.sprite.y = Phaser.Math.Clamp(ny, this.beachTopY+10, height-16);

        if (c.friend){
          // ‚ÄúAmico‚Äù: cerca la üí© pi√π vicina e la mangia
          const target = this.nearestPoop(c.sprite);
          if (target){
            const dx=target.x-c.sprite.x, dy=target.y-c.sprite.y, d=Math.hypot(dx,dy)||1;
            c.sprite.x += (dx/d)*50*dt; c.sprite.y += (dy/d)*50*dt;
            if (d<12 && target.active){ target._label?.destroy(); target.destroy(); SFX.crab(); }
          }
        }
      }

      // Disegna coni di visione: bagnino + nuotatori + (granchi se NON amici)
      this.visionGfx.clear();
      this.drawCone(this.visionGfx, this.lifeguard.x, this.lifeguard.y, this.lifeguard.dir, this.lifeguard.fov, this.lifeguard.range, 0xff0000, 0.15);
      for (const s of this.swimmers){ this.drawCone(this.visionGfx, s.sprite.x, s.sprite.y, s.dir, s.fov, s.range, 0xff8800, 0.12); }
      if (!GameState.crabsFriendly){
        for (const c of this.crabs){
          // piccolissimo cono
          const dir = c.dir, fov = Phaser.Math.DegToRad(35), range = 80;
          this.drawCone(this.visionGfx, c.sprite.x, c.sprite.y, dir, fov, range, 0xaa5500, 0.12);
        }
      }

      // Sconfitta se QUALCUNO vede una üí© (bagnino, nuotatori, granchi non amici)
      if (this.isAnyPoopDetected()){ SFX.lose(); resetForNewRun(); this.scene.start('LoseScene', { reason:'detected' }); return; }

     // Vittoria: niente pi√π ‚Äúcarico‚Äù e nessuna üí© attiva ‚Üí si va al livello BOSS
if (GameState.poopMeter <= 0 && this.poops.countActive(true) === 0){
  SFX.win();
  // NON facciamo resetForNewRun: ci servono ancora i bonus nel livello finale
  this.scene.start('BossScene');
  return;
}
      // HUD (barre a destra + stato bonus)
      const barW=220, barH=22, pad=16, xRight = width - barW - pad;
      this.ui.clear();
      drawProgressBar(this.ui, xRight, 12, barW, barH, GameState.poopMeter, 0x9b5a1a);
      drawProgressBar(this.ui, xRight, 12+barH+6, barW, barH, GameState.stomach,   0xcc3333);
      this.poopText.setPosition(xRight+barW, 12).setText(`Pup√π: ${Math.round(GameState.poopMeter*100)}%`);
      this.stomachText.setPosition(xRight+barW, 12+barH+6).setText(`Mal di pancia: ${Math.round(GameState.stomach*100)}%`);

      const status = [
        GameState.hasNarwhal? 'Narvalo pronto' : 'Narvalo no',
        GameState.hasSiren?   'Sirena pronta'  : 'Sirena no',
        GameState.hasTornado? 'Tornado pronto' : 'Tornado no',
        GameState.crabsFriendly? 'Granchi amici' : 'Granchi neutrali'
      ];
      const distractLeft = Math.max(0, Math.ceil((this.lifeguard.distractedUntil - time)/1000));
      this.uiText.setText(`Cacchette: ${this.poops.countActive(true)}`);
      this.statusText.setText(status.join('  ‚Ä¢  ') + (distractLeft>0?`  ‚Ä¢  Bagnino distratto: ${distractLeft}s`:''));

      // Scorciatoie tastiera
      if (Phaser.Input.Keyboard.JustDown(this.keySpace)) { this.dropPoop(); SFX.drop(); }
      if (Phaser.Input.Keyboard.JustDown(this.keyS)) { this.triggerSiren(); SFX.siren(); }
      if (Phaser.Input.Keyboard.JustDown(this.keyN)) { this.triggerNarwhal(); SFX.narwhal(); }
      if (Phaser.Input.Keyboard.JustDown(this.keyT)) { this.triggerTornado(); SFX.tornado(); }

      const moving = body.velocity.length() > 5; updateLimbs(this.playerLimbs, this.player.x, this.player.y, moving, time/1000);
    }
    drawCone(gfx, x, y, dir, fov, range, color, alpha){
      gfx.fillStyle(color, alpha);
      const a1 = dir - fov/2, a2 = dir + fov/2;
      const p1 = { x: x + Math.cos(a1)*range, y: y + Math.sin(a1)*range };
      const p2 = { x: x + Math.cos(a2)*range, y: y + Math.sin(a2)*range };
      gfx.beginPath(); gfx.moveTo(x,y); gfx.lineTo(p1.x, p1.y); gfx.arc(x,y,range,a1,a2); gfx.lineTo(x,y); gfx.closePath(); gfx.fillPath();
    }
    isAnyPoopDetected(){
      // Bagnino
      for (const p of this.poops.getChildren()){
        if (!p.active) continue;
        if (isInVisionCone({x:this.lifeguard.x,y:this.lifeguard.y}, this.lifeguard.dir, this.lifeguard.fov, this.lifeguard.range, {x:p.x,y:p.y})) return true;
      }
      // Nuotatori
      for (const s of this.swimmers){
        for (const p of this.poops.getChildren()){
          if (!p.active) continue;
          if (isInVisionCone({x:s.sprite.x,y:s.sprite.y}, s.dir, s.fov, s.range, {x:p.x,y:p.y})) return true;
        }
      }
      // Granchi (se non amici)
      if (!GameState.crabsFriendly){
        for (const c of this.crabs){
          for (const p of this.poops.getChildren()){
            if (!p.active) continue;
            if (isInVisionCone({x:c.sprite.x,y:c.sprite.y}, c.dir, Phaser.Math.DegToRad(35), 80, {x:p.x,y:p.y})) return true;
          }
        }
      }
      return false;
    }
    updateStatusTexts(){ /* placeholder se servisse aggiornare testi subito */ }
  }
   class BossScene extends Phaser.Scene {
  constructor(){ super('BossScene'); }

  create(){
    const { width, height } = this.scale;
    this.cameras.main.setBackgroundColor('#102131');

    // --- STATI VITA (0..1) ---
    this.playerHp = 1;
    this.bossHp   = 1;

    // --- SFONDO SEMPLICE SPIAGGIA/MARE ---
    const bg = this.add.graphics();
    bg.fillStyle(0x0b3d91,1); bg.fillRect(0,0,width,height*0.35);      // cielo
    bg.fillStyle(0x1976d2,1); bg.fillRect(0,height*0.35,width,height*0.25); // mare
    bg.fillStyle(0xf4e2b5,1); bg.fillRect(0,height*0.60,width,height*0.40); // sabbia

    // --- PLAYER ---
    const key = `char_${GameState.selected.specie}_${GameState.selected.eta}_${GameState.selected.genere}`;
    if (!this.textures.exists(key)) createCharacterTexture(this, key, GameState.selected);

    this.player = this.add.image(width*0.2, height*0.7, key);
    this.physics.add.existing(this.player);
    this.player.body.setCircle(this.player.displayWidth/2);
    this.player.body.setCollideWorldBounds(true);

    this.playerLimbs = makeLimbs(this, 0x000000);

    // --- BOSS (BAGNINO) ---
    const lifekey = 'lifeguard_tex';
    if (!this.textures.exists(lifekey)) createLifeguardTexture(this, lifekey);
    this.bossSprite = this.add.image(width*0.75, height*0.45, lifekey);
    this.physics.add.existing(this.bossSprite);
    this.bossSprite.body.setCircle(this.bossSprite.displayWidth/2);
    this.bossSprite.body.setImmovable(true);

    this.bossFrozenUntil = 0;
    this.lastBossShot = 0;
    this.bossShotInterval = 1400; // ms

    // --- PROIETTILI ---
    this.playerProjectiles = this.physics.add.group();
    this.bossProjectiles   = this.physics.add.group();

    // --- BONUS DISPONIBILI DAL MARE ---
    this.canUseNarwhal = !!GameState.hasNarwhal;
    this.canUseSiren   = !!GameState.hasSiren;
    this.canUseTornado = !!GameState.hasTornado;
    this.canUseCrabs   = !!GameState.crabsFriendly; // qui diventano attacco speciale

    // Li consideriamo "consumati" a prescindere dopo questo livello
    GameState.hasNarwhal = false;
    GameState.hasSiren   = false;
    GameState.hasTornado = false;
    GameState.crabsFriendly = false;

    // --- UI BARRE VITA ---
    this.ui = this.add.graphics();
    this.playerHpText = this.add.text(16, 12, '', { fontFamily:FONT, fontSize: 14, color:'#ffffff' });
    this.bossHpText   = this.add.text(width-16, 12, '', { fontFamily:FONT, fontSize: 14, color:'#ffffff' }).setOrigin(1,0);

    // Istruzioni
    this.infoText = this.add.text(width/2, 52,
      'Ultimo livello! Evita gli oggetti del bagnino, lancia üí© e usa i bonus rimasti!',
      { fontFamily:FONT, fontSize: 16, color:'#e3f2fd', align:'center', wordWrap:{ width: Math.min(700, width-40) } }
    ).setOrigin(0.5);

    // Pulsanti testo bonus (solo visivi, la logica √® via tastiera)
    const bottomY = height - 50;
    this.btnPoop = this.add.text(16, bottomY, 'Spara üí© (SPAZIO)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff', backgroundColor:'#a34a00',
      padding:{left:10,right:10,top:6,bottom:6}
    });

    let xCursor = 260;
    this.btnNar = this.add.text(xCursor, bottomY, 'Narvalo üêã (N)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff',
      backgroundColor:this.canUseNarwhal ? '#6a1b9a' : '#555',
      padding:{left:10,right:10,top:6,bottom:6}
    }); xCursor += 170;

    this.btnSir = this.add.text(xCursor, bottomY, 'Sirena üßú‚Äç‚ôÄÔ∏è (S)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff',
      backgroundColor:this.canUseSiren ? '#2947a3' : '#555',
      padding:{left:10,right:10,top:6,bottom:6}
    }); xCursor += 170;

    this.btnTor = this.add.text(xCursor, bottomY, 'Tornado üåÄ (T)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff',
      backgroundColor:this.canUseTornado ? '#00695c' : '#555',
      padding:{left:10,right:10,top:6,bottom:6}
    }); xCursor += 170;

    this.btnCrab = this.add.text(xCursor, bottomY, 'Granchi ü¶Ä (C)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff',
      backgroundColor:this.canUseCrabs ? '#8B4513' : '#555',
      padding:{left:10,right:10,top:6,bottom:6}
    });

    // --- TORNADO VISIVO ---
    this.tornadoUntil = 0;
    this.tornadoGfx = this.add.graphics();

    // --- INPUT ---
    this.cursors = this.input.keyboard.createCursorKeys();
    this.wasd = this.input.keyboard.addKeys('W,A,S,D');
    this.keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
    this.keyN = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.N);
    this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
    this.keyT = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.T);
    this.keyC = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.C);

    this.pointerTarget = null;
    this.pointerMarker = this.add.circle(0,0,8,0x000000,0.3).setVisible(false);
    const setPointerTarget = (p)=>{
      this.pointerTarget = { x:p.worldX, y:p.worldY };
      this.pointerMarker.setPosition(this.pointerTarget.x, this.pointerTarget.y).setVisible(true);
    };
    this.input.on('pointerdown', setPointerTarget);
    this.input.on('pointermove', (p)=>{ if (p.isDown) setPointerTarget(p); });

    // --- COLLISIONI ---
    this.physics.add.overlap(this.player, this.bossProjectiles, this.onPlayerHit, null, this);
    this.physics.add.overlap(this.bossSprite, this.playerProjectiles, this.onBossHit, null, this);

    // --- HUD iniziale ---
    this.updateHud();
  }

  // --- HUD ---
  updateHud(){
    const { width } = this.scale;
    const barW = (width/2) - 40, barH = 20;

    this.ui.clear();
    // barra player (sinistra)
    drawProgressBar(this.ui, 16, 32, barW, barH, this.playerHp, 0x4caf50);
    // barra boss (destra)
    drawProgressBar(this.ui, width - barW - 16, 32, barW, barH, this.bossHp, 0xe53935);

    this.playerHpText.setText(`Vita: ${Math.round(this.playerHp*100)}%`);
    this.bossHpText.setText(`Vita bagnino: ${Math.round(this.bossHp*100)}%`);
  }

  // --- LOGICA SPARO BOSS ---
bossShoot(time){
  if (time < this.lastBossShot + this.bossShotInterval) return;
  if (time < this.bossFrozenUntil) return;

  this.lastBossShot = time;

  const emojis = ['ü©¥','üõü','üèê','ü™£','üèñÔ∏è'];
  const emoji = Phaser.Utils.Array.GetRandom(emojis);

  const proj = this.add.text(this.bossSprite.x, this.bossSprite.y, emoji, {
    fontFamily:FONT, fontSize: 26
  }).setOrigin(0.5);
  this.physics.add.existing(proj);
  proj.body.setCircle(18).setOffset(-18,-18);
  proj.body.setAllowGravity(false);

  // direzione verso il player
  const dx = this.player.x - this.bossSprite.x;
  const dy = this.player.y - this.bossSprite.y;
  const dist = Math.hypot(dx,dy) || 1;
  const speed = 220;

  // salviamo le velocit√† "a mano"
  proj._vx = (dx/dist)*speed;
  proj._vy = (dy/dist)*speed;

  this.bossProjectiles.add(proj);
}

  // --- LOGICA SPARO PLAYER (üí©) ---
 shootPoop(){
  const now = this.time.now;
  if (this._lastPoop && now < this._lastPoop + 220) return;
  this._lastPoop = now;

  const proj = this.add.text(this.player.x, this.player.y, 'üí©', {
    fontFamily:FONT, fontSize: 22
  }).setOrigin(0.5);
  this.physics.add.existing(proj);
  proj.body.setCircle(14).setOffset(-14,-14);
  proj.body.setAllowGravity(false);

  const dx = this.bossSprite.x - this.player.x;
  const dy = this.bossSprite.y - this.player.y;
  const dist = Math.hypot(dx,dy) || 1;
  const speed = 260;

  proj._vx = (dx/dist)*speed;
  proj._vy = (dy/dist)*speed;

  this.playerProjectiles.add(proj);
  SFX.drop();
}

  // --- BONUS: NARVALO ---
  useNarwhal(){
    if (!this.canUseNarwhal) return;
    this.canUseNarwhal = false;
    this.btnNar.setStyle({ backgroundColor:'#555' });

    // Effetto: mangia TUTTI i proiettili del bagnino
    this.add.text(this.player.x, this.player.y - 40, 'üêã', {
      fontFamily:FONT, fontSize: 30
    }).setOrigin(0.5);

    this.bossProjectiles.getChildren().forEach(p=>p.destroy());
    SFX.narwhal();
  }

  // --- BONUS: SIRENA ---
  useSiren(){
    if (!this.canUseSiren) return;
    this.canUseSiren = false;
    this.btnSir.setStyle({ backgroundColor:'#555' });

    this.bossFrozenUntil = this.time.now + 6000; // 6 secondi
    const sir = this.add.text(this.bossSprite.x, this.bossSprite.y - 60, 'üßú‚Äç‚ôÄÔ∏è', {
      fontFamily:FONT, fontSize: 26
    }).setOrigin(0.5);

    this.tweens.add({
      targets:sir,
      y: sir.y - 20,
      alpha: 0,
      duration: 1500,
      onComplete:()=> sir.destroy()
    });

    SFX.siren();
  }

  // --- BONUS: GRANCHI ---
  useCrabs(){
    if (!this.canUseCrabs) return;
    this.canUseCrabs = false;
    this.btnCrab.setStyle({ backgroundColor:'#555' });

    // 3 granchi che caricano il bagnino come mini-cacche
   // 3 granchi che caricano il bagnino come mini-cacche
for (let i=0;i<3;i++){
  const crab = this.add.text(40 + i*30, this.scale.height - 70, 'ü¶Ä', {
    fontFamily:FONT, fontSize: 22
  }).setOrigin(0.5);
  this.physics.add.existing(crab);
  crab.body.setCircle(14).setOffset(-14,-14);
  crab.body.setAllowGravity(false);

  const dx = this.bossSprite.x - crab.x;
  const dy = this.bossSprite.y - crab.y;
  const dist = Math.hypot(dx,dy) || 1;
  const speed = 260;

  crab._vx = (dx/dist)*speed;
  crab._vy = (dy/dist)*speed;

  this.playerProjectiles.add(crab);
}

SFX.crab();


    SFX.crab();
  }

  // --- BONUS: TORNADO ---
  useTornado(){
    if (!this.canUseTornado) return;
    this.canUseTornado = false;
    this.btnTor.setStyle({ backgroundColor:'#555' });

    this.tornadoUntil = this.time.now + 5000; // 5 secondi
    SFX.tornado();
  }

  // --- COLLISIONI ---
  onPlayerHit(player, projectile){
    projectile.destroy();
    this.playerHp = Math.max(0, this.playerHp - 0.18);
    this.updateHud();
    if (this.playerHp <= 0){
      this.endLose();
    } else {
      SFX.wrong();
    }
  }

  onBossHit(boss, projectile){
    projectile.destroy();
    this.bossHp = Math.max(0, this.bossHp - 0.12);
    this.updateHud();
    if (this.bossHp <= 0){
      this.endWin();
    } else {
      SFX.eat();
    }
  }

  endWin(){
    SFX.win();
    resetForNewRun();
    this.scene.start('WinScene');
  }

  endLose(){
    SFX.lose();
    resetForNewRun();
    this.scene.start('LoseScene', { reason:'boss' });
  }

  update(time, delta){
    const dt = delta/1000;
    const { width, height } = this.scale;
    const body = this.player.body;
    body.setVelocity(0);

    const speed = 180;

    // movimento tastiera
    if (this.cursors.left.isDown || this.wasd.A.isDown) body.setVelocityX(-speed);
    else if (this.cursors.right.isDown || this.wasd.D.isDown) body.setVelocityX(speed);

    if (this.cursors.up.isDown || this.wasd.W.isDown) body.setVelocityY(-speed);
    else if (this.cursors.down.isDown || this.wasd.S.isDown) body.setVelocityY(speed);

    // movimento touch/click
    if (this.pointerTarget){
      const dx = this.pointerTarget.x - this.player.x;
      const dy = this.pointerTarget.y - this.player.y;
      const dist = Math.hypot(dx,dy);
      if (dist > 6){
        body.setVelocity((dx/dist)*speed, (dy/dist)*speed);
      } else {
        this.pointerTarget = null;
        this.pointerMarker.setVisible(false);
      }
    }

    // sparo player
    if (Phaser.Input.Keyboard.JustDown(this.keySpace)){
      this.shootPoop();
    }

    // bonus input
    if (Phaser.Input.Keyboard.JustDown(this.keyN)) this.useNarwhal();
    if (Phaser.Input.Keyboard.JustDown(this.keyS)) this.useSiren();
    if (Phaser.Input.Keyboard.JustDown(this.keyT)) this.useTornado();
    if (Phaser.Input.Keyboard.JustDown(this.keyC)) this.useCrabs();

    // sparo boss
    this.bossShoot(time);

    // effetto tornado: allontana i proiettili del bagnino dal player
    this.tornadoGfx.clear();
    if (time < this.tornadoUntil){
      this.tornadoGfx.lineStyle(2, 0x00695c, 0.9);
      this.tornadoGfx.strokeCircle(this.player.x, this.player.y, 40);
      this.tornadoGfx.strokeCircle(this.player.x, this.player.y, 24);

      this.bossProjectiles.getChildren().forEach(p=>{
        const dx = p.x - this.player.x;
        const dy = p.y - this.player.y;
        const dist = Math.hypot(dx,dy) || 1;
        const speed = 260;
        p.body.setVelocity((dx/dist)*speed, (dy/dist)*speed);
      });
    }

    // cleanup proiettili fuori schermo
    this.playerProjectiles.getChildren().forEach(p=>{
      if (p.x < -40 || p.x > width+40 || p.y < -40 || p.y > height+40) p.destroy();
    });
    this.bossProjectiles.getChildren().forEach(p=>{
      if (p.x < -40 || p.x > width+40 || p.y < -40 || p.y > height+40) p.destroy();
    });

    // animazione arti player
    const moving = body.velocity.length() > 5;
    updateLimbs(this.playerLimbs, this.player.x, this.player.y, moving, time/1000);
  }

  shutdown(){
    this.playerLimbs?.destroy?.();
  }
}

class BossScene extends Phaser.Scene {
  constructor(){ super('BossScene'); }

  create(){
    const { width, height } = this.scale;
    this.cameras.main.setBackgroundColor('#102131');

    // --- STATI VITA (0..1) ---
    this.playerHp = 1;
    this.bossHp   = 1;

    // --- SFONDO SEMPLICE SPIAGGIA/MARE ---
    const bg = this.add.graphics();
    bg.fillStyle(0x0b3d91,1); bg.fillRect(0,0,width,height*0.35);      // cielo
    bg.fillStyle(0x1976d2,1); bg.fillRect(0,height*0.35,width,height*0.25); // mare
    bg.fillStyle(0xf4e2b5,1); bg.fillRect(0,height*0.60,width,height*0.40); // sabbia

    // --- PLAYER ---
    const key = `char_${GameState.selected.specie}_${GameState.selected.eta}_${GameState.selected.genere}`;
    if (!this.textures.exists(key)) createCharacterTexture(this, key, GameState.selected);

    this.player = this.add.image(width*0.2, height*0.7, key);
    this.physics.add.existing(this.player);
    this.player.body.setCircle(this.player.displayWidth/2);
    this.player.body.setCollideWorldBounds(true);

    this.playerLimbs = makeLimbs(this, 0x000000);

    // --- BOSS (BAGNINO) ---
    const lifekey = 'lifeguard_tex';
    if (!this.textures.exists(lifekey)) createLifeguardTexture(this, lifekey);
    this.bossSprite = this.add.image(width*0.75, height*0.45, lifekey);
    this.physics.add.existing(this.bossSprite);
    this.bossSprite.body.setCircle(this.bossSprite.displayWidth/2);
    this.bossSprite.body.setImmovable(true);

    this.bossFrozenUntil = 0;
    this.lastBossShot = 0;
    this.bossShotInterval = 1400; // ms

    // --- PROIETTILI ---
    this.playerProjectiles = this.physics.add.group();
    this.bossProjectiles   = this.physics.add.group();

    // --- BONUS DISPONIBILI DAL MARE ---
    this.canUseNarwhal = !!GameState.hasNarwhal;
    this.canUseSiren   = !!GameState.hasSiren;
    this.canUseTornado = !!GameState.hasTornado;
    this.canUseCrabs   = !!GameState.crabsFriendly; // qui diventano attacco speciale

    // Li consideriamo "consumati" a prescindere dopo questo livello
    GameState.hasNarwhal = false;
    GameState.hasSiren   = false;
    GameState.hasTornado = false;
    GameState.crabsFriendly = false;

    // --- UI BARRE VITA ---
    this.ui = this.add.graphics();
    this.playerHpText = this.add.text(16, 12, '', { fontFamily:FONT, fontSize: 14, color:'#ffffff' });
    this.bossHpText   = this.add.text(width-16, 12, '', { fontFamily:FONT, fontSize: 14, color:'#ffffff' }).setOrigin(1,0);

    // Istruzioni
    this.infoText = this.add.text(width/2, 52,
      'Ultimo livello! Evita gli oggetti del bagnino, lancia üí© e usa i bonus rimasti!',
      { fontFamily:FONT, fontSize: 16, color:'#e3f2fd', align:'center', wordWrap:{ width: Math.min(700, width-40) } }
    ).setOrigin(0.5);

    // Pulsanti testo bonus (solo visivi, la logica √® via tastiera)
    const bottomY = height - 50;
    this.btnPoop = this.add.text(16, bottomY, 'Spara üí© (SPAZIO)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff', backgroundColor:'#a34a00',
      padding:{left:10,right:10,top:6,bottom:6}
    });

    let xCursor = 260;
    this.btnNar = this.add.text(xCursor, bottomY, 'Narvalo üêã (N)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff',
      backgroundColor:this.canUseNarwhal ? '#6a1b9a' : '#555',
      padding:{left:10,right:10,top:6,bottom:6}
    }); xCursor += 170;

    this.btnSir = this.add.text(xCursor, bottomY, 'Sirena üßú‚Äç‚ôÄÔ∏è (S)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff',
      backgroundColor:this.canUseSiren ? '#2947a3' : '#555',
      padding:{left:10,right:10,top:6,bottom:6}
    }); xCursor += 170;

    this.btnTor = this.add.text(xCursor, bottomY, 'Tornado üåÄ (T)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff',
      backgroundColor:this.canUseTornado ? '#00695c' : '#555',
      padding:{left:10,right:10,top:6,bottom:6}
    }); xCursor += 170;

    this.btnCrab = this.add.text(xCursor, bottomY, 'Granchi ü¶Ä (C)', {
      fontFamily:FONT, fontSize:18, color:'#ffffff',
      backgroundColor:this.canUseCrabs ? '#8d6e63' : '#555',
      padding:{left:10,right:10,top:6,bottom:6}
    });

    // --- TORNADO VISIVO ---
    this.tornadoUntil = 0;
    this.tornadoGfx = this.add.graphics();

    // --- INPUT ---
    this.cursors = this.input.keyboard.createCursorKeys();
    this.wasd = this.input.keyboard.addKeys('W,A,S,D');
    this.keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
    this.keyN = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.N);
    this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
    this.keyT = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.T);
    this.keyC = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.C);

    this.pointerTarget = null;
    this.pointerMarker = this.add.circle(0,0,8,0x000000,0.3).setVisible(false);
    const setPointerTarget = (p)=>{
      this.pointerTarget = { x:p.worldX, y:p.worldY };
      this.pointerMarker.setPosition(this.pointerTarget.x, this.pointerTarget.y).setVisible(true);
    };
    this.input.on('pointerdown', setPointerTarget);
    this.input.on('pointermove', (p)=>{ if (p.isDown) setPointerTarget(p); });

    // --- COLLISIONI ---
    this.physics.add.overlap(this.player, this.bossProjectiles, this.onPlayerHit, null, this);
    this.physics.add.overlap(this.bossSprite, this.playerProjectiles, this.onBossHit, null, this);

    // --- HUD iniziale ---
    this.updateHud();
  }

  // --- HUD ---
  updateHud(){
    const { width } = this.scale;
    const barW = (width/2) - 40, barH = 20;

    this.ui.clear();
    // barra player (sinistra)
    drawProgressBar(this.ui, 16, 32, barW, barH, this.playerHp, 0x4caf50);
    // barra boss (destra)
    drawProgressBar(this.ui, width - barW - 16, 32, barW, barH, this.bossHp, 0xe53935);

    this.playerHpText.setText(`Vita: ${Math.round(this.playerHp*100)}%`);
    this.bossHpText.setText(`Vita bagnino: ${Math.round(this.bossHp*100)}%`);
  }

  // --- LOGICA SPARO BOSS ---
  bossShoot(time){
    if (time < this.lastBossShot + this.bossShotInterval) return;
    if (time < this.bossFrozenUntil) return;

    this.lastBossShot = time;

    const emojis = ['ü©¥','üõü','üèê','ü™£','üèñÔ∏è'];
    const emoji = Phaser.Utils.Array.GetRandom(emojis);

    const proj = this.add.text(this.bossSprite.x, this.bossSprite.y, emoji, {
      fontFamily:FONT, fontSize: 26
    }).setOrigin(0.5);
    this.physics.add.existing(proj);
    proj.body.setCircle(18).setOffset(-18,-18);
    proj.body.setAllowGravity(false);

    // direzione verso il player
    const dx = this.player.x - this.bossSprite.x;
    const dy = this.player.y - this.bossSprite.y;
    const dist = Math.hypot(dx,dy) || 1;
    const speed = 220;

    // salviamo le velocit√† "a mano"
    proj._vx = (dx/dist)*speed;
    proj._vy = (dy/dist)*speed;

    this.bossProjectiles.add(proj);
  }

  // --- LOGICA SPARO PLAYER (üí©) ---
  shootPoop(){
    const now = this.time.now;
    if (this._lastPoop && now < this._lastPoop + 220) return;
    this._lastPoop = now;

    const proj = this.add.text(this.player.x, this.player.y, 'üí©', {
      fontFamily:FONT, fontSize: 22
    }).setOrigin(0.5);
    this.physics.add.existing(proj);
    proj.body.setCircle(14).setOffset(-14,-14);
    proj.body.setAllowGravity(false);

    const dx = this.bossSprite.x - this.player.x;
    const dy = this.bossSprite.y - this.player.y;
    const dist = Math.hypot(dx,dy) || 1;
    const speed = 260;

    proj._vx = (dx/dist)*speed;
    proj._vy = (dy/dist)*speed;

    this.playerProjectiles.add(proj);
    SFX.drop();
  }

  // --- BONUS: NARVALO ---
  useNarwhal(){
    if (!this.canUseNarwhal) return;
    this.canUseNarwhal = false;
    this.btnNar.setStyle({ backgroundColor:'#555' });

    // Effetto: mangia TUTTI i proiettili del bagnino
    this.add.text(this.player.x, this.player.y - 40, 'üêã', {
      fontFamily:FONT, fontSize: 30
    }).setOrigin(0.5);

    this.bossProjectiles.getChildren().forEach(p=>p.destroy());
    SFX.narwhal();
  }

  // --- BONUS: SIRENA ---
  useSiren(){
    if (!this.canUseSiren) return;
    this.canUseSiren = false;
    this.btnSir.setStyle({ backgroundColor:'#555' });

    this.bossFrozenUntil = this.time.now + 6000; // 6 secondi
    const sir = this.add.text(this.bossSprite.x, this.bossSprite.y - 60, 'üßú‚Äç‚ôÄÔ∏è', {
      fontFamily:FONT, fontSize: 26
    }).setOrigin(0.5);

    this.tweens.add({
      targets:sir,
      y: sir.y - 20,
      alpha: 0,
      duration: 1500,
      onComplete:()=> sir.destroy()
    });

    SFX.siren();
  }

  // --- BONUS: GRANCHI ---
  useCrabs(){
    if (!this.canUseCrabs) return;
    this.canUseCrabs = false;
    this.btnCrab.setStyle({ backgroundColor:'#555' });

    // 3 granchi che caricano il bagnino come mini-cacche
    for (let i=0;i<3;i++){
      const crab = this.add.text(40 + i*30, this.scale.height - 70, 'ü¶Ä', {
        fontFamily:FONT, fontSize: 22
      }).setOrigin(0.5);
      this.physics.add.existing(crab);
      crab.body.setCircle(14).setOffset(-14,-14);
      crab.body.setAllowGravity(false);

      const dx = this.bossSprite.x - crab.x;
      const dy = this.bossSprite.y - crab.y;
      const dist = Math.hypot(dx,dy) || 1;
      const speed = 260;

      crab._vx = (dx/dist)*speed;
      crab._vy = (dy/dist)*speed;

      // li tratto come proiettili del player cos√¨ danneggiano il boss
      this.playerProjectiles.add(crab);
    }

    SFX.crab();
  }

  // --- BONUS: TORNADO ---
  useTornado(){
    if (!this.canUseTornado) return;
    this.canUseTornado = false;
    this.btnTor.setStyle({ backgroundColor:'#555' });

    this.tornadoUntil = this.time.now + 5000; // 5 secondi
    SFX.tornado();
  }

  // --- COLLISIONI ---
  onPlayerHit(player, projectile){
    projectile.destroy();
    this.playerHp = Math.max(0, this.playerHp - 0.18);
    this.updateHud();
    if (this.playerHp <= 0){
      this.endLose();
    } else {
      SFX.wrong();
    }
  }

  onBossHit(boss, projectile){
    projectile.destroy();
    this.bossHp = Math.max(0, this.bossHp - 0.12);
    this.updateHud();
    if (this.bossHp <= 0){
      this.endWin();
    } else {
      SFX.eat();
    }
  }

  endWin(){
    SFX.win();
    resetForNewRun();
    this.scene.start('WinScene');
  }

  endLose(){
    SFX.lose();
    resetForNewRun();
    this.scene.start('LoseScene', { reason:'boss' });
  }

  update(time, delta){
    const dt = delta/1000;
    const { width, height } = this.scale;
    const body = this.player.body;
    body.setVelocity(0);

    const speed = 180;

    // movimento tastiera
    if (this.cursors.left.isDown || this.wasd.A.isDown) body.setVelocityX(-speed);
    else if (this.cursors.right.isDown || this.wasd.D.isDown) body.setVelocityX(speed);

    if (this.cursors.up.isDown || this.wasd.W.isDown) body.setVelocityY(-speed);
    else if (this.cursors.down.isDown || this.wasd.S.isDown) body.setVelocityY(speed);

    // movimento touch/click
    if (this.pointerTarget){
      const dx = this.pointerTarget.x - this.player.x;
      const dy = this.pointerTarget.y - this.player.y;
      const dist = Math.hypot(dx,dy);
      if (dist > 6){
        body.setVelocity((dx/dist)*speed, (dy/dist)*speed);
      } else {
        this.pointerTarget = null;
        this.pointerMarker.setVisible(false);
      }
    }

    // sparo player
    if (Phaser.Input.Keyboard.JustDown(this.keySpace)){
      this.shootPoop();
    }

    // bonus input
    if (Phaser.Input.Keyboard.JustDown(this.keyN)) this.useNarwhal();
    if (Phaser.Input.Keyboard.JustDown(this.keyS)) this.useSiren();
    if (Phaser.Input.Keyboard.JustDown(this.keyT)) this.useTornado();
    if (Phaser.Input.Keyboard.JustDown(this.keyC)) this.useCrabs();

    // sparo boss
    this.bossShoot(time);

    // APPLICAZIONE VELOCIT√Ä PROIETTILI (fix principale)
    this.playerProjectiles.getChildren().forEach(p=>{
      if (!p.body || typeof p._vx !== 'number') return;
      p.body.setVelocity(p._vx, p._vy);
    });

    this.bossProjectiles.getChildren().forEach(p=>{
      if (!p.body || typeof p._vx !== 'number') return;
      p.body.setVelocity(p._vx, p._vy);
    });

    // effetto tornado: allontana i proiettili del bagnino dal player
    this.tornadoGfx.clear();
    if (time < this.tornadoUntil){
      this.tornadoGfx.lineStyle(2, 0x00695c, 0.9);
      this.tornadoGfx.strokeCircle(this.player.x, this.player.y, 40);
      this.tornadoGfx.strokeCircle(this.player.x, this.player.y, 24);

      this.bossProjectiles.getChildren().forEach(p=>{
        const dx = p.x - this.player.x;
        const dy = p.y - this.player.y;
        const dist = Math.hypot(dx,dy) || 1;
        const baseSpeed = Math.hypot(p._vx || 0, p._vy || 0) || 220;
        const factor = 1.3;
        p._vx = (dx/dist)*baseSpeed*factor;
        p._vy = (dy/dist)*baseSpeed*factor;
        p.body.setVelocity(p._vx, p._vy);
      });
    }

    // cleanup proiettili fuori schermo
    this.playerProjectiles.getChildren().forEach(p=>{
      if (p.x < -40 || p.x > width+40 || p.y < -40 || p.y > height+40) p.destroy();
    });
    this.bossProjectiles.getChildren().forEach(p=>{
      if (p.x < -40 || p.x > width+40 || p.y < -40 || p.y > height+40) p.destroy();
    });

    // animazione arti player
    const moving = body.velocity.length() > 5;
    updateLimbs(this.playerLimbs, this.player.x, this.player.y, moving, time/1000);
  }

  shutdown(){
    this.playerLimbs?.destroy?.();
  }
}


  class WinScene extends Phaser.Scene {
  constructor(){ super('WinScene'); }
  create(){
    const { width, height } = this.scale;
    this.cameras.main.setBackgroundColor('#1b5e20');

    this.add.text(
      width/2,
      height/2 - 40,
      'Ce l\'hai fatta! ü§´üåä',
      { fontFamily:FONT, fontSize: 28, color:'#ffffff' }
    ).setOrigin(0.5);

    this.add.text(
      width/2,
      height/2 + 10,
      'Nessuno ha scoperto nulla e hai sconfitto il boss finale! Bravo stratega!',
      { fontFamily:FONT, fontSize: 16, color:'#e8f5e9' }
    ).setOrigin(0.5);

    this.add.text(
      width/2 - 130,
      height - 60,
      '‚¨Ö Menu',
      {
        fontFamily:FONT,
        fontSize:22,
        color:'#fff',
        backgroundColor:'#2e7d32',
        padding:{left:10,right:10,top:6,bottom:6}
      }
    )
    .setOrigin(0.5)
    .setInteractive({useHandCursor:true})
    .on('pointerdown', ()=>{
      resetForNewRun();
      this.scene.start('MenuScene');
    });

    this.add.text(
      width/2 + 130,
      height - 60,
      '‚ü≤ Gioca ancora',
      {
        fontFamily:FONT,
        fontSize:22,
        color:'#fff',
        backgroundColor:'#2e7d32',
        padding:{left:10,right:10,top:6,bottom:6}
      }
    )
    .setOrigin(0.5)
    .setInteractive({useHandCursor:true})
    .on('pointerdown', ()=>{
      resetForNewRun();
      this.scene.start('LandScene');
    });
  }
}


  // ========== BOOT ==========
  function setupAudioUnlock(){
    const gate = document.getElementById('audio-gate');
    const btn  = document.getElementById('audio-btn');
    if (!gate || !btn) return;
    gate.style.display = 'flex';
    const unlock = () => {
      try { ensureAudioContext().resume(); } catch(_) {}
      gate.style.display = 'none';
      window.removeEventListener('pointerdown', unlock);
    };
    btn.addEventListener('click', unlock);
    window.addEventListener('pointerdown', unlock, { once:true });
  }

  function createGame(options={}){
    const parent = options.parent || 'game-container';
    setupAudioUnlock();
    const config = {
      type: Phaser.AUTO,
      width: 960,
      height: 540,
      backgroundColor: '#0d1117',
      parent,
      scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
      physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
     scene: [MenuScene, LandScene, SeaScene, BossScene, LoseScene, WinScene]
    };
    return new Phaser.Game(config);
  }

  window.PooPooPanda = { createGame };

  window.addEventListener('DOMContentLoaded', ()=>{
    const el = document.getElementById('game-container');
    if (el) window.PooPooPanda._game = createGame({ parent: 'game-container' });
  });
  </script>
</body>
</html>
