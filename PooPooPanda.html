<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Poo Poo Panda ‚Äî Single-file (spacchettabile)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0d1117; }
    body { font-family: 'Segoe UI Emoji','Apple Color Emoji','Noto Color Emoji', system-ui, Arial, sans-serif; }
    #game-container { width:100vw; height:100vh; display:flex; align-items:center; justify-content:center; }
    .audio-unlock { position: fixed; inset: 0; display: none; align-items:center; justify-content:center; background: rgba(0,0,0,0.6); z-index: 999; }
    .audio-unlock > button { font-size: 18px; padding: 10px 14px; border-radius: 12px; border: 0; background: #0a7d33; color: #fff; box-shadow: 0 6px 16px rgba(0,0,0,0.35); cursor:pointer; }
    .hint { position: fixed; bottom: 8px; left: 8px; background: rgba(255,255,255,0.9); padding: 6px 8px; border-radius: 8px; font-size: 12px; z-index: 50; }
  </style>
</head>
<body>
  <div id="game-container"></div>
  <div id="audio-gate" class="audio-unlock"><button id="audio-btn">üîà Tocca per attivare audio</button></div>
  <div class="hint">Tocco/click per muovere ‚Ä¢ SPAZIO: üí© ‚Ä¢ N: üêã ‚Ä¢ S: üßú‚Äç‚ôÄÔ∏è ‚Ä¢ T: üåÄ</div>

  <!-- Phaser UMD (global window.Phaser) -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.87.0/dist/phaser.min.js"></script>

  <!-- Gioco integrato in un solo <script> (modulare e facilmente spacchettabile) -->
  <script type="module">
  /*
   * Poo Poo Panda ‚Äî Single-file bundle (spacchettabile)
   * ---------------------------------------------------
   * Come suddividere in moduli se serve:
   *   - domain         -> blocco // DOMAIN
   *   - sfx            -> blocco // SFX (audio)
   *   - ui             -> blocco // UI (componenti grafici)
   *   - textures       -> blocco // TEXTURES
   *   - limbs          -> blocco // LIMBS
   *   - scenes         -> blocco // SCENES (Menu/Land/Sea/Lose/Win)
   *   - boot/main      -> blocco // BOOT
   */
  const Phaser = window.Phaser;
  const FONT = "Segoe UI Emoji, Apple Color Emoji, Noto Color Emoji, Arial, sans-serif";

  // =====================================
  // DOMAIN
  // =====================================
  const Characters = {
    PANDA_PICCOLO: { specie: 'panda', eta: 'piccolo' },
    PANDA_ADULTO:  { specie: 'panda', eta: 'adulto'  },
    BAMBINO:       { specie: 'umano', eta: 'piccolo' },
    ADULTO:        { specie: 'umano', eta: 'adulto'  }
  };
  const Foods = { BAMBOO: 'bamboo', PASTA: 'pasta', PIZZA: 'pizza', GELATO: 'gelato' };
  function allowedFoodsFor(character){
    if (character.specie === 'panda') return new Set([Foods.BAMBOO]);
    if (character.specie === 'umano' && character.eta === 'piccolo') return new Set([Foods.PASTA]);
    if (character.specie === 'umano' && character.eta === 'adulto') return new Set([Foods.PIZZA]);
    return new Set();
  }
  function poopGain(character, food){
    const allowed = allowedFoodsFor(character);
    if (allowed.has(food)) return 0.18;
    if (food === Foods.GELATO) return 0.06;
    return 0.00;
  }
  function defaultRng(){ return { int(min, max){ return Math.floor(Math.random()*(max-min+1)) + min; } }; }
  function randomPointAvoiding(center, minDist, bounds, rng = defaultRng()){
    const maxTry = 50;
    for (let i=0;i<maxTry;i++){
      const x = rng.int(bounds.xMin, bounds.xMax);
      const y = rng.int(bounds.yMin, bounds.yMax);
      const dx = x - center.x, dy = y - center.y;
      if (Math.hypot(dx,dy) >= minDist) return { x, y };
    }
    return { x: rng.int(bounds.xMin, bounds.xMax), y: rng.int(bounds.yMin, bounds.yMax) };
  }
  function isInVisionCone(observer, dirAngle, fovRad, range, target){
    const dx = target.x - observer.x, dy = target.y - observer.y;
    const dist = Math.hypot(dx, dy); if (dist > range) return false;
    const ang = Math.atan2(dy, dx);
    let diff = ang - dirAngle; // normalizza a [-pi, pi]
    diff = Math.atan2(Math.sin(diff), Math.cos(diff));
    return Math.abs(diff) <= fovRad/2;
  }
  const GameState = {
    selected: { specie: 'panda', eta: 'piccolo', genere: 'm' },
    poopMeter: 0,
    hasNarwhal: false,
    hasSiren: false,
    hasTornado: false,
    transitioning: false
  };
  function resetForNewRun(){
    GameState.poopMeter = 0;
    GameState.hasNarwhal = false;
    GameState.hasSiren = false;
    GameState.hasTornado = false;
    GameState.transitioning = false;
  }
  function labelForFood(foodType){
    switch(foodType){
      case Foods.BAMBOO: return 'üéã Bamboo';
      case Foods.PASTA:  return 'üçù Pasta';
      case Foods.PIZZA:  return 'üçï Pizza';
      case Foods.GELATO: return 'üç¶ Gelato';
      default:           return 'Cibo';
    }
  }
  function colorForFood(foodType){
    switch(foodType){
      case Foods.BAMBOO: return '#1f7a1f';
      case Foods.PASTA:  return '#7a5d1f';
      case Foods.PIZZA:  return '#a83232';
      case Foods.GELATO: return '#7a1f6a';
      default:           return '#333333';
    }
  }

  // =====================================
  // SFX (audio WebAudio minimalista)
  // =====================================
  let _audioCtx = null;
  function ensureAudioContext(){ if (!_audioCtx) _audioCtx = new (window.AudioContext || window.webkitAudioContext)(); return _audioCtx; }
  function tone({ freq=440, dur=0.12, type='sine', vol=0.2 }){
    const ctx = ensureAudioContext();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = type; osc.frequency.value = freq;
    osc.connect(gain); gain.connect(ctx.destination);
    gain.gain.setValueAtTime(vol, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + dur);
    osc.start(); osc.stop(ctx.currentTime + dur);
  }
  const SFX = {
    play: (f,d,t,v)=> tone({ freq:f, dur:d, type:t, vol:v }),
    eat(){ this.play(520,0.08,'triangle',0.22); this.play(660,0.06,'sine',0.18); },
    wrong(){ this.play(220,0.10,'sawtooth',0.18); },
    drop(){ this.play(180,0.14,'square',0.22); },
    narwhal(){ this.play(400,0.10,'sine',0.2); this.play(300,0.20,'triangle',0.15); },
    siren(){ this.play(900,0.08,'square',0.2); this.play(700,0.12,'square',0.2); },
    tornado(){ this.play(120,0.3,'sawtooth',0.2); },
    win(){ [523,659,783].forEach((f,i)=>setTimeout(()=>this.play(f,0.12,'sine',0.22), i*120)); },
    lose(){ [196,185,174].forEach((f,i)=>setTimeout(()=>this.play(f,0.12,'triangle',0.22), i*120)); },
    button(){ this.play(540,0.08,'sine',0.22); }
  };

  // =====================================
  // UI
  // =====================================
  function drawProgressBar(graphics, x, y, w, h, progress){
    graphics.lineStyle(2, 0x222222, 1);
    graphics.strokeRoundedRect(x, y, w, h, 8);
    graphics.fillStyle(0x333333, 1);
    graphics.fillRoundedRect(x, y, w, h, 8);
    const innerPad = 4, iw = (w - innerPad*2) * Math.max(0, Math.min(1, progress));
    graphics.fillStyle(0x9b5a1a, 1);
    graphics.fillRoundedRect(x + innerPad, y + innerPad, iw, h - innerPad*2, 6);
  }
  function makeBamboo(scene, x, baseY, totalH){
    const c = scene.add.container(x, baseY);
    const g = scene.add.graphics(); c.add(g);
    const stemW = 16; const segments = Math.max(3, Math.floor(totalH/36));
    let y = 0;
    for (let i=0;i<segments;i++){
      g.fillStyle(0x2e7d32,1); g.fillRoundedRect(-stemW/2, -y-36, stemW, 36, 6);
      g.lineStyle(3,0x1b5e20,1); g.strokeLineShape(new Phaser.Geom.Line(-stemW/2, -y-18, stemW/2, -y-18));
      const leaf = (lx,ly,ang,sz=12)=>{ g.fillStyle(0x66bb6a,1); const ax=Math.cos(ang), ay=Math.sin(ang); g.fillTriangle(lx,ly, lx-ax*sz, ly-ay*sz, lx-ay*sz*0.6, ly+ax*sz*0.6); };
      if (i%2===0) leaf(stemW/2, -y-24, 0.2); else leaf(-stemW/2, -y-10, Math.PI-0.2);
      y += 36;
    }
    c.setSize(stemW, totalH);
    scene.tweens.add({ targets:c, angle:2, yoyo:true, repeat:-1, duration:2200, ease:'Sine.easeInOut' });
    return c;
  }

  // =====================================
  // TEXTURES
  // =====================================
  function drawBow(g, cx, cy, col=0xff3da7){ g.fillStyle(col,1); g.fillEllipse(cx-6,cy,8,10); g.fillEllipse(cx+6,cy,8,10); g.fillCircle(cx,cy,3); }
  function drawCap(g, cx, cy, col=0x1f4d7a){ g.fillStyle(col,1); g.fillEllipse(cx,cy,26,12); g.fillRect(cx-13, cy, 26, 5); }
  function drawGlasses(g, cx, cy){ g.lineStyle(2,0x000000,1); g.strokeCircle(cx-8,cy,6); g.strokeCircle(cx+8,cy,6); g.lineBetween(cx-2,cy, cx+2,cy); }
  function createCharacterTexture(scene, key, sel){
    const g = scene.add.graphics();
    const isPanda = sel.specie === 'panda';
    const isBaby  = sel.eta === 'piccolo';
    const size = isBaby ? 22 : 28;
    const pad = 22;
    const cx = pad + size, cy = pad + size;
    if (isPanda) {
      g.fillStyle(0xffffff, 1); g.fillCircle(cx, cy, size);
      g.fillStyle(0x000000, 1);
      g.fillCircle(cx-12, cy-18, isBaby?6:7); g.fillCircle(cx+12, cy-18, isBaby?6:7);
      g.fillEllipse(cx-7, cy-2, 10, 14); g.fillEllipse(cx+7, cy-2, 10, 14);
      g.fillStyle(0xffffff, 1); g.fillCircle(cx-7, cy-2, 3); g.fillCircle(cx+7, cy-2, 3);
      g.fillStyle(0x000000, 1); g.fillCircle(cx, cy+5, 3);
      if (isBaby) { g.fillStyle(0xffa3a3,0.8); g.fillCircle(cx-12, cy+10, 3); g.fillCircle(cx+12, cy+10, 3); }
      else { if (sel.genere==='m'){ g.fillStyle(0xa00000,1); g.fillTriangle(cx, cy+18, cx-6, cy+28, cx+6, cy+28); } else { g.fillStyle(0xffe066,1); g.fillCircle(cx, cy+26, 4); } }
      if (sel.genere==='f') drawBow(g, cx-14, cy-26, 0xff3da7); else drawCap(g, cx, cy-28, 0x1f4d7a);
    } else {
      const skin = 0xffe0bd; g.fillStyle(skin, 1); g.fillCircle(cx, cy, size);
      const hairCol = 0x3b2e2a;
      if (isBaby) { g.fillStyle(hairCol, 1); g.fillEllipse(cx, cy-10, size*1.6, size*0.8); }
      else { g.fillStyle(hairCol, 1); if (sel.genere==='f') g.fillEllipse(cx, cy-6, size*1.8, size*1.6); else g.fillEllipse(cx, cy-8, size*1.8, size*1.0); }
      g.fillStyle(0x000000, 1); g.fillCircle(cx-7, cy-2, 3); g.fillCircle(cx+7, cy-2, 3); g.lineStyle(2, 0x000000, 1); g.strokeCircle(cx, cy+6, 6);
      if (sel.genere==='f') drawBow(g, cx-14, cy-26, 0xff3da7); else drawCap(g, cx, cy-28, 0x1f4d7a);
      if (!isBaby && sel.genere==='m') drawGlasses(g, cx, cy-2);
    }
    const w = (size+pad)*2, h = (size+pad)*2; g.generateTexture(key, w, h); g.destroy();
  }
  function createSwimmerTexture(scene, key, tint=0x00a3c4){
    const g = scene.add.graphics(); const pad=10; const r=12, cx=pad+r, cy=pad+r;
    g.fillStyle(0xffe0bd,1); g.fillCircle(cx, cy, r);
    g.fillStyle(tint,1); g.fillEllipse(cx, cy-6, r*1.8, r*1.0);
    g.lineStyle(2,0x000000,1); g.strokeRect(cx-8, cy-2, 16, 4);
    g.fillStyle(0xc0dff4,1); g.fillEllipse(cx, cy+16, r*1.2, r*0.8);
    g.generateTexture(key, pad*2+r*2, pad*2+r*2+16); g.destroy();
  }
  function createLifeguardTexture(scene, key){
    const g = scene.add.graphics(); const pad=10; const r=14, cx=pad+r, cy=pad+r;
    g.fillStyle(0xffe0bd,1); g.fillCircle(cx, cy, r);
    g.fillStyle(0xc62828,1); g.fillEllipse(cx, cy-8, r*1.8, r*1.0); g.fillRect(cx-12, cy-8, 24, 5);
    g.fillStyle(0x808080,1); g.fillRect(cx-2, cy+6, 4, 6);
    g.fillStyle(0xffffff,1); g.fillEllipse(cx, cy+18, r*1.4, r*1.0);
    g.fillStyle(0xc62828,1); g.fillRect(cx-2, cy+14, 4, 8); g.fillRect(cx-6, cy+16, 12, 4);
    g.generateTexture(key, pad*2+r*2, pad*2+r*2+18); g.destroy();
  }

  // =====================================
  // LIMBS
  // =====================================
  function makeLimbs(scene, color=0x000000){
    const parts = ['LA','RA','LL','RL'].reduce((acc,k)=>{ acc[k]=scene.add.graphics(); return acc; },{});
    const draw = (g,x,y,rot)=>{ g.clear(); g.fillStyle(color,1); g.save(); g.translateCanvas(x,y); g.rotateCanvas(rot); g.fillRoundedRect(-2,-8,4,16,2); g.restore(); };
    return { parts, draw, setVisible(v){ Object.values(parts).forEach(p=>p.setVisible(v)); }, destroy(){ Object.values(parts).forEach(p=>p.destroy()); } };
  }
  function updateLimbs(limbs, px, py, moving, t){
    const amp = moving? 0.8 : 0.2; const speed = moving? 10 : 2; const s = Math.sin(t*speed);
    limbs.draw(limbs.parts.LA, px-12, py+6,  s*amp);
    limbs.draw(limbs.parts.RA, px+12, py+6, -s*amp);
    limbs.draw(limbs.parts.LL, px-8,  py+20, -s*amp);
    limbs.draw(limbs.parts.RL, px+8,  py+20,  s*amp);
  }

  // =====================================
  // SCENES
  // =====================================
  class MenuScene extends Phaser.Scene {
    constructor(){ super('MenuScene'); }
    create(){
      resetForNewRun();
      const { width, height } = this.scale;
      const bg = this.add.graphics();
      bg.fillStyle(0x0b3d91,1); bg.fillRect(0,0,width,height*0.35);
      bg.fillStyle(0x1976d2,1); bg.fillRect(0,height*0.35,width,height*0.25);
      bg.fillStyle(0xf4e2b5,1); bg.fillRect(0,height*0.60,width,height*0.40);
      makeBamboo(this, 54, height-20, height*0.75);
      makeBamboo(this, width-54, height-20, height*0.68);
      const title = this.add.text(width/2, 60, 'Poo Poo Panda', { fontFamily: FONT, fontSize: 54, color:'#ffffff' }).setOrigin(0.5);
      title.setShadow(3,3,'#000000',6,true,true);
      const mascotKey = 'mascot_panda';
      if (!this.textures.exists(mascotKey)) createCharacterTexture(this, mascotKey, { specie:'panda', eta:'adulto', genere:'f' });
      this.add.image(width/2 + 240, 115, mascotKey).setScale(1.6);
      const panelW = Math.min(720, width-60), panelH = 300;
      const panel = this.add.graphics();
      panel.fillStyle(0x1b2838, 0.92); panel.fillRoundedRect((width-panelW)/2, 150, panelW, panelH, 20);
      panel.lineStyle(2, 0x90caf9, 1); panel.strokeRoundedRect((width-panelW)/2, 150, panelW, panelH, 20);
      this.add.text(width/2, 165, 'Scegli il personaggio e il genere', { fontFamily: FONT, fontSize: 22, color:'#e3f2fd' }).setOrigin(0.5);
      const options = [
        { label: 'Panda piccolo', value: Characters.PANDA_PICCOLO, preview:{specie:'panda',eta:'piccolo',genere:'m'} },
        { label: 'Panda adulto',  value: Characters.PANDA_ADULTO,  preview:{specie:'panda',eta:'adulto',genere:'m'} },
        { label: 'Bambino umano', value: Characters.BAMBINO,       preview:{specie:'umano',eta:'piccolo',genere:'m'} },
        { label: 'Adulto umano',  value: Characters.ADULTO,        preview:{specie:'umano',eta:'adulto',genere:'m'} },
      ];
      const cards = []; let selectedIdx = 0; const startX = (width-panelW)/2 + 28; const startY = 205; const gapX = (panelW-56)/4; const cardW = gapX-14; const cardH = 110;
      const makeCard = (i)=>{
        const x = startX + i*gapX; const y = startY; const c = this.add.container(x, y);
        const g = this.add.graphics(); c.add(g);
        g.fillStyle(0x102131,1); g.fillRoundedRect(0,0,cardW,cardH,16); g.lineStyle(2,0x5dade2,1); g.strokeRoundedRect(0,0,cardW,cardH,16);
        const opt = options[i];
        const k = `menu_prev_${i}`; if (!this.textures.exists(k)) createCharacterTexture(this, k, opt.preview);
        const img = this.add.image(cardW/2, 46, k).setScale(0.9); c.add(img);
        const txt = this.add.text(cardW/2, cardH-20, opt.label, { fontFamily: FONT, fontSize: 16, color:'#e3f2fd' }).setOrigin(0.5); txt.setShadow(2,2,'#000',4,true,true); c.add(txt);
        c.setSize(cardW, cardH);
        c.setInteractive(new Phaser.Geom.Rectangle(0,0,cardW,cardH), Phaser.Geom.Rectangle.Contains)
          .on('pointerover', ()=>{ g.clear(); g.fillStyle(0x0f2a3f,1); g.fillRoundedRect(0,0,cardW,cardH,16); g.lineStyle(2,0x90caf9,1); g.strokeRoundedRect(0,0,cardW,cardH,16); })
          .on('pointerout', ()=>{ if (selectedIdx!==i){ g.clear(); g.fillStyle(0x102131,1); g.fillRoundedRect(0,0,cardW,cardH,16); g.lineStyle(2,0x5dade2,1); g.strokeRoundedRect(0,0,cardW,cardH,16);} })
          .on('pointerdown', ()=>{ SFX.button(); selectedIdx=i; refreshCards(); });
        cards.push({c,g,img,txt});
      };
      for (let i=0;i<options.length;i++) makeCard(i);
      const refreshCards = ()=>{
        cards.forEach((card, i)=>{
          card.g.clear();
          if (i===selectedIdx){ card.g.fillStyle(0x143d5b,1); card.g.fillRoundedRect(0,0,cardW,cardH,16); card.g.lineStyle(3,0x64b5f6,1); card.g.strokeRoundedRect(0,0,cardW,cardH,16); }
          else { card.g.fillStyle(0x102131,1); card.g.fillRoundedRect(0,0,cardW,cardH,16); card.g.lineStyle(2,0x5dade2,1); card.g.strokeRoundedRect(0,0,cardW,cardH,16); }
        });
      };
      refreshCards();
      let gender = 'm';
      const pillW = 220, pillH = 40; const pillX = width/2 - pillW/2, pillY = 325;
      const pill = this.add.graphics();
      const drawPill = ()=>{ pill.clear(); pill.fillStyle(0x102131,1); pill.fillRoundedRect(pillX, pillY, pillW, pillH, 20); pill.lineStyle(2,0x90caf9,1); pill.strokeRoundedRect(pillX, pillY, pillW, pillH, 20); const knobX = gender==='m'? pillX+pillW*0.25 : pillX+pillW*0.75; pill.fillStyle(0x64b5f6,1); pill.fillRoundedRect(knobX-44, pillY+6, 88, pillH-12, 16); };
      drawPill();
      this.add.text(pillX+pillW*0.25, pillY+pillH/2, '‚ôÇÔ∏è Maschio', { fontFamily: FONT, fontSize:16, color:'#e3f2fd' }).setOrigin(0.5);
      this.add.text(pillX+pillW*0.75, pillY+pillH/2, '‚ôÄÔ∏è Femmina', { fontFamily: FONT, fontSize:16, color:'#e3f2fd' }).setOrigin(0.5);
      this.add.zone(pillX, pillY, pillW, pillH).setOrigin(0).setInteractive().on('pointerdown', ()=>{ SFX.button(); gender = gender==='m' ? 'f' : 'm'; drawPill(); });
      this.add.text(width/2, height - 110, 'Consiglio: Panda‚ÜíBamboo | Bimbo‚ÜíPasta | Adulto‚ÜíPizza', { fontFamily: FONT, fontSize: 16, color: '#0b0b0b', backgroundColor:'#e3f2fd', padding:{left:10,right:10,top:4,bottom:4} }).setOrigin(0.5);
      const start = this.add.text(width/2, height - 60, 'Inizia ‚ñ∂', { fontFamily: FONT, fontSize: 30, color: '#ffffff', backgroundColor:'#43a047', padding:{ left:18, right:18, top:8, bottom:8 } }).setOrigin(0.5);
      start.setShadow(3,3,'#1b5e20',6,true,true);
      start.setInteractive({ useHandCursor: true })
        .on('pointerover', ()=> start.setStyle({ backgroundColor:'#2e7d32' }))
        .on('pointerout',  ()=> start.setStyle({ backgroundColor:'#43a047' }))
        .on('pointerdown', ()=>{
          if (GameState.transitioning) return; GameState.transitioning = true; SFX.button();
          const chosen = options[selectedIdx].value; GameState.selected = { specie: chosen.specie, eta: chosen.eta, genere: gender };
          this.scene.start('LandScene');
        });
    }
  }

  class LandScene extends Phaser.Scene {
    constructor(){ super('LandScene'); }
    create(){
      GameState.transitioning = false; const { width, height } = this.scale;
      this.cameras.main.setBackgroundColor('#87CEEB');
      this.bg = this.add.graphics(); this.bg.fillStyle(0xF4E2B5, 1); this.bg.fillRect(0, height*0.35, width, height*0.65);
      this.add.text(10, 10, `Personaggio: ${GameState.selected.specie} ${GameState.selected.eta} (${GameState.selected.genere==='m'?'M':'F'})`, { fontFamily: FONT, fontSize: 16, color: '#000' });
      const key = `char_${GameState.selected.specie}_${GameState.selected.eta}_${GameState.selected.genere}`; createCharacterTexture(this, key, GameState.selected);
      this.player = this.add.image(width/2, height*0.6, key); this.physics.add.existing(this.player); this.player.body.setCircle(this.player.displayWidth/2); this.player.body.setCollideWorldBounds(true);
      this.playerLimbs = makeLimbs(this, 0x000000);
      this.foods = this.physics.add.group(); this.bonuses = this.physics.add.group();
      this.sceneStartMs = this.time.now; this.GRACE_MS = 1000; this.EAT_COOLDOWN_MS = 180; this.lastEatMs = 0;
      this.spawnFoodWave(); this.spawnBonusNarwhal();
      this.ui = this.add.graphics(); this.uiText = this.add.text(width - 200, 12, 'Pup√π: 0%', { fontFamily: FONT, fontSize: 16, color: '#111' });
      this.promptText = this.add.text(width/2, 48, '', { fontFamily: FONT, fontSize: 18, color: '#111' }).setOrigin(0.5);
      this.seaBtn = this.add.text(width - 190, 42, 'Vai al Mare ‚ñ∂', { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#0a7d33', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({ useHandCursor:true }).on('pointerdown', () => this.tryGoSea()); this.seaBtn.visible = false;
      this.restartBtn = this.add.text(16, height - 44, '‚ü≤ Ricomincia (R)', { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#444', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({ useHandCursor:true }).on('pointerdown', () => this.restartLand());
      this.tut = this.add.text(width/2, height-90, 'Mangia i cibi giusti, riempi fino al 60% e vai al mare!', { fontFamily:FONT, fontSize: 16, color:'#001', backgroundColor:'#fff', padding:{left:8,right:8,top:6,bottom:6} }).setOrigin(0.5);
      this.time.delayedCall(4000, ()=> this.tut.setVisible(false));
      this.cursors = this.input.keyboard.createCursorKeys(); this.wasd = this.input.keyboard.addKeys('W,A,S,D'); this.keyM = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.M); this.keyR = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
      this.pointerTarget = null; this.pointerMarker = this.add.circle(0, 0, 8, 0x000000, 0.3).setVisible(false);
      const setPointerTarget = (p)=>{ this.pointerTarget = { x: p.worldX, y: p.worldY }; this.pointerMarker.setPosition(this.pointerTarget.x, this.pointerTarget.y).setVisible(true); };
      this.input.on('pointerdown', setPointerTarget); this.input.on('pointermove', (p)=>{ if (p.isDown) setPointerTarget(p); });
      this.physics.add.overlap(this.player, this.foods, this.onEatFood, null, this); this.physics.add.overlap(this.player, this.bonuses, this.onTakeBonus, null, this);
    }
    restartLand(){ resetForNewRun(); this.scene.start('LandScene'); }
    getSafeSpawn(minDist=120){ const { width, height } = this.scale; const b = { xMin: 40, xMax: width-40, yMin: height*0.4, yMax: height-40 }; return randomPointAvoiding({x:this.player.x,y:this.player.y}, minDist, b); }
    spawnFoodWave(){ const types=[Foods.BAMBOO,Foods.PASTA,Foods.PIZZA,Foods.GELATO]; for(let i=0;i<8;i++){ const t=Phaser.Utils.Array.GetRandom(types); const p=this.getSafeSpawn(140); this.spawnFoodAt(p.x,p.y,t);} }
    spawnFoodAt(x,y,t){ const food=this.add.text(x,y,labelForFood(t),{ fontFamily:FONT, fontSize:18, color:colorForFood(t)}).setOrigin(0.5); this.physics.add.existing(food); food.body.setCircle(24).setOffset(-24,-24); food.body.setImmovable(true); food.foodType=t; this.foods.add(food);}  
    spawnSingleFood(){ const types=[Foods.BAMBOO,Foods.PASTA,Foods.PIZZA,Foods.GELATO]; const t=Phaser.Utils.Array.GetRandom(types); const p=this.getSafeSpawn(120); this.spawnFoodAt(p.x,p.y,t); }
    spawnBonusNarwhal(){ if (GameState.hasNarwhal) return; const p=this.getSafeSpawn(160); const b=this.add.text(p.x,p.y,'üêã Narvalo',{ fontFamily:FONT, fontSize:18, color:'#551a8b'}).setOrigin(0.5); this.physics.add.existing(b); b.body.setCircle(26).setOffset(-26,-26); b.body.setImmovable(true); b.bonusType='narwhal'; this.bonuses.add(b);}  
    onEatFood(player, food){ const now=this.time.now; if (now-this.sceneStartMs< this.GRACE_MS) return; if (now-this.lastEatMs<this.EAT_COOLDOWN_MS) return; this.lastEatMs=now; const gain=poopGain(GameState.selected, food.foodType); if (gain===0){ this.tweens.add({targets:food, angle:10, yoyo:true, duration:120, onComplete:()=>food.destroy()}); SFX.wrong(); } else { GameState.poopMeter=Math.max(0, Math.min(1, GameState.poopMeter+gain)); this.tweens.add({targets:food, scale:1.3, yoyo:true, duration:120, onComplete:()=>food.destroy()}); SFX.eat(); } this.time.delayedCall(300, ()=>this.spawnSingleFood()); }
    onTakeBonus(player, bonus){ if (bonus.bonusType==='narwhal'){ GameState.hasNarwhal=true; this.tweens.add({ targets:bonus, angle:360, scale:1.5, duration:240, onComplete:()=>bonus.destroy() }); SFX.narwhal(); } }
    tryGoSea(){ if (GameState.poopMeter<0.6 || GameState.transitioning) return; GameState.transitioning=true; this.scene.start('SeaScene'); }
    update(time, delta){ const speed=160; const body=this.player.body; body.setVelocity(0);
      if (this.cursors.left.isDown||this.wasd.A.isDown) body.setVelocityX(-speed); else if (this.cursors.right.isDown||this.wasd.D.isDown) body.setVelocityX(speed);
      if (this.cursors.up.isDown||this.wasd.W.isDown) body.setVelocityY(-speed); else if (this.cursors.down.isDown||this.wasd.S.isDown) body.setVelocityY(speed);
      if (this.pointerTarget){ const dx=this.pointerTarget.x-this.player.x, dy=this.pointerTarget.y-this.player.y, dist=Math.hypot(dx,dy); if (dist>6) body.setVelocity((dx/dist)*speed, (dy/dist)*speed); else { this.pointerTarget=null; this.pointerMarker.setVisible(false);} }
      this.ui.clear(); drawProgressBar(this.ui, 16, 12, 220, 22, GameState.poopMeter); this.uiText.setText(`Pup√π: ${Math.round(GameState.poopMeter*100)}%`);
      const canSea = GameState.poopMeter>=0.6; this.promptText.setText(canSea? 'Premi M o tocca ‚ñ∂ Vai al Mare':'Mangia i cibi adatti per riempire la barra'); this.seaBtn.visible=canSea;
      if (Phaser.Input.Keyboard.JustDown(this.keyM)) this.tryGoSea(); if (Phaser.Input.Keyboard.JustDown(this.keyR)) this.restartLand();
      if (GameState.poopMeter>=1.0) { SFX.lose(); this.scene.start('LoseScene'); }
      const moving = body.velocity.length() > 5; updateLimbs(this.playerLimbs, this.player.x, this.player.y, moving, time/1000);
    }
    shutdown(){ this.playerLimbs?.destroy?.(); }
  }

  class SeaScene extends Phaser.Scene {
    constructor(){ super('SeaScene'); }
    create(){
      const { width, height } = this.scale; GameState.transitioning=false;
      this.cameras.main.setBackgroundColor('#3CB7E7');
      const key = `char_${GameState.selected.specie}_${GameState.selected.eta}_${GameState.selected.genere}`; createCharacterTexture(this, key, GameState.selected);
      this.player = this.add.image(width*0.5, height*0.7, key); this.physics.add.existing(this.player); this.player.body.setCircle(this.player.displayWidth/2); this.player.body.setCollideWorldBounds(true);
      this.playerLimbs = makeLimbs(this, 0x001122);
      this.currentAngle = Phaser.Math.FloatBetween(-Math.PI, Math.PI); this.currentSpeed = 38; this.currentFrozen = false; this.currentArrow = this.add.graphics();
      this.cloud = this.add.text(width/2, 36, '‚òÅÔ∏è‚òÅÔ∏è‚òÅÔ∏è', { fontFamily:FONT, fontSize: 40, color:'#ffffff' }).setOrigin(0.5).setVisible(false);
      this.tweens.add({ targets:this.cloud, scale:1.15, yoyo:true, repeat:-1, duration:450, ease:'Sine.easeInOut' });
      this.scheduleNextCurrentChange();
      this.poops = this.add.group(); this.narwhals = []; this.swimmers = [];
      const lifekey = 'lifeguard_tex'; if (!this.textures.exists(lifekey)) createLifeguardTexture(this, lifekey); this.lifeguardSprite = this.add.image(width/2, 60, lifekey);
      this.lifeguard = { x: this.lifeguardSprite.x, y: this.lifeguardSprite.y, dir: Math.PI/2, sweepMin: Math.PI/2 - Phaser.Math.DegToRad(35), sweepMax: Math.PI/2 + Phaser.Math.DegToRad(35), speed: Phaser.Math.DegToRad(20), fov: Phaser.Math.DegToRad(50), range: 360, distractedUntil: 0 };
      this.visionGfx = this.add.graphics();
      const capColors = [0x00a3c4,0xffa726,0x8e24aa,0x2e7d32,0xd32f2f,0x455a64];
      for (let i=0; i<6; i++) this.spawnSwimmer(Phaser.Utils.Array.GetRandom(capColors));
      this.seaBonuses = this.physics.add.group();
      if (!GameState.hasNarwhal) this.spawnSeaBonus('narwhal');
      if (!GameState.hasSiren) this.spawnSeaBonus('siren');
      if (!GameState.hasTornado) this.spawnSeaBonus('tornado');
      this.tornado = null; this.tornadoGfx = this.add.graphics();
      this.ui = this.add.graphics();
      this.uiText = this.add.text(16, 12, '', { fontFamily:FONT, fontSize: 16, color:'#001' });
      this.statusText = this.add.text(width/2, 12, '', { fontFamily:FONT, fontSize: 16, color:'#001' }).setOrigin(0.5);
      this.dropBtn   = this.add.text(16, height - 44, 'Sgancia üí© (SPAZIO)', { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#a34a00', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ this.dropPoop(); SFX.drop(); });
      this.narBtn    = this.add.text(260, height - 44, 'Narvalo üêã (N)',     { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#6a1b9a', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ this.triggerNarwhal(); SFX.narwhal(); });
      this.sirenBtn  = this.add.text(440, height - 44, 'Sirena ‚ú® (S)',      { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#2947a3', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ this.triggerSiren(); SFX.siren(); });
      this.tornBtn   = this.add.text(600, height - 44, 'Tornado üåÄ (T)',     { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#00695c', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ this.triggerTornado(); SFX.tornado(); });
      this.menuBtn   = this.add.text(width - 280, height - 44, '‚¨Ö Menu',     { fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#444', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ resetForNewRun(); this.scene.start('MenuScene'); });
      this.restartBtn= this.add.text(width - 140, height - 44, '‚ü≤ Ricomincia',{ fontFamily:FONT, fontSize: 18, color:'#ffffff', backgroundColor:'#444', padding:{left:10,right:10,top:6,bottom:6} }).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ resetForNewRun(); this.scene.start('LandScene'); });
      this.tut = this.add.text(width/2, height-90, 'Usa corrente & bonus (N/S/T). Cono del bagnino = rosso. Evita che üí© entri nei coni per 60s!', { fontFamily:FONT, fontSize: 16, color:'#001', backgroundColor:'#fff', padding:{left:8,right:8,top:6,bottom:6} }).setOrigin(0.5);
      this.time.delayedCall(6000, ()=> this.tut.setVisible(false));
      this.cursors = this.input.keyboard.createCursorKeys(); this.wasd = this.input.keyboard.addKeys('W,A,S,D'); this.keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE); this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S); this.keyN = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.N); this.keyT = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.T);
      this.pointerTarget = null; this.pointerMarker = this.add.circle(0,0,8,0x000000,0.3).setVisible(false);
      const setPointerTarget = (p)=>{ this.pointerTarget = { x: p.worldX, y: p.worldY }; this.pointerMarker.setPosition(this.pointerTarget.x, this.pointerTarget.y).setVisible(true); };
      this.input.on('pointerdown', setPointerTarget); this.input.on('pointermove', (p)=>{ if (p.isDown) setPointerTarget(p); });
      this.physics.add.overlap(this.player, this.seaBonuses, (player, b)=>{ if (b.type==='narwhal'){ GameState.hasNarwhal = true; SFX.narwhal(); } if (b.type==='siren'){ GameState.hasSiren = true; SFX.siren(); } if (b.type==='tornado'){ GameState.hasTornado = true; SFX.tornado(); } this.tweens.add({ targets:b, angle:360, scale:1.5, duration:240, onComplete:()=>b.destroy() }); });
    }
    scheduleNextCurrentChange(){ const nextMs = Phaser.Math.Between(12000, 20000); this._cloudTimer1 = this.time.delayedCall(nextMs - 2500, ()=>{ if (!this.currentFrozen) this.cloud.setVisible(true); }); this._cloudTimer2 = this.time.delayedCall(nextMs, ()=>{ if (this.currentFrozen) { this.cloud.setVisible(false); this.scheduleNextCurrentChange(); return; } this.currentAngle = Phaser.Math.FloatBetween(-Math.PI, Math.PI); this.cloud.setVisible(false); this.scheduleNextCurrentChange(); }); }
    spawnSeaBonus(type){ const { width, height } = this.scale; const x = Phaser.Math.Between(40, width-40), y = Phaser.Math.Between(height*0.35, height-40); const label = type==='narwhal' ? 'üêã Narvalo' : type==='siren' ? 'üßú‚Äç‚ôÄÔ∏è Sirena' : 'üåÄ Tornado'; const color = type==='narwhal' ? '#6a1b9a' : type==='siren' ? '#0a4abf' : '#00695c'; const b = this.add.text(x, y, label, { fontFamily:FONT, fontSize: 18, color: color }).setOrigin(0.5); this.physics.add.existing(b); b.body.setCircle(26).setOffset(-26,-26); b.body.setImmovable(true); b.type = type; this.seaBonuses.add(b); }
    spawnSwimmer(tint){ const { width, height } = this.scale; const x = Phaser.Math.Between(60, width-60), y = Phaser.Math.Between(height*0.35, height-80); const key = `swim_${tint}`; if (!this.textures.exists(key)) createSwimmerTexture(this, key, tint); const s = this.add.image(x,y,key); this.physics.add.existing(s); s.body.setCircle(s.displayWidth/2); s.body.setCollideWorldBounds(true); const limbs = makeLimbs(this, 0x223344); const data = { sprite:s, dir: Phaser.Math.FloatBetween(-Math.PI, Math.PI), speed: 40, fov: Phaser.Math.DegToRad(40), range: 140, changeAt: 0, limbs }; this.swimmers.push(data); }
    nearestPoop(from){ let best=null, bestD=1e9; this.poops.getChildren().forEach(p=>{ if(!p.active) return; const d=Phaser.Math.Distance.Between(from.x,from.y,p.x,p.y); if(d<bestD){ best=p; bestD=d; } }); return best; }
    triggerNarwhal(){ if (!GameState.hasNarwhal) return; const n = this.add.text(this.player.x, this.player.y, 'üêã', { fontFamily:FONT, fontSize: 26 }); n._speed = 90; n._target = this.nearestPoop(n); this.narwhals.push(n); GameState.hasNarwhal = false; SFX.narwhal(); }
    triggerSiren(){ if (!GameState.hasSiren) return; GameState.hasSiren = false; const siren = this.add.text(this.player.x, this.player.y, 'üßú‚Äç‚ôÄÔ∏è', { fontFamily:FONT, fontSize: 26 }); this.lifeguard.distractedUntil = this.time.now + 15000; this.time.delayedCall(15000, ()=>{ siren.destroy(); }); SFX.siren(); }
    triggerTornado(){ if (!GameState.hasTornado) return; GameState.hasTornado = false; this.tornado = { x: this.player.x, y: this.player.y, until: this.time.now + 15000 }; SFX.tornado(); }
    dropPoop(){ if (GameState.poopMeter <= 0) return; const chunk = Math.min(GameState.poopMeter, 0.2); GameState.poopMeter = Math.max(0, Math.min(1, GameState.poopMeter - chunk)); const p = this.add.text(this.player.x, this.player.y, 'üí©', { fontFamily:FONT, fontSize: 20}); p._tDrop = this.time.now; p._ttlMs = 60000; p._label = this.add.text(p.x, p.y-18, '60', { fontFamily:FONT, fontSize: 12, color:'#001' }).setOrigin(0.5); this.poops.add(p); SFX.drop(); }
    update(time, delta){
      const dt = delta/1000; const speed=120; const body=this.player.body; body.setVelocity(0);
      if (this.cursors.left.isDown||this.wasd.A.isDown) body.setVelocityX(-speed); else if (this.cursors.right.isDown||this.wasd.D.isDown) body.setVelocityX(speed);
      if (this.cursors.up.isDown||this.wasd.W.isDown) body.setVelocityY(-speed); else if (this.cursors.down.isDown||this.wasd.S.isDown) body.setVelocityY(speed);
      if (this.pointerTarget){ const dx=this.pointerTarget.x-this.player.x, dy=this.pointerTarget.y-this.player.y, dist=Math.hypot(dx,dy); if (dist>6) body.setVelocity((dx/dist)*speed,(dy/dist)*speed); else { this.pointerTarget=null; this.pointerMarker.setVisible(false);} }
      const cx = Math.cos(this.currentAngle)*this.currentSpeed; const cy = Math.sin(this.currentAngle)*this.currentSpeed;
      body.velocity.x += cx; body.velocity.y += cy;
      this.currentArrow.clear(); this.currentArrow.fillStyle(0x002244, 0.15); this.currentArrow.fillCircle(40, 40, 18); this.currentArrow.lineStyle(5, 0xfff176, 0.95);
      const ax=40, ay=40; const ex=ax + Math.cos(this.currentAngle)*32, ey=ay + Math.sin(this.currentAngle)*32; this.currentArrow.lineBetween(ax, ay, ex, ey);
      this.currentArrow.fillStyle(0xfff176, 1); this.currentArrow.fillTriangle(ex, ey, ex - Math.cos(this.currentAngle+0.5)*10, ey - Math.sin(this.currentAngle+0.5)*10, ex - Math.cos(this.currentAngle-0.5)*10, ey - Math.sin(this.currentAngle-0.5)*10);
      if (time >= this.lifeguard.distractedUntil){ this.lifeguard.dir += this.lifeguard.speed * dt; if (this.lifeguard.dir > this.lifeguard.sweepMax || this.lifeguard.dir < this.lifeguard.sweepMin){ this.lifeguard.speed *= -1; this.lifeguard.dir = Phaser.Math.Clamp(this.lifeguard.dir, this.lifeguard.sweepMin, this.lifeguard.sweepMax); } }
      for (const s of this.swimmers){ if (time > s.changeAt){ s.dir = Phaser.Math.FloatBetween(-Math.PI, Math.PI); s.changeAt = time + Phaser.Math.Between(1200, 2600); }
        let vx = Math.cos(s.dir)*s.speed + cx, vy = Math.sin(s.dir)*s.speed + cy;
        if (this.tornado && time < this.tornado.until){ const dx = this.tornado.x - s.sprite.x, dy = this.tornado.y - s.sprite.y; const d = Math.hypot(dx,dy)||1; const pull = 120; vx += (dx/d)*pull; vy += (dy/d)*pull; }
        s.sprite.body.setVelocity(vx, vy);
        const moving = Math.hypot(vx,vy)>5; updateLimbs(s.limbs, s.sprite.x, s.sprite.y, moving, time/1000);
      }
      if (this.tornado && time >= this.tornado.until){ this.tornado=null; this.tornadoGfx.clear(); }
      this.tornadoGfx.clear(); if (this.tornado){ this.tornadoGfx.lineStyle(3, 0x00695c, 0.9); this.tornadoGfx.strokeCircle(this.tornado.x, this.tornado.y, 24); this.tornadoGfx.strokeCircle(this.tornado.x, this.tornado.y, 12); this.tornadoGfx.strokeCircle(this.tornado.x, this.tornado.y, 36); }
      for (const n of this.narwhals){ if (!n.active) continue; if (!n._target || !n._target.active) n._target = this.nearestPoop(n); if (n._target){ const dx = n._target.x - n.x, dy = n._target.y - n.y; const d = Math.hypot(dx,dy)||1; n.x += (dx/d)*n._speed*dt + cx*dt; n.y += (dy/d)*n._speed*dt + cy*dt; if (d<10 && n._target.active){ n._target._label?.destroy(); n._target.destroy(); n._target = this.nearestPoop(n); SFX.narwhal(); } } else { n.x += cx*dt; n.y += cy*dt; n._despawnAt = n._despawnAt || (time+2000); if (time>=n._despawnAt){ n.destroy(); } } }
      this.currentFrozen = this.poops.countActive(true) > 0; if (this.currentFrozen) this.cloud.setVisible(false);
      this.poops.getChildren().forEach(p=>{ p.x += cx*dt; p.y += cy*dt; p._label?.setPosition(p.x, p.y-18); const left = Math.max(0, Math.ceil((p._ttlMs - (time - p._tDrop))/1000)); p._label?.setText(left.toString()); if (left<=0 && p.active){ p._label?.destroy(); p.destroy(); } });
      this.visionGfx.clear(); this.drawCone(this.visionGfx, this.lifeguard.x, this.lifeguard.y, this.lifeguard.dir, this.lifeguard.fov, this.lifeguard.range, 0xff0000, 0.15);
      for (const s of this.swimmers){ this.drawCone(this.visionGfx, s.sprite.x, s.sprite.y, s.dir, s.fov, s.range, 0xff8800, 0.12); }
      if (this.isAnyPoopDetected()){ SFX.lose(); resetForNewRun(); this.scene.start('LoseScene'); return; }
      if (GameState.poopMeter <= 0 && this.poops.countActive(true) === 0){ SFX.win(); resetForNewRun(); this.scene.start('WinScene'); return; }
      const secPoop = Math.ceil(this.maxPoopRemainingSeconds(time));
      const status = [ GameState.hasNarwhal? 'Narvalo pronto' : 'Narvalo no', GameState.hasSiren? 'Sirena pronta' : 'Sirena no', GameState.hasTornado? 'Tornado pronto' : 'Tornado no' ];
      const distractLeft = Math.max(0, Math.ceil((this.lifeguard.distractedUntil - time)/1000));
      this.ui.clear(); drawProgressBar(this.ui, 16, 12, 220, 22, GameState.poopMeter);
      this.uiText.setText(`Pup√π: ${Math.round(GameState.poopMeter*100)}%  |  Cacchette: ${this.poops.countActive(true)}  |  TTL max: ${isFinite(secPoop)?secPoop:0}s`);
      this.statusText.setText(status.join('  ‚Ä¢  ') + (distractLeft>0?`  ‚Ä¢  Bagnino distratto: ${distractLeft}s`:''));
      if (Phaser.Input.Keyboard.JustDown(this.keySpace)) { this.dropPoop(); SFX.drop(); }
      if (Phaser.Input.Keyboard.JustDown(this.keyS)) { this.triggerSiren(); SFX.siren(); }
      if (Phaser.Input.Keyboard.JustDown(this.keyN)) { this.triggerNarwhal(); SFX.narwhal(); }
      if (Phaser.Input.Keyboard.JustDown(this.keyT)) { this.triggerTornado(); SFX.tornado(); }
      const moving = body.velocity.length() > 5; updateLimbs(this.playerLimbs, this.player.x, this.player.y, moving, time/1000);
    }
    drawCone(gfx, x, y, dir, fov, range, color, alpha){ gfx.fillStyle(color, alpha); const a1 = dir - fov/2, a2 = dir + fov/2; const p1 = { x: x + Math.cos(a1)*range, y: y + Math.sin(a1)*range }; const p2 = { x: x + Math.cos(a2)*range, y: y + Math.sin(a2)*range }; gfx.beginPath(); gfx.moveTo(x,y); gfx.lineTo(p1.x, p1.y); gfx.arc(x,y,range,a1,a2); gfx.lineTo(x,y); gfx.closePath(); gfx.fillPath(); }
    isAnyPoopDetected(){ const poos = this.poops.getChildren(); for (const p of poos){ if (!p.active) continue; if (isInVisionCone({x:this.lifeguard.x,y:this.lifeguard.y}, this.lifeguard.dir, this.lifeguard.fov, this.lifeguard.range, {x:p.x,y:p.y})) return true; for (const s of this.swimmers){ if (isInVisionCone({x:s.sprite.x,y:s.sprite.y}, s.dir, s.fov, s.range, {x:p.x,y:p.y})) return true; } } return false; }
    maxPoopRemainingSeconds(time){ let mx = 0; this.poops.getChildren().forEach(p=>{ if (p.active) mx = Math.max(mx, (p._ttlMs - (time - p._tDrop))/1000); }); return mx>0?mx:0; }
  }

  class LoseScene extends Phaser.Scene {
    constructor(){ super('LoseScene'); }
    create(){
      const { width, height } = this.scale;
      this.cameras.main.setBackgroundColor('#222');
      this.add.text(width/2, height/2 - 40, 'Ops! Sei stato scoperto! üö®', { fontFamily:FONT, fontSize: 26, color:'#ffffff' }).setOrigin(0.5);
      this.add.text(width/2, height/2 + 10, 'Riprova usando correnti e bonus.', { fontFamily:FONT, fontSize: 16, color:'#dddddd' }).setOrigin(0.5);
      this.add.text(width/2 - 130, height - 60, '‚¨Ö Menu', { fontFamily:FONT, fontSize:22, color:'#fff', backgroundColor:'#444', padding:{left:10,right:10,top:6,bottom:6} }).setOrigin(0.5).setInteractive({useHandCursor:true}).on('pointerdown', ()=>{ resetForNewRun(); this.scene.start('MenuScene'); });
      this.add.text(width/2 + 130, height - 60, '‚ü≤ Riprova', { fontFamily:FONT, fontSize:22, color:'#fff', backgroundColor:'#444', padding:{left:10,right:10,top:6,bottom:6} }).setOrigin(0.5).setInteractive({useHandCursor:true}).on('pointerdown', ()=>{ resetForNewRun(); this.scene.start('LandScene'); });
    }
  }

  class WinScene extends Phaser.Scene {
    constructor(){ super('WinScene'); }
    create(){
      const { width, height } = this.scale;
      this.cameras.main.setBackgroundColor('#1b5e20');
      this.add.text(width/2, height/2 - 40, 'Ce l\'hai fatta! ü§´üåä', { fontFamily:FONT, fontSize: 28, color:'#ffffff' }).setOrigin(0.5);
      this.add.text(width/2, height/2 + 10, 'Nessuno ha scoperto nulla. Bravo stratega!', { fontFamily:FONT, fontSize: 16, color:'#e8f5e9' }).setOrigin(0.5);
      this.add.text(width/2 - 130, height - 60, '‚¨Ö Menu', { fontFamily:FONT, fontSize:22, color:'#fff', backgroundColor:'#2e7d32', padding:{left:10,right:10,top:6,bottom:6} }).setOrigin(0.5).setInteractive({useHandCursor:true}).on('pointerdown', ()=>{ resetForNewRun(); this.scene.start('MenuScene'); });
      this.add.text(width/2 + 130, height - 60, '‚ü≤ Gioca ancora', { fontFamily:FONT, fontSize:22, color:'#fff', backgroundColor:'#2e7d32', padding:{left:10,right:10,top:6,bottom:6} }).setOrigin(0.5).setInteractive({useHandCursor:true}).on('pointerdown', ()=>{ resetForNewRun(); this.scene.start('LandScene'); });
    }
  }

  // =====================================
  // BOOT
  // =====================================
  function setupAudioUnlock(){
    const gate = document.getElementById('audio-gate');
    const btn  = document.getElementById('audio-btn');
    if (!gate || !btn) return;
    gate.style.display = 'flex';
    const unlock = () => {
      try { ensureAudioContext().resume(); } catch(_) {}
      gate.style.display = 'none';
      window.removeEventListener('pointerdown', unlock);
    };
    btn.addEventListener('click', unlock);
    window.addEventListener('pointerdown', unlock, { once:true });
  }

  function createGame(options={}){
    const parent = options.parent || 'game-container';
    setupAudioUnlock();
    const config = {
      type: Phaser.AUTO,
      width: 960,
      height: 540,
      backgroundColor: '#0d1117',
      parent,
      scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
      physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
      scene: [MenuScene, LandScene, SeaScene, LoseScene, WinScene]
    };
    return new Phaser.Game(config);
  }

  // Espone una mini-API globale per integrazione (es. Unity WebView)
  window.PooPooPanda = { createGame };

  // Avvio automatico se presente il container di default
  window.addEventListener('DOMContentLoaded', ()=>{
    const el = document.getElementById('game-container');
    if (el) window.PooPooPanda._game = createGame({ parent: 'game-container' });
  });
  </script>
</body>
</html>
