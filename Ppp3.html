<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8"/>
  <title>Poo Poo Panda ‚Äî single-file (sprite-sheet embedded + haptics)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
  <style>
    html,body{margin:0;height:100%;background:#0d1117}
    body{font-family:'Segoe UI Emoji','Apple Color Emoji','Noto Color Emoji',system-ui,Arial,sans-serif}
    #game-container{width:100vw;height:100vh;display:flex;align-items:center;justify-content:center}

    /* Overlay sblocco audio (mobile) */
    .audio-unlock{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6);z-index:999}
    .audio-unlock>button{font-size:18px;padding:10px 14px;border-radius:12px;border:0;background:#0a7d33;color:#fff;box-shadow:0 6px 16px rgba(0,0,0,.35);cursor:pointer}

    /* Hint: non deve bloccare i tap */
    .hint{position:fixed;left:8px;bottom:74px;background:rgba(255,255,255,.92);padding:6px 8px;border-radius:8px;font-size:12px;z-index:50;pointer-events:none}

    /* Toolbar fuori dalla scena (anti-overlap) */
    #toolbar{position:fixed;left:50%;transform:translateX(-50%);bottom:8px;z-index:1000;display:none;gap:8px;padding:8px;border-radius:14px;background:rgba(10,14,19,.7);backdrop-filter:blur(4px);border:1px solid rgba(255,255,255,.15)}
    #toolbar button{font:600 14px system-ui,Arial,sans-serif;padding:8px 10px;border-radius:12px;border:0;color:#fff;box-shadow:0 4px 12px rgba(0,0,0,.25);cursor:pointer;white-space:nowrap}
    #btn-menu,#btn-restart{background:#424242}
    #btn-poop{background:#a34a00}
    #btn-narwhal{background:#6a1b9a}
    #btn-siren{background:#2947a3}
    #btn-tornado{background:#00695c}
  </style>
</head>
<body>
  <div id="game-container"></div>

  <div id="toolbar" aria-label="Comandi di gioco">
    <button id="btn-menu">‚¨Ö Menu</button>
    <button id="btn-restart">‚ü≤ Ricomincia</button>
    <button id="btn-poop">üí©</button>
    <button id="btn-narwhal">üêã</button>
    <button id="btn-siren">üßú‚Äç‚ôÄÔ∏è</button>
    <button id="btn-tornado">üåÄ</button>
  </div>

  <div id="audio-gate" class="audio-unlock"><button id="audio-btn">üîà Tocca per attivare audio</button></div>
  <div class="hint">Tap/click per muovere ‚Ä¢ SPAZIO: üí© ‚Ä¢ N: üêã ‚Ä¢ S: üßú‚Äç‚ôÄÔ∏è ‚Ä¢ T: üåÄ</div>

  <!-- Phaser -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.87.0/dist/phaser.min.js"></script>

  <script type="module">
    /* ============================================================
     * Poo Poo Panda ‚Äî Single file con sprite-sheet incorporato
     * - Sprite-sheet generato a runtime (canvas ‚Üí dataURL ‚Üí spritesheet)
     * - Nessun asset esterno richiesto
     * - Tutte le modifiche concordate + vibrazione dispositivi
     * ============================================================ */

    const Phaser = window.Phaser;
    const FONT = "Segoe UI Emoji, Apple Color Emoji, Noto Color Emoji, Arial, sans-serif";

    /* ---------------- Haptics ---------------- */
    const Haptics = {
      vib: (pattern)=> { try{ if(navigator.vibrate) navigator.vibrate(pattern); }catch{} },
      wrong: ()=>Haptics.vib(80),
      bonusPickup: ()=>Haptics.vib(35),
      bonusUse: ()=>Haptics.vib([30,50,30]),
      win: ()=>Haptics.vib([30,70,30]),
      lose: ()=>Haptics.vib([70,40,70]),
    };

    /* ---------------- Sprite sheet config ----------------
     * COLS: colonne griglia, ROWS: righe, CELL: lato cella (px)
     * MAP: mappa di frame ‚Üí animazioni coese con quanto usiamo nel gioco
     * ---------------------------------------------------- */
    const SPRITE = { NAME:'pp_sheet', COLS:8, ROWS:18, CELL:128 };
    const idx = (r,c)=> r*SPRITE.COLS + c;
    const rowSpan = (r, startC, count)=> Array.from({length:count},(_,i)=> idx(r, startC+i));

    const MAP = {
      // Panda piccoli/adulti (M/F) ‚Äî walk & swim (6 frame)
      panda_child_m_walk: rowSpan(0,0,6),
      panda_child_f_walk: rowSpan(1,0,6),
      panda_child_m_swim: rowSpan(2,0,6),
      panda_child_f_swim: rowSpan(3,0,6),

      panda_adult_m_walk: rowSpan(4,0,6),
      panda_adult_f_walk: rowSpan(5,0,6),
      panda_adult_m_swim: rowSpan(6,0,6),
      panda_adult_f_swim: rowSpan(7,0,6),

      // Umani (walk)
      human_child_m_walk: rowSpan(8,0,6),
      human_child_f_walk: rowSpan(9,0,6),
      human_adult_m_walk: rowSpan(10,0,6),
      human_adult_f_walk: rowSpan(11,0,6),

      // Nuotatori (testa+bracciata)
      swimmer_m_swim: rowSpan(12,0,6),
      swimmer_f_swim: rowSpan(13,0,6),

      // Bagnino (idle 3 frame)
      lifeguard_idle:  rowSpan(14,0,3),

      // Granchi & bonus
      crab_walk:       rowSpan(15,0,4),
      crab_bonus:      [ idx(15,6) ],

      // Powerups
      bonus_narwhal:   [ idx(16,0) ],
      bonus_siren:     [ idx(16,1) ],
      bonus_tornado:   [ idx(16,2) ],

      // Cibi
      food_bamboo:     [ idx(17,0) ],
      food_pasta:      [ idx(17,1) ],
      food_pizza:      [ idx(17,2) ],
      food_gelato:     [ idx(17,3) ],
    };

    /* ---------------- Generazione sprite-sheet inline ----------------
     * Non √® fotorealistico ma √® "carino" e coerente; se vorrai sostituirlo
     * con uno fotorealistico, baster√† rimpiazzare la funzione con un dataURL PNG.
     * ---------------------------------------------------------------- */
    function drawPanda(ctx, CELL, {small=false, female=false, swim=false, frame=0}){
      const cx=CELL/2, cy=CELL/2, scale= small?0.85:1.0;
      const wob = Math.sin(frame/6*Math.PI*2)*4;
      // corpo
      ctx.save();
      ctx.translate(cx, cy + (swim?0:5));
      ctx.scale(scale, scale);
      ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0,0,30,0,Math.PI*2); ctx.fill();
      // orecchie
      ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(-15,-22,8,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(15,-22,8,0,Math.PI*2); ctx.fill();
      // occhi
      ctx.beginPath(); ctx.ellipse(-8,-4,6,9,0,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(8,-4,6,9,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(-8,-4,3,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(8,-4,3,0,Math.PI*2); ctx.fill();
      // naso
      ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(0,8,3,0,Math.PI*2); ctx.fill();
      // accessorio
      if(female){ // fiocco
        ctx.fillStyle='#ff3da7';
        ctx.beginPath(); ctx.ellipse(-16,-28,7,10,0,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(-6,-28,7,10,0,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(-11,-28,3,0,Math.PI*2); ctx.fill();
      } else { // cappellino
        ctx.fillStyle='#1f4d7a';
        ctx.beginPath(); ctx.ellipse(0,-28,22,10,0,0,Math.PI*2); ctx.fill();
        ctx.fillRect(-12,-28,24,5);
      }
      // arti stilizzati (walk/nuoto)
      ctx.fillStyle='#000';
      const phase = (frame%6)/6*Math.PI*2;
      if(swim){
        // bracciata
        ctx.save(); ctx.translate(-18,8); ctx.rotate(Math.sin(phase)*0.6); ctx.fillRect(-2,-12,4,24); ctx.restore();
        ctx.save(); ctx.translate(18,8);  ctx.rotate(Math.sin(phase+Math.PI)*0.6); ctx.fillRect(-2,-12,4,24); ctx.restore();
      } else {
        // cammino
        ctx.save(); ctx.translate(-10,22); ctx.rotate(Math.sin(phase)*0.6); ctx.fillRect(-2,-8,4,16); ctx.restore();
        ctx.save(); ctx.translate(10,22);  ctx.rotate(Math.sin(phase+Math.PI)*0.6); ctx.fillRect(-2,-8,4,16); ctx.restore();
        ctx.save(); ctx.translate(-16,8);  ctx.rotate(Math.sin(phase+Math.PI)*0.5); ctx.fillRect(-2,-8,4,16); ctx.restore();
        ctx.save(); ctx.translate(16,8);   ctx.rotate(Math.sin(phase)*0.5); ctx.fillRect(-2,-8,4,16); ctx.restore();
      }
      ctx.restore();
      // onde
      if(swim){
        ctx.fillStyle='#bfe8ff';
        ctx.beginPath(); ctx.ellipse(cx, cy+40, 26, 10, 0, 0, Math.PI*2); ctx.fill();
      }
    }
    function drawHuman(ctx, CELL, {child=false, female=false, swim=false, frame=0}){
      const cx=CELL/2, cy=CELL/2, scale=child?0.9:1.0;
      ctx.save(); ctx.translate(cx, cy); ctx.scale(scale, scale);
      // testa
      ctx.fillStyle='#ffd7b3'; ctx.beginPath(); ctx.arc(0,0,28,0,Math.PI*2); ctx.fill();
      // capelli
      ctx.fillStyle='#3b2e2a';
      if(female){ ctx.beginPath(); ctx.ellipse(0,-6,40,22,0,0,Math.PI*2); ctx.fill(); }
      else { ctx.beginPath(); ctx.ellipse(0,-8,36,16,0,0,Math.PI*2); ctx.fill(); }
      // occhi + bocca
      ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(-8,-4,3,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(8,-4,3,0,Math.PI*2); ctx.fill();
      ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,8,6,0,Math.PI); ctx.stroke();
      // accessorio
      if(female){ ctx.fillStyle='#ff3da7'; ctx.beginPath(); ctx.ellipse(-16,-28,7,10,0,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(-6,-28,7,10,0,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(-11,-28,3,0,Math.PI*2); ctx.fill(); }
      else { ctx.fillStyle='#1f4d7a'; ctx.beginPath(); ctx.ellipse(0,-28,22,10,0,0,Math.PI*2); ctx.fill(); ctx.fillRect(-12,-28,24,5); }
      // arti
      ctx.fillStyle='#000'; const phase = (frame%6)/6*Math.PI*2;
      if(swim){
        ctx.save(); ctx.translate(-18,8); ctx.rotate(Math.sin(phase)*0.6); ctx.fillRect(-2,-12,4,24); ctx.restore();
        ctx.save(); ctx.translate(18,8);  ctx.rotate(Math.sin(phase+Math.PI)*0.6); ctx.fillRect(-2,-12,4,24); ctx.restore();
        ctx.fillStyle='#bfe8ff'; ctx.beginPath(); ctx.ellipse(0,40,26,10,0,0,Math.PI*2); ctx.fill();
      } else {
        ctx.save(); ctx.translate(-10,22); ctx.rotate(Math.sin(phase)*0.6); ctx.fillRect(-2,-8,4,16); ctx.restore();
        ctx.save(); ctx.translate(10,22);  ctx.rotate(Math.sin(phase+Math.PI)*0.6); ctx.fillRect(-2,-8,4,16); ctx.restore();
        ctx.save(); ctx.translate(-16,8);  ctx.rotate(Math.sin(phase+Math.PI)*0.5); ctx.fillRect(-2,-8,4,16); ctx.restore();
        ctx.save(); ctx.translate(16,8);   ctx.rotate(Math.sin(phase)*0.5); ctx.fillRect(-2,-8,4,16); ctx.restore();
      }
      ctx.restore();
    }
    function drawSwimmer(ctx, CELL, {female=false, frame=0}){
      drawHuman(ctx, CELL, {child:false,female,swim:true,frame});
    }
    function drawLifeguard(ctx, CELL, {frame=0}){
      const cx=CELL/2, cy=CELL/2;
      ctx.save(); ctx.translate(cx, cy-6);
      // testa
      ctx.fillStyle='#ffd7b3'; ctx.beginPath(); ctx.arc(0,0,24,0,Math.PI*2); ctx.fill();
      // cappello rosso
      ctx.fillStyle='#c62828'; ctx.beginPath(); ctx.ellipse(0,-18,36,16,0,0,Math.PI*2); ctx.fill(); ctx.fillRect(-22,-18,44,6);
      // torace
      ctx.fillStyle='#ffffff'; ctx.beginPath(); ctx.ellipse(0,26,28,18,0,0,Math.PI*2); ctx.fill();
      // fischietto (oscilla)
      ctx.fillStyle='#808080'; const wob = Math.sin(frame/3*Math.PI*2)*2; ctx.fillRect(-2,14,4,8); ctx.fillRect(-6,16,12,4);
      ctx.restore();
    }
    function drawCrab(ctx, CELL, {frame=0}){
      const cx=CELL/2, cy=CELL/2;
      ctx.save(); ctx.translate(cx,cy);
      ctx.fillStyle='#b83d17'; ctx.beginPath(); ctx.ellipse(0,0,28,18,0,0,Math.PI*2); ctx.fill();
      // chele
      ctx.beginPath(); ctx.arc(-24,-6,8,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(24,-6,8,0,Math.PI*2); ctx.fill();
      // zampette animate
      ctx.fillStyle='#7a240d'; const a = frame%4;
      for(let i=0;i<3;i++){ const y=12, x= -18 + i*12; ctx.fillRect(x, y+(a===i?0:3), 6, 3); ctx.fillRect(-x, y+((a+1)%4===i?0:3), 6, 3); }
      ctx.restore();
    }
    function drawBonus(ctx,CELL,type){
      const cx=CELL/2, cy=CELL/2;
      if(type==='narwhal'){ ctx.fillStyle='#1b7'; ctx.beginPath(); ctx.ellipse(cx,cy,28,16,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#fff'; ctx.fillRect(cx+20,cy-3,12,6); }
      if(type==='siren'){ ctx.fillStyle='#0a4abf'; ctx.beginPath(); ctx.arc(cx,cy-8,16,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#0b8'; ctx.beginPath(); ctx.moveTo(cx-14,cy+6); ctx.quadraticCurveTo(cx,cy+22,cx+14,cy+6); ctx.quadraticCurveTo(cx,cy+14,cx-14,cy+6); ctx.fill(); }
      if(type==='tornado'){ ctx.strokeStyle='#00695c'; ctx.lineWidth=4; for(let r=8;r<=28;r+=8){ ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke(); } }
      if(type==='crab'){ ctx.fillStyle='#8B4513'; ctx.beginPath(); ctx.arc(cx,cy,18,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#fff'; ctx.font='bold 16px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('+',cx,cy); }
    }
    function drawFood(ctx,CELL,type){
      const cx=CELL/2, cy=CELL/2;
      if(type==='bamboo'){ ctx.fillStyle='#1f7a1f'; for(let i=0;i<3;i++){ ctx.fillRect(cx-20+i*14, cy-22, 6, 44); } }
      if(type==='pasta'){ ctx.fillStyle='#d4b16a'; ctx.beginPath(); ctx.ellipse(cx,cy,28,16,0,0,Math.PI*2); ctx.fill(); }
      if(type==='pizza'){ ctx.fillStyle='#a83232'; ctx.beginPath(); ctx.moveTo(cx-24,cy+18); ctx.lineTo(cx+24,cy+18); ctx.lineTo(cx,cy-18); ctx.closePath(); ctx.fill(); }
      if(type==='gelato'){ ctx.fillStyle='#d18'; ctx.beginPath(); ctx.arc(cx,cy-8,16,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#b78'; ctx.beginPath(); ctx.moveTo(cx-10,cy+12); ctx.lineTo(cx+10,cy+12); ctx.lineTo(cx,cy-2); ctx.closePath(); ctx.fill(); }
    }

    function generateEmbeddedSpriteSheetDataURL(){
      const {COLS,ROWS,CELL}=SPRITE;
      const W=COLS*CELL, H=ROWS*CELL;
      const cvs=document.createElement('canvas'); cvs.width=W; cvs.height=H;
      const ctx=cvs.getContext('2d');
      ctx.clearRect(0,0,W,H);

      // helper per disegnare in cella (r,c)
      const inCell=(r,c,draw)=>{ ctx.save(); ctx.translate(c*CELL, r*CELL); draw(ctx); ctx.restore(); };

      // Panda child/adult M/F (walk & swim) ‚Äî 6 frame
      for(let f=0; f<6; f++){
        inCell(0,f,   (c)=>drawPanda(c,CELL,{small:true,female:false,swim:false,frame:f}));
        inCell(1,f,   (c)=>drawPanda(c,CELL,{small:true,female:true,swim:false,frame:f}));
        inCell(2,f,   (c)=>drawPanda(c,CELL,{small:true,female:false,swim:true, frame:f}));
        inCell(3,f,   (c)=>drawPanda(c,CELL,{small:true,female:true,swim:true,  frame:f}));

        inCell(4,f,   (c)=>drawPanda(c,CELL,{small:false,female:false,swim:false,frame:f}));
        inCell(5,f,   (c)=>drawPanda(c,CELL,{small:false,female:true,swim:false,frame:f}));
        inCell(6,f,   (c)=>drawPanda(c,CELL,{small:false,female:false,swim:true, frame:f}));
        inCell(7,f,   (c)=>drawPanda(c,CELL,{small:false,female:true,swim:true,  frame:f}));
      }

      // Umani walk
      for(let f=0; f<6; f++){
        inCell(8,f,  (c)=>drawHuman(c,CELL,{child:true, female:false, swim:false, frame:f}));
        inCell(9,f,  (c)=>drawHuman(c,CELL,{child:true, female:true,  swim:false, frame:f}));
        inCell(10,f, (c)=>drawHuman(c,CELL,{child:false,female:false, swim:false, frame:f}));
        inCell(11,f, (c)=>drawHuman(c,CELL,{child:false,female:true,  swim:false, frame:f}));
      }

      // Nuotatori
      for(let f=0; f<6; f++){
        inCell(12,f,(c)=>drawSwimmer(c,CELL,{female:false,frame:f}));
        inCell(13,f,(c)=>drawSwimmer(c,CELL,{female:true, frame:f}));
      }

      // Bagnino idle 3 frame
      for(let f=0; f<3; f++){ inCell(14,f,(c)=>drawLifeguard(c,CELL,{frame:f})); }

      // Granchi walk 4 frame + bonus
      for(let f=0; f<4; f++){ inCell(15,f,(c)=>drawCrab(c,CELL,{frame:f})); }
      inCell(15,6,(c)=>drawBonus(c,CELL,'crab'));

      // Powerups
      inCell(16,0,(c)=>drawBonus(c,CELL,'narwhal'));
      inCell(16,1,(c)=>drawBonus(c,CELL,'siren'));
      inCell(16,2,(c)=>drawBonus(c,CELL,'tornado'));

      // Cibi
      inCell(17,0,(c)=>drawFood(c,CELL,'bamboo'));
      inCell(17,1,(c)=>drawFood(c,CELL,'pasta'));
      inCell(17,2,(c)=>drawFood(c,CELL,'pizza'));
      inCell(17,3,(c)=>drawFood(c,CELL,'gelato'));

      return cvs.toDataURL('image/png');
    }

    /* ---------------- Domain ---------------- */
    const Characters = {
      PANDA_PICCOLO: { specie:'panda', eta:'piccolo' },
      PANDA_ADULTO:  { specie:'panda', eta:'adulto'  },
      BAMBINO:       { specie:'umano', eta:'piccolo' },
      ADULTO:        { specie:'umano', eta:'adulto'  }
    };
    const Foods = { BAMBOO:'bamboo', PASTA:'pasta', PIZZA:'pizza', GELATO:'gelato' };
    function allowedFoodsFor(ch){
      if(ch.specie==='panda') return new Set([Foods.BAMBOO]);
      if(ch.specie==='umano' && ch.eta==='piccolo') return new Set([Foods.PASTA]);
      if(ch.specie==='umano' && ch.eta==='adulto')  return new Set([Foods.PIZZA]);
      return new Set();
    }
    function poopGain(ch, food){
      const allow = allowedFoodsFor(ch);
      if(allow.has(food)) return 0.18;
      if(food===Foods.GELATO) return 0.06;
      return 0;
    }
    const GameState = {
      selected: { specie:'panda', eta:'piccolo', genere:'m' },
      poopMeter:0, stomach:0,
      hasNarwhal:false, hasSiren:false, hasTornado:false,
      crabsFriendly:false, transitioning:false
    };
    function resetForNewRun(){
      GameState.poopMeter=0; GameState.stomach=0;
      GameState.hasNarwhal=false; GameState.hasSiren=false; GameState.hasTornado=false;
      GameState.crabsFriendly=false; GameState.transitioning=false;
    }

    /* ---------------- SFX minimal ---------------- */
    let _audioCtx=null;
    function ensureAudioContext(){ if(!_audioCtx) _audioCtx=new (window.AudioContext||window.webkitAudioContext)(); return _audioCtx; }
    function tone({freq=440,dur=0.12,type='sine',vol=0.22}){ const ctx=ensureAudioContext(), osc=ctx.createOscillator(), gain=ctx.createGain(); osc.type=type; osc.frequency.value=freq; osc.connect(gain); gain.connect(ctx.destination); gain.gain.setValueAtTime(vol,ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.0001,ctx.currentTime+dur); osc.start(); osc.stop(ctx.currentTime+dur); }
    const SFX={ play:(f,d,t,v)=>tone({freq:f,dur:d,type:t,vol:v}), eat(){this.play(520,0.08,'triangle',0.22);this.play(660,0.06,'sine',0.18)}, wrong(){this.play(220,0.10,'sawtooth',0.18)}, drop(){this.play(180,0.14,'square',0.22)}, narwhal(){this.play(400,0.10,'sine',0.2);this.play(300,0.20,'triangle',0.15)}, siren(){this.play(900,0.08,'square',0.2);this.play(700,0.12,'square',0.2)}, tornado(){this.play(120,0.30,'sawtooth',0.2)}, crab(){this.play(760,0.06,'square',0.22);this.play(640,0.08,'triangle',0.18)}, win(){[523,659,783].forEach((f,i)=>setTimeout(()=>this.play(f,0.12,'sine',0.22),i*120))}, lose(){[196,185,174].forEach((f,i)=>setTimeout(()=>this.play(f,0.12,'triangle',0.22),i*120))}, button(){this.play(540,0.08,'sine',0.22)} };

    /* ---------------- UI helpers ---------------- */
    function drawProgressBar(g, x, y, w, h, p, col=0x9b5a1a){
      g.lineStyle(2,0x222222,1); g.strokeRoundedRect(x,y,w,h,8);
      g.fillStyle(0x333333,1); g.fillRoundedRect(x,y,w,h,8);
      const pad=4, iw=(w-pad*2)*Phaser.Math.Clamp(p,0,1);
      g.fillStyle(col,1); g.fillRoundedRect(x+pad,y+pad,iw,h-pad*2,6);
    }

    /* ---------------- Boot: carica lo sheet embedded ---------------- */
    class BootScene extends Phaser.Scene{
      constructor(){ super('Boot'); }
      preload(){}
      create(){
        const dataURL = generateEmbeddedSpriteSheetDataURL();
        const image = new Image();
        image.onload = ()=>{
          // Registra spritesheet da immagine caricata
          this.textures.addSpriteSheet(SPRITE.NAME, image, { frameWidth: SPRITE.CELL, frameHeight: SPRITE.CELL, endFrame: SPRITE.COLS*SPRITE.ROWS-1 });
          this.scene.start('MenuScene');
        };
        image.onerror = ()=>{
          // In caso improbabile, proseguiamo con fallback vettoriale
          console.warn('Sprite-sheet embedded non caricato, uso fallback vettoriale');
          this.scene.start('MenuScene');
        };
        image.src = dataURL;
      }
    }

    /* ---------------- Vettoriali fallback (per rari casi) ---------------- */
    function drawBow(g, cx, cy, col=0xff3da7){ g.fillStyle(col,1); g.fillEllipse(cx-6,cy,8,10); g.fillEllipse(cx+6,cy,8,10); g.fillCircle(cx,cy,3); }
    function drawCap(g, cx, cy, col=0x1f4d7a){ g.fillStyle(col,1); g.fillEllipse(cx,cy,26,12); g.fillRect(cx-13,cy,26,5); }
    function drawGlasses(g,cx,cy){ g.lineStyle(2,0x000000,1); g.strokeCircle(cx-8,cy,6); g.strokeCircle(cx+8,cy,6); g.lineBetween(cx-2,cy,cx+2,cy); }
    function createCharacterTexture(scene, key, sel){
      const g=scene.add.graphics(), isPanda=sel.specie==='panda', isBaby=sel.eta==='piccolo', size=isBaby?22:28, pad=22, cx=pad+size, cy=pad+size;
      if (isPanda){
        g.fillStyle(0xffffff,1); g.fillCircle(cx,cy,size);
        g.fillStyle(0x000000,1); g.fillCircle(cx-12,cy-18,isBaby?6:7); g.fillCircle(cx+12,cy-18,isBaby?6:7);
        g.fillEllipse(cx-7,cy-2,10,14); g.fillEllipse(cx+7,cy-2,10,14);
        g.fillStyle(0xffffff,1); g.fillCircle(cx-7,cy-2,3); g.fillCircle(cx+7,cy-2,3);
        g.fillStyle(0x000000,1); g.fillCircle(cx,cy+5,3);
        if (isBaby){ g.fillStyle(0xffa3a3,0.8); g.fillCircle(cx-12, cy+10, 3); g.fillCircle(cx+12, cy+10, 3); }
        else { if (sel.genere==='m'){ g.fillStyle(0xa00000,1); g.fillTriangle(cx, cy+18, cx-6, cy+28, cx+6, cy+28); } else { g.fillStyle(0xffe066,1); g.fillCircle(cx, cy+26, 4); } }
        if (sel.genere==='f') drawBow(g, cx-14, cy-26); else drawCap(g, cx, cy-28);
      } else {
        const skin=0xffe0bd; g.fillStyle(skin,1); g.fillCircle(cx,cy,size);
        const hair=0x3b2e2a; if(isBaby){ g.fillStyle(hair,1); g.fillEllipse(cx,cy-10,size*1.6,size*0.8); }
        else { g.fillStyle(hair,1); if(sel.genere==='f') g.fillEllipse(cx,cy-6,size*1.8,size*1.6); else g.fillEllipse(cx,cy-8,size*1.8,size*1.0); }
        g.fillStyle(0x000000,1); g.fillCircle(cx-7,cy-2,3); g.fillCircle(cx+7,cy-2,3); g.lineStyle(2,0x000000,1); g.strokeCircle(cx,cy+6,6);
        if (sel.genere==='f') drawBow(g, cx-14, cy-26); else drawCap(g, cx, cy-28);
        if (!isBaby && sel.genere==='m') drawGlasses(g, cx, cy-2);
      }
      const w=(size+pad)*2,h=(size+pad)*2; g.generateTexture(key,w,h); g.destroy();
    }

    /* ---------------- Limbs (fallback) ---------------- */
    function makeLimbs(scene,color=0x000000){
      const parts=['LA','RA','LL','RL'].reduce((a,k)=>{ a[k]=scene.add.graphics(); return a; },{});
      const draw=(g,x,y,rot)=>{ g.clear(); g.fillStyle(color,1); g.save(); g.translateCanvas(x,y); g.rotateCanvas(rot); g.fillRoundedRect(-2,-8,4,16,2); g.restore(); };
      return { parts, draw, setVisible(v){ Object.values(parts).forEach(p=>p.setVisible(v)); }, destroy(){ Object.values(parts).forEach(p=>p.destroy()); } };
    }
    function updateLimbs(limbs, px, py, moving, t){
      const amp=moving?0.8:0.2, speed=moving?10:2, s=Math.sin(t*speed);
      limbs.draw(limbs.parts.LA, px-12, py+6,  s*amp);
      limbs.draw(limbs.parts.RA, px+12, py+6, -s*amp);
      limbs.draw(limbs.parts.LL, px-8,  py+20, -s*amp);
      limbs.draw(limbs.parts.RL, px+8,  py+20,  s*amp);
    }

    /* ---------------- Animazioni da sprite ---------------- */
    function ensureAnim(scene, key, frames, frameRate=10, repeat=-1){
      if (!scene.anims.exists(key) && frames && frames.length>0){
        scene.anims.create({ key, frames: frames.map(i=>({key:SPRITE.NAME, frame:i})), frameRate, repeat });
      }
    }
    function sheetOK(scene){ return scene.textures.exists(SPRITE.NAME); }
    function registerBaseAnimations(scene){
      if (!sheetOK(scene)) return;
      Object.entries(MAP).forEach(([name, frames])=>{
        ensureAnim(scene, name, frames, /swim|walk/.test(name)?10:1, /walk|swim/.test(name)?-1:0);
      });
    }
    function animKeysForSelected(sel){
      const g = sel.genere==='f' ? 'f' : 'm';
      if (sel.specie==='panda'){
        const base = sel.eta==='piccolo' ? 'panda_child' : 'panda_adult';
        return { walk: `${base}_${g}_walk`, swim: `${base}_${g}_swim` };
      } else { // umano
        const base = sel.eta==='piccolo' ? 'human_child' : 'human_adult';
        const swim = g==='f' ? 'swimmer_f_swim' : 'swimmer_m_swim';
        return { walk: `${base}_${g}_walk`, swim };
      }
    }

    /* ---------------- Menu ---------------- */
    class MenuScene extends Phaser.Scene{
      constructor(){ super('MenuScene'); }
      create(){
        hideToolbar();
        resetForNewRun();
        this.cameras.main.setBackgroundColor('#0d1117');
        const {width, height}=this.scale;
        registerBaseAnimations(this);

        // sfondo cielo-mare-sabbia
        const bg=this.add.graphics();
        bg.fillStyle(0x0b3d91,1).fillRect(0,0,width,height*0.35);
        bg.fillStyle(0x1976d2,1).fillRect(0,height*0.35,width,height*0.25);
        bg.fillStyle(0xf4e2b5,1).fillRect(0,height*0.60,width,height*0.40);

        const title=this.add.text(width/2,56,'Poo Poo Panda',{fontFamily:FONT,fontSize:52,color:'#fff'}).setOrigin(0.5);
        title.setShadow(3,3,'#000',6,true,true);

        this.input.addPointer(3);
        this.input.setTopOnly(true);

        const panelW=Math.min(760,width-40), panelH=320, px=(width-panelW)/2, py=140;
        const panel=this.add.graphics();
        panel.fillStyle(0x1b2838,.96).fillRoundedRect(px,py,panelW,panelH,20);
        panel.lineStyle(3,0x64b5f6,1).strokeRoundedRect(px,py,panelW,panelH,20);
        this.add.text(width/2,py+16,'Scegli personaggio e genere',{fontFamily:FONT,fontSize:20,color:'#e3f2fd'}).setOrigin(0.5);

        const options=[
          { label:'Panda piccolo', value:Characters.PANDA_PICCOLO },
          { label:'Panda adulto',  value:Characters.PANDA_ADULTO  },
          { label:'Bambino umano', value:Characters.BAMBINO       },
          { label:'Adulto umano',  value:Characters.ADULTO        },
        ];
        let selectedIdx=0, gender='m';
        const cards=[];
        const startX=px+24, startY=py+84, gapX=(panelW-48)/4, cardW=gapX-10, cardH=120;

        const drawCardBG=(g, active)=>{
          g.clear();
          if(active){
            g.fillStyle(0x0e3a5a,1).fillRoundedRect(0,0,cardW,cardH,16);
            g.lineStyle(4,0x9be7ff,1).strokeRoundedRect(0,0,cardW,cardH,16);
            g.fillStyle(0x9be7ff,.22).fillRoundedRect(3,3,cardW-6,cardH-6,14);
          }else{
            g.fillStyle(0x102131,1).fillRoundedRect(0,0,cardW,cardH,16);
            g.lineStyle(2,0x5dade2,1).strokeRoundedRect(0,0,cardW,cardH,16);
          }
        };

        const makeCard=(i)=>{
          const x=startX+i*gapX, y=startY;
          const c=this.add.container(x,y);
          const g=this.add.graphics(); c.add(g);
          const img = this.add.image(cardW/2,48,SPRITE.NAME,0).setVisible(sheetOK(this)).setScale(0.6); c.add(img);
          const txt = this.add.text(cardW/2, cardH-18, options[i].label, {fontFamily:FONT,fontSize:15,color:'#e3f2fd'}).setOrigin(0.5); txt.setShadow(2,2,'#000',4,true,true); c.add(txt);
          c.setSize(cardW,cardH);

          const sel = ()=>({...options[i].value, genere: gender});
          const key = ()=>`menu_prev_${i}_${gender}`;

          const refreshVisual=()=>{
            drawCardBG(g, i===selectedIdx);
            if (sheetOK(this)){
              const ak = animKeysForSelected(sel()).walk;
              const frames = MAP[ak];
              if (frames){ img.setVisible(true).setTexture(SPRITE.NAME, frames[0]).setScale(0.6); }
            } else {
              if(!this.textures.exists(key())) createCharacterTexture(this,key(),sel());
              img.setVisible(true).setTexture(key()).setScale(0.9);
            }
          };
          refreshVisual();

          // UN SOLO TAP per selezionare
          c.setInteractive({useHandCursor:true})
           .on('pointerdown', ()=>{ SFX.button(); selectedIdx=i; cards.forEach(cc=>cc.refresh()); });

          // i figli non devono mangiare l'evento
          c.iterate(child=>{ if(child.input) child.removeInteractive(); });

          const api={ refresh: refreshVisual };
          cards.push(api);
        };
        for(let i=0;i<options.length;i++) makeCard(i);

        // Toggle genere
        const pillW=240, pillH=40, pillX=width/2-pillW/2, pillY=py+panelH-58, pill=this.add.graphics();
        const drawPill=()=>{
          pill.clear();
          pill.fillStyle(0x102131,1).fillRoundedRect(pillX,pillY,pillW,pillH,20);
          pill.lineStyle(2,0x90caf9,1).strokeRoundedRect(pillX,pillY,pillW,pillH,20);
          const knobX=gender==='m'?pillX+pillW*0.25:pillX+pillW*0.75;
          pill.fillStyle(0x64b5f6,1).fillRoundedRect(knobX-46,pillY+6,92,pillH-12,16);
        };
        drawPill();
        this.add.text(pillX+pillW*0.25,pillY+pillH/2,'‚ôÇÔ∏è Maschio',{fontFamily:FONT,fontSize:16,color:'#e3f2fd'}).setOrigin(0.5);
        this.add.text(pillX+pillW*0.75,pillY+pillH/2,'‚ôÄÔ∏è Femmina',{fontFamily:FONT,fontSize:16,color:'#e3f2fd'}).setOrigin(0.5);
        this.add.zone(pillX,pillY,pillW,pillH).setOrigin(0).setInteractive({useHandCursor:true}).on('pointerdown',()=>{
          SFX.button(); gender=(gender==='m')?'f':'m'; drawPill(); cards.forEach(c=>c.refresh());
        });

        // Start (sempre cliccabile anche in landscape)
        const start=this.add.text(width/2,height-64,'Inizia ‚ñ∂',{fontFamily:FONT,fontSize:30,color:'#fff',backgroundColor:'#43a047',padding:{left:18,right:18,top:8,bottom:8}}).setOrigin(0.5);
        start.setShadow(3,3,'#1b5e20',6,true,true);
        const goStart=()=>{ if(GameState.transitioning) return; GameState.transitioning=true; SFX.button(); const chosen=options[selectedIdx].value; GameState.selected={ specie:chosen.specie, eta:chosen.eta, genere:gender }; this.scene.start('LandScene'); };
        start.setInteractive({useHandCursor:true}).on('pointerdown',goStart);
        const startZone=this.add.zone(start.x,start.y,Math.max(240,start.width+160),Math.max(56,start.height+24)).setOrigin(0.5).setInteractive({useHandCursor:true}).on('pointerdown',goStart);

        this.scale.on('resize', ({width:W,height:H})=>{ start.setPosition(W/2, H-64); startZone.setPosition(W/2, H-64); });
      }
    }

    /* ---------------- Land Scene ---------------- */
    class LandScene extends Phaser.Scene{
      constructor(){ super('LandScene'); }
      create(){
        hideToolbar();
        GameState.transitioning=false;
        const {width,height}=this.scale;
        this.cameras.main.setBackgroundColor('#87CEEB');
        const bg=this.add.graphics();
        bg.fillStyle(0x1976d2,1).fillRect(0,height*0.35,width,height*0.25); // fascia mare
        bg.fillStyle(0xF4E2B5,1).fillRect(0,height*0.60,width,height*0.40); // sabbia

        // Player
        let playerObj;
        if (sheetOK(this)){
          const ak = animKeysForSelected(GameState.selected).walk;
          if (this.anims.exists(ak)) playerObj=this.add.sprite(width/2,height*0.6,SPRITE.NAME, MAP[ak][0]).play(ak);
        }
        if (!playerObj){ const key=`char_${GameState.selected.specie}_${GameState.selected.eta}_${GameState.selected.genere}`; createCharacterTexture(this,key,GameState.selected); playerObj=this.add.image(width/2,height*0.6,key); }
        this.player=playerObj; this.physics.add.existing(this.player); this.player.body.setCircle(this.player.displayWidth/2).setCollideWorldBounds(true);
        this.playerLimbs = sheetOK(this) ? null : makeLimbs(this,0x000000);

        // Gruppi
        this.foods=this.physics.add.group(); this.bonuses=this.physics.add.group();

        // UI a destra (testi fuori barra ad alto contrasto)
        this.ui=this.add.graphics();
        this.poopText=this.add.text(0,0,'',{fontFamily:FONT,fontSize:14,color:'#ffffff'}).setOrigin(1,0).setStroke('#111',4).setShadow(2,2,'#000',4);
        this.stomachText=this.add.text(0,0,'',{fontFamily:FONT,fontSize:14,color:'#ffffff'}).setOrigin(1,0).setStroke('#111',4).setShadow(2,2,'#000',4);
        this.promptText=this.add.text(width/2,48,'',{fontFamily:FONT,fontSize:18,color:'#111',backgroundColor:'#fff',padding:{left:8,right:8,top:4,bottom:4}}).setOrigin(0.5);
        this.seaBtn=this.add.text(width-190,42,'Vai al Mare ‚ñ∂',{fontFamily:FONT,fontSize:18,color:'#fff',backgroundColor:'#0a7d33',padding:{left:10,right:10,top:6,bottom:6}})
          .setInteractive({useHandCursor:true}).on('pointerdown',()=>this.tryGoSea());
        this.seaBtn.visible=false;
        this.restartBtn=this.add.text(16,height-44,'‚ü≤ Ricomincia (R)',{fontFamily:FONT,fontSize:18,color:'#fff',backgroundColor:'#444',padding:{left:10,right:10,top:6,bottom:6}})
          .setInteractive({useHandCursor:true}).on('pointerdown',()=>{ resetForNewRun(); this.scene.restart(); });

        // Spawn iniziale
        this.sceneStartMs=this.time.now; this.GRACE_MS=1000; this.EAT_COOLDOWN_MS=180; this.lastEatMs=0;
        this.spawnFoodWave(); this.spawnBonusNarwhal();

        this.tut=this.add.text(width/2,height-90,'Mangia i cibi giusti. Evita quelli sbagliati (mal di pancia). Riempi ‚â• 60% e vai al mare!',{fontFamily:FONT,fontSize:16,color:'#001',backgroundColor:'#fff',padding:{left:8,right:8,top:6,bottom:6}}).setOrigin(0.5);
        this.time.delayedCall(5000,()=>this.tut.setVisible(false));

        // Input
        this.cursors=this.input.keyboard.createCursorKeys(); this.wasd=this.input.keyboard.addKeys('W,A,S,D');
        this.keyM=this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.M);
        this.pointerTarget=null; this.pointerMarker=this.add.circle(0,0,8,0x000000,0.25).setVisible(false);
        const setPointerTarget=(p)=>{ this.pointerTarget={x:p.worldX,y:p.worldY}; this.pointerMarker.setPosition(this.pointerTarget.x,this.pointerTarget.y).setVisible(true); };
        this.input.on('pointerdown',setPointerTarget); this.input.on('pointermove',(p)=>{ if(p.isDown) setPointerTarget(p); });

        // Collisions
        this.physics.add.overlap(this.player,this.foods,this.onEatFood,null,this);
        this.physics.add.overlap(this.player,this.bonuses,this.onTakeBonus,null,this);

        this.scale.on('resize', ({width:W,height:H})=>{
          this.seaBtn.setPosition(W-190,42);
          this.restartBtn.setPosition(16,H-44);
          this.tut.setPosition(W/2,H-90);
        });
      }
      getSafeSpawn(minDist=120){ const {width,height}=this.scale; const b={xMin:40,xMax:width-40,yMin:height*0.4,yMax:height-40}; return randomPointAvoiding({x:this.player.x,y:this.player.y},minDist,b); }
      spawnFoodWave(){ const types=[Foods.BAMBOO,Foods.PASTA,Foods.PIZZA,Foods.GELATO]; for(let i=0;i<8;i++){ const t=Phaser.Utils.Array.GetRandom(types); const p=this.getSafeSpawn(140); this.spawnFoodAt(p.x,p.y,t);} }
      spawnFoodAt(x,y,t){
        if (sheetOK(this)){
          const key = t===Foods.BAMBOO ? 'food_bamboo' : t===Foods.PASTA ? 'food_pasta' : t===Foods.PIZZA ? 'food_pizza' : 'food_gelato';
          const frames = MAP[key]; if (frames){ const spr=this.add.image(x,y,SPRITE.NAME,frames[0]).setScale(0.8); this.physics.add.existing(spr); spr.body.setCircle(24).setOffset(-24,-24).setImmovable(true); spr.foodType=t; this.foods.add(spr); return; }
        }
        const txt=this.add.text(x,y,labelForFood(t),{fontFamily:FONT,fontSize:18,color:colorForFood(t)}).setOrigin(0.5);
        this.physics.add.existing(txt); txt.body.setCircle(24).setOffset(-24,-24).setImmovable(true); txt.foodType=t; this.foods.add(txt);
      }
      spawnSingleFood(){ const types=[Foods.BAMBOO,Foods.PASTA,Foods.PIZZA,Foods.GELATO]; const t=Phaser.Utils.Array.GetRandom(types); const p=this.getSafeSpawn(120); this.spawnFoodAt(p.x,p.y,t); }
      spawnBonusNarwhal(){
        if(GameState.hasNarwhal) return;
        const p=this.getSafeSpawn(160);
        const b=this.add.image(p.x,p.y,SPRITE.NAME,MAP.bonus_narwhal[0]).setScale(0.9);
        this.physics.add.existing(b); b.body.setCircle(26).setOffset(-26,-26).setImmovable(true); b.bonusType='narwhal'; this.bonuses.add(b);
      }
      onEatFood(player,food){
        const now=this.time.now; if(now-this.sceneStartMs<this.GRACE_MS) return; if(now-this.lastEatMs<this.EAT_COOLDOWN_MS) return; this.lastEatMs=now;
        const gain=poopGain(GameState.selected,food.foodType);
        if(gain===0){ GameState.stomach=Math.min(1,GameState.stomach+0.22); this.tweens.add({targets:food,angle:10,yoyo:true,duration:120,onComplete:()=>food.destroy()}); SFX.wrong(); Haptics.wrong(); }
        else { GameState.poopMeter=Math.min(1,GameState.poopMeter+gain); this.tweens.add({targets:food,scale:1.25,yoyo:true,duration:120,onComplete:()=>food.destroy()}); SFX.eat(); }
        this.time.delayedCall(300,()=>this.spawnSingleFood());
      }
      onTakeBonus(_,bonus){
        if(bonus.bonusType==='narwhal'){ GameState.hasNarwhal=true; this.tweens.add({targets:bonus,angle:360,scale:1.5,duration:240,onComplete:()=>bonus.destroy()}); SFX.narwhal(); Haptics.bonusPickup(); }
      }
      tryGoSea(){ if(GameState.poopMeter<0.6||GameState.transitioning) return; GameState.transitioning=true; this.scene.start('SeaScene'); }
      update(time,delta){
        const {width,height}=this.scale; const body=this.player.body; const dt=delta/1000;
        body.setVelocity(0);
        const inWater=(this.player.y>=height*0.35 && this.player.y<=height*0.60);
        const speed=inWater?110:160;
        if(this.cursors.left.isDown||this.wasd.A.isDown) body.setVelocityX(-speed); else if(this.cursors.right.isDown||this.wasd.D.isDown) body.setVelocityX(speed);
        if(this.cursors.up.isDown||this.wasd.W.isDown) body.setVelocityY(-speed); else if(this.cursors.down.isDown||this.wasd.S.isDown) body.setVelocityY(speed);
        if(this.pointerTarget){ const dx=this.pointerTarget.x-this.player.x, dy=this.pointerTarget.y-this.player.y, d=Math.hypot(dx,dy); if(d>6) body.setVelocity((dx/d)*speed,(dy/d)*speed); else { this.pointerTarget=null; this.pointerMarker.setVisible(false);} }

        // UI destre (testi fuori barra)
        const barW=220, barH=22, pad=16, xRight=width-barW-pad;
        this.ui.clear();
        drawProgressBar(this.ui,xRight,12,barW,barH,GameState.poopMeter,0x9b5a1a);
        drawProgressBar(this.ui,xRight,12+barH+6,barW,barH,GameState.stomach,0xcc3333);
        this.poopText.setPosition(xRight+barW,12).setText(`Pup√π: ${Math.round(GameState.poopMeter*100)}%`);
        this.stomachText.setPosition(xRight+barW,12+barH+6).setText(`Mal di pancia: ${Math.round(GameState.stomach*100)}%`);

        const canSea=GameState.poopMeter>=0.6; this.promptText.setText(canSea?'Premi M o tocca ‚ñ∂ Vai al Mare':'Riempi la barra pup√π (‚â•60%)'); this.seaBtn.visible=canSea;
        if(Phaser.Input.Keyboard.JustDown(this.keyM)) this.tryGoSea();

        if(GameState.poopMeter>=1.0){ SFX.lose(); Haptics.lose(); this.scene.start('LoseScene',{reason:'overeat'}); }
        if(GameState.stomach>=1.0){ SFX.lose(); Haptics.lose(); this.scene.start('LoseScene',{reason:'stomachache'}); }

        if(!sheetOK(this) && this.playerLimbs){ const moving=body.velocity.length()>5; updateLimbs(this.playerLimbs,this.player.x,this.player.y,moving,time/1000); }

        this.player.y = Phaser.Math.Clamp(this.player.y, height*0.30, height-20);
      }
      shutdown(){ this.playerLimbs?.destroy?.(); }
    }

    /* ---------------- Sea Scene (spiaggia in alto) ---------------- */
    class SeaScene extends Phaser.Scene{
      constructor(){ super('SeaScene'); }
      create(){
        showToolbar();
        GameState.transitioning=false;
        const {width,height}=this.scale;
        this.cameras.main.setBackgroundColor('#3CB7E7');

        // Spiaggia in alto
        this.beachHeight = Math.floor(height * 0.26);
        this.beachBottomY = this.beachHeight;

        const bg=this.add.graphics();
        bg.fillStyle(0xF4E2B5,1).fillRect(0,0,width,this.beachHeight);
        bg.fillStyle(0x3CB7E7,1).fillRect(0,this.beachHeight,width,height-this.beachHeight);

        // Player (swim se possibile)
        let playerObj;
        if (sheetOK(this)){
          const ak = animKeysForSelected(GameState.selected).swim;
          if (this.anims.exists(ak)) playerObj=this.add.sprite(width*0.5,this.beachBottomY+60,SPRITE.NAME, MAP[ak][0]).play(ak);
        }
        if (!playerObj){ const key=`char_${GameState.selected.specie}_${GameState.selected.eta}_${GameState.selected.genere}`; createCharacterTexture(this,key,GameState.selected); playerObj=this.add.image(width*0.5,this.beachBottomY+60,key); }
        this.player=playerObj; this.physics.add.existing(this.player); this.player.body.setCircle(this.player.displayWidth/2).setCollideWorldBounds(true);
        this.playerLimbs = sheetOK(this) ? null : makeLimbs(this,0x001122);

        // Corrente (freccia verde chiaro)
        this.currentAngle=Phaser.Math.FloatBetween(-Math.PI,Math.PI);
        this.currentSpeed=38; this.currentFrozen=false; this.currentArrow=this.add.graphics();
        this.cloud=this.add.text(width/2,36,'‚òÅÔ∏è‚òÅÔ∏è‚òÅÔ∏è',{fontFamily:FONT,fontSize:40,color:'#fff'}).setOrigin(0.5).setVisible(false);
        this.tweens.add({targets:this.cloud,scale:1.15,yoyo:true,repeat:-1,duration:450,ease:'Sine.easeInOut'});
        this.scheduleNextCurrentChange();

        // Gruppi
        this.poops=this.add.group();
        this.narwhals=[];
        this.swimmers=[];
        this.seaBonuses=this.physics.add.group();

        // Bagnino in spiaggia, guarda verso il mare (giu')
        let lifeguardImage=this.add.sprite(width/2,this.beachBottomY-22,SPRITE.NAME,MAP.lifeguard_idle[0]).play('lifeguard_idle');
        this.lifeguardSprite=lifeguardImage.setDepth(5);
        this.lifeguard={ x:lifeguardImage.x, y:lifeguardImage.y, dir: Math.PI/2, sweepMin: Math.PI/2 - Phaser.Math.DegToRad(35), sweepMax: Math.PI/2 + Phaser.Math.DegToRad(35), speed: Phaser.Math.DegToRad(20), fov: Phaser.Math.DegToRad(50), range: 360, distractedUntil: 0 };
        this.visionGfx=this.add.graphics().setDepth(2);

        // Nuotatori SOLO mare
        for(let i=0;i<6;i++){
          const sKey = i%2===0 ? 'swimmer_m_swim' : 'swimmer_f_swim';
          const x=Phaser.Math.Between(60,width-60), y=Phaser.Math.Between(this.beachBottomY+70, height-90);
          let s=this.add.sprite(x,y,SPRITE.NAME, MAP[sKey][0]).play(sKey).setDepth(3);
          this.physics.add.existing(s); s.body.setCircle(s.displayWidth/2).setCollideWorldBounds(true);
          const limbs = sheetOK(this) ? null : makeLimbs(this,0x223344);
          this.swimmers.push({ sprite:s, dir:Phaser.Math.FloatBetween(-Math.PI,Math.PI), speed:42, fov:Phaser.Math.DegToRad(40), range:140, changeAt:0, limbs });
        }

        // Bonus (anti-overlay: margine in basso)
        const BOTTOM_OVERLAY_PX = 110;
        if(!GameState.hasNarwhal) this.spawnSeaBonus('narwhal', BOTTOM_OVERLAY_PX);
        if(!GameState.hasSiren)   this.spawnSeaBonus('siren',   BOTTOM_OVERLAY_PX);
        if(!GameState.hasTornado) this.spawnSeaBonus('tornado', BOTTOM_OVERLAY_PX);
        this.spawnCrabBonus(); // su spiaggia

        // Tornado
        this.tornado=null; this.tornadoGfx=this.add.graphics().setDepth(4);

        // HUD
        this.ui=this.add.graphics().setDepth(10);
        this.uiText=this.add.text(16,12,'',{fontFamily:FONT,fontSize:16,color:'#ffffff'}).setStroke('#111',4).setShadow(2,2,'#000',4).setDepth(10);
        this.statusText=this.add.text(width/2,12,'',{fontFamily:FONT,fontSize:16,color:'#ffffff'}).setOrigin(0.5).setStroke('#111',4).setShadow(2,2,'#000',4).setDepth(10);
        this.poopText=this.add.text(0,0,'',{fontFamily:FONT,fontSize:14,color:'#ffffff'}).setOrigin(1,0).setStroke('#111',4).setShadow(2,2,'#000',4).setDepth(10);
        this.stomachText=this.add.text(0,0,'',{fontFamily:FONT,fontSize:14,color:'#ffffff'}).setOrigin(1,0).setStroke('#111',4).setShadow(2,2,'#000',4).setDepth(10);

        // Input
        this.cursors=this.input.keyboard.createCursorKeys(); this.wasd=this.input.keyboard.addKeys('W,A,S,D');
        this.keySpace=this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
        this.keyS=this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
        this.keyN=this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.N);
        this.keyT=this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.T);
        this.pointerTarget=null; this.pointerMarker=this.add.circle(0,0,8,0x000000,0.25).setVisible(false).setDepth(9);
        const setPointerTarget=(p)=>{ this.pointerTarget={x:p.worldX,y:p.worldY}; this.pointerMarker.setPosition(this.pointerTarget.x,this.pointerTarget.y).setVisible(true); };
        this.input.on('pointerdown',setPointerTarget); this.input.on('pointermove',(p)=>{ if(p.isDown) setPointerTarget(p); });

        // Raccolta bonus
        this.physics.add.overlap(this.player,this.seaBonuses,(player,b)=>{
          if(b.type==='narwhal'){ GameState.hasNarwhal=true; SFX.narwhal(); Haptics.bonusPickup(); }
          if(b.type==='siren'){   GameState.hasSiren=true;   SFX.siren(); Haptics.bonusPickup(); }
          if(b.type==='tornado'){ GameState.hasTornado=true; SFX.tornado(); Haptics.bonusPickup(); }
          if(b.type==='crab'){    GameState.crabsFriendly=true; SFX.crab(); Haptics.bonusPickup(); this.onCrabsBefriend(); }
          this.tweens.add({targets:b,angle:360,scale:1.5,duration:240,onComplete:()=>b.destroy()});
        });

        // Granchi (solo spiaggia)
        this.crabs=[]; this.crabGfx=this.add.graphics().setDepth(4); this.CRAB_VISION_R=28;
        this.spawnCrabs(6);

        // Toolbar DOM ‚Üí metodi scena
        wireToolbarToSeaScene(this);

        // Resize HUD
        this.scale.on('resize', ({width:W,height:H})=>{ this.statusText.setPosition(W/2,12); });
      }
      scheduleNextCurrentChange(){
        const nextMs=Phaser.Math.Between(12000,20000);
        this._cloudTimer1=this.time.delayedCall(nextMs-2500,()=>{ if(!this.currentFrozen) this.cloud.setVisible(true); });
        this._cloudTimer2=this.time.delayedCall(nextMs,()=>{ if(this.currentFrozen){ this.cloud.setVisible(false); this.scheduleNextCurrentChange(); return; } this.currentAngle=Phaser.Math.FloatBetween(-Math.PI,Math.PI); this.cloud.setVisible(false); this.scheduleNextCurrentChange(); });
      }
      spawnSeaBonus(type, bottomMargin=110){
        const {width,height}=this.scale;
        const x=Phaser.Math.Between(40,width-40), y=Phaser.Math.Between(this.beachBottomY+70, Math.max(this.beachBottomY+120, height-bottomMargin-20));
        const frameKey = type==='narwhal'? 'bonus_narwhal' : type==='siren'? 'bonus_siren' : 'bonus_tornado';
        let b=this.add.image(x,y,SPRITE.NAME,MAP[frameKey][0]).setScale(0.9).setDepth(6);
        this.physics.add.existing(b); b.body.setCircle(26).setOffset(-26,-26); b.body.setImmovable(true); b.type=type; this.seaBonuses.add(b);
      }
      spawnCrabBonus(){
        const { width } = this.scale;
        const x=Phaser.Math.Between(40,width-40), y=Phaser.Math.Between(24, this.beachBottomY-24);
        let b=this.add.image(x,y,SPRITE.NAME,MAP.crab_bonus[0]).setScale(0.9).setDepth(6);
        this.physics.add.existing(b); b.body.setCircle(26).setOffset(-26,-26); b.body.setImmovable(true); b.type='crab'; this.seaBonuses.add(b);
      }
      spawnCrabs(n=6){
        for(let i=0;i<n;i++){
          const x=Phaser.Math.Between(20,this.scale.width-20);
          const y=Phaser.Math.Between(12,this.beachBottomY-12);
          let t=this.add.sprite(x,y,SPRITE.NAME,MAP.crab_walk[0]).play('crab_walk').setDepth(6);
          this.physics.add.existing(t); t.body.setCircle(12).setCollideWorldBounds(true);
          const crab={ sprite:t, dir:Phaser.Math.FloatBetween(-Math.PI,Math.PI), speed:34, changeAt:0, friend:false };
          this.crabs.push(crab);
        }
      }
      onCrabsBefriend(){ this.crabs.forEach(c=>c.friend=true); }

      triggerNarwhal(){ if(!GameState.hasNarwhal) return; const ak='bonus_narwhal'; let n=this.add.image(this.player.x,this.player.y,SPRITE.NAME,MAP[ak][0]).setDepth(7); n._speed=90; n._target=this.nearestPoop(n); this.narwhals.push(n); GameState.hasNarwhal=false; SFX.narwhal(); Haptics.bonusUse(); }
      triggerSiren(){ if(!GameState.hasSiren) return; GameState.hasSiren=false; let siren=this.add.image(this.player.x,this.player.y,SPRITE.NAME,MAP.bonus_siren[0]).setDepth(7); this.lifeguard.distractedUntil=this.time.now+15000; this.time.delayedCall(15000,()=>siren.destroy()); SFX.siren(); Haptics.bonusUse(); }
      triggerTornado(){ if(!GameState.hasTornado) return; GameState.hasTornado=false; this.tornado={x:this.player.x,y:this.player.y,until:this.time.now+15000}; SFX.tornado(); Haptics.bonusUse(); }
      dropPoop(){ if(GameState.poopMeter<=0) return; const chunk=Math.min(GameState.poopMeter,0.2); GameState.poopMeter=Math.max(0,GameState.poopMeter-chunk); const p=this.add.text(this.player.x,this.player.y,'üí©',{fontFamily:FONT,fontSize:20}).setDepth(8); p._tDrop=this.time.now; p._ttlMs=60000; p._stranded=false; p._label=this.add.text(p.x,p.y-18,'60',{fontFamily:FONT,fontSize:12,color:'#001'}).setOrigin(0.5).setDepth(8); this.poops.add(p); SFX.drop(); }

      nearestPoop(from){ let best=null, dBest=1e9; this.poops.getChildren().forEach(p=>{ if(!p.active) return; const d=Phaser.Math.Distance.Between(from.x,from.y,p.x,p.y); if(d<dBest){ best=p; dBest=d; } }); return best; }

      update(time,delta){
        const dt=delta/1000, {width,height}=this.scale;
        const body=this.player.body; body.setVelocity(0);

        const onBeach=(this.player.y <= this.beachBottomY);
        const speed=onBeach?150:120;
        if (this.cursors.left.isDown||this.wasd.A.isDown) body.setVelocityX(-speed); else if (this.cursors.right.isDown||this.wasd.D.isDown) body.setVelocityX(speed);
        if (this.cursors.up.isDown||this.wasd.W.isDown) body.setVelocityY(-speed); else if (this.cursors.down.isDown||this.wasd.S.isDown) body.setVelocityY(speed);
        if (this.pointerTarget){ const dx=this.pointerTarget.x-this.player.x, dy=this.pointerTarget.y-this.player.y, dist=Math.hypot(dx,dy); if(dist>6) body.setVelocity((dx/dist)*speed,(dy/dist)*speed); else { this.pointerTarget=null; this.pointerMarker.setVisible(false);} }

        // Corrente (solo acqua)
        const cx=Math.cos(this.currentAngle)*this.currentSpeed, cy=Math.sin(this.currentAngle)*this.currentSpeed;
        if(!onBeach){ body.velocity.x += cx; body.velocity.y += cy; }

        // Freccia corrente (verde chiaro + alta leggibilit√†)
        this.currentArrow.clear(); this.currentArrow.fillStyle(0x004411,0.12).fillCircle(40,40,18);
        this.currentArrow.lineStyle(5,0xa5e75a,0.98);
        const ax=40,ay=40, ex=ax+Math.cos(this.currentAngle)*32, ey=ay+Math.sin(this.currentAngle)*32;
        this.currentArrow.lineBetween(ax,ay,ex,ey);
        this.currentArrow.fillStyle(0xa5e75a,1);
        this.currentArrow.fillTriangle(ex,ey, ex-Math.cos(this.currentAngle+0.5)*10, ey-Math.sin(this.currentAngle+0.5)*10, ex-Math.cos(this.currentAngle-0.5)*10, ey-Math.sin(this.currentAngle-0.5)*10);

        // Bagnino sweep (giu')
        if(time>=this.lifeguard.distractedUntil){
          this.lifeguard.dir += this.lifeguard.speed*dt;
          if(this.lifeguard.dir>this.lifeguard.sweepMax || this.lifeguard.dir<this.lifeguard.sweepMin){
            this.lifeguard.speed*=-1;
            this.lifeguard.dir=Phaser.Math.Clamp(this.lifeguard.dir,this.lifeguard.sweepMin,this.lifeguard.sweepMax);
          }
        }

        // Nuotatori: solo mare
        for(const s of this.swimmers){
          if(time>s.changeAt){ s.dir=Phaser.Math.FloatBetween(-Math.PI,Math.PI); s.changeAt=time+Phaser.Math.Between(1200,2600); }
          let vx=Math.cos(s.dir)*s.speed + cx, vy=Math.sin(s.dir)*s.speed + cy;
          const nextY=s.sprite.y + vy*dt;
          if(nextY < this.beachBottomY+20){ vy = Math.abs(vy); s.dir = Math.abs(s.dir); }
          s.sprite.body.setVelocity(vx,vy);
          if(!sheetOK(this) && s.limbs){ const moving=Math.hypot(vx,vy)>5; updateLimbs(s.limbs,s.sprite.x,s.sprite.y,moving,time/1000); }
        }

        // Tornado
        if(this.tornado && time>=this.tornado.until){ this.tornado=null; this.tornadoGfx.clear(); }
        this.tornadoGfx.clear();
        if(this.tornado){ this.tornadoGfx.lineStyle(3,0x00695c,0.9); this.tornadoGfx.strokeCircle(this.tornado.x,this.tornado.y,24); this.tornadoGfx.strokeCircle(this.tornado.x,this.tornado.y,12); this.tornadoGfx.strokeCircle(this.tornado.x,this.tornado.y,36); }

        // Narvali (pulizia üí©)
        for(const n of this.narwhals){
          if(!n.active) continue;
          if(!n._target || !n._target.active) n._target=this.nearestPoop(n);
          if(n._target){
            const dx=n._target.x-n.x, dy=n._target.y-n.y, d=Math.hypot(dx,dy)||1;
            n.x += (dx/d)*n._speed*dt + cx*dt; n.y += (dy/d)*n._speed*dt + cy*dt;
            if(d<10 && n._target.active){ n._target._label?.destroy(); n._target.destroy(); n._target=this.nearestPoop(n); SFX.narwhal(); }
          } else { n.x+=cx*dt; n.y+=cy*dt; n._despawnAt=n._despawnAt||(time+2000); if(time>=n._despawnAt) n.destroy(); }
        }

        // üí©: si arena su spiaggia
        this.poops.getChildren().forEach(p=>{
          const nowOnBeach = (p.y <= this.beachBottomY);
          if(!p._stranded && !nowOnBeach){ p.x += cx*dt; p.y += cy*dt; }
          if(nowOnBeach) p._stranded=true;
          p._label?.setPosition(p.x,p.y-18);
          const left=Math.max(0,Math.ceil((p._ttlMs - (time - p._tDrop))/1000)); p._label?.setText(left.toString());
          if(left<=0 && p.active){ p._label?.destroy(); p.destroy(); }
          p.x=Phaser.Math.Clamp(p.x,8,width-8);
          p.y=Phaser.Math.Clamp(p.y,60,height-8);
        });

        // Granchi (solo spiaggia) + visione circolare
        this.crabGfx.clear();
        for(const c of this.crabs){
          if(time>c.changeAt){ c.dir=Phaser.Math.FloatBetween(-Math.PI,Math.PI); c.changeAt=time+Phaser.Math.Between(1000,2200); }
          let vx=Math.cos(c.dir)*c.speed, vy=Math.sin(c.dir)*c.speed;
          const nx=c.sprite.x+vx*dt, ny=c.sprite.y+vy*dt;
          if(ny > this.beachBottomY-10){ vy = -Math.abs(vy); c.dir = -Math.abs(c.dir); }
          c.sprite.x = Phaser.Math.Clamp(nx,16,width-16);
          c.sprite.y = Phaser.Math.Clamp(c.sprite.y + vy*dt, 12, this.beachBottomY-12);

          this.crabGfx.lineStyle(1, c.friend?0x2e7d32:0xaa5500, 0.65);
          this.crabGfx.strokeCircle(c.sprite.x, c.sprite.y, this.CRAB_VISION_R);

          if(c.friend){
            const target=this.nearestPoop(c.sprite);
            if(target && target._stranded){
              const dx=target.x-c.sprite.x, dy=target.y-c.sprite.y, d=Math.hypot(dx,dy)||1;
              c.sprite.x += (dx/d)*50*dt; c.sprite.y += (dy/d)*50*dt;
              if(d<12 && target.active){ target._label?.destroy(); target.destroy(); SFX.crab(); }
            }
          }
        }

        // Visione: bagnino + nuotatori (coni)
        this.visionGfx.clear();
        this.drawCone(this.visionGfx,this.lifeguard.x,this.lifeguard.y,this.lifeguard.dir,this.lifeguard.fov,this.lifeguard.range,0xff0000,0.15);
        for(const s of this.swimmers){ this.drawCone(this.visionGfx,s.sprite.x,s.sprite.y,s.dir,s.fov,s.range,0xff8800,0.12); }

        // Sconfitta
        if(this.isAnyPoopDetected()){ SFX.lose(); Haptics.lose(); resetForNewRun(); this.scene.start('LoseScene',{reason:'detected'}); return; }
        // Vittoria
        if(GameState.poopMeter<=0 && this.poops.countActive(true)===0){ SFX.win(); Haptics.win(); resetForNewRun(); this.scene.start('WinScene'); return; }

        // HUD destre
        const barW=220, barH=22, pad=16, xRight=width-barW-pad;
        this.ui.clear();
        drawProgressBar(this.ui,xRight,12,barW,barH,GameState.poopMeter,0x9b5a1a);
        drawProgressBar(this.ui,xRight,12+barH+6,barW,barH,GameState.stomach,0xcc3333);
        this.poopText.setPosition(xRight+barW,12).setText(`Pup√π: ${Math.round(GameState.poopMeter*100)}%`);
        this.stomachText.setPosition(xRight+barW,12+barH+6).setText(`Mal di pancia: ${Math.round(GameState.stomach*100)}%`);

        const status=[ GameState.hasNarwhal?'Narvalo pronto':'Narvalo no', GameState.hasSiren?'Sirena pronta':'Sirena no', GameState.hasTornado?'Tornado pronto':'Tornado no', GameState.crabsFriendly?'Granchi amici':'Granchi neutrali' ];
        const distractLeft=Math.max(0,Math.ceil((this.lifeguard.distractedUntil-time)/1000));
        this.uiText.setText(`Cacchette: ${this.poops.countActive(true)}`);
        this.statusText.setText(status.join('  ‚Ä¢  ')+(distractLeft>0?`  ‚Ä¢  Bagnino distratto: ${distractLeft}s`:'' ));

        // Scorciatoie
        if(Phaser.Input.Keyboard.JustDown(this.keySpace)) this.dropPoop();
        if(Phaser.Input.Keyboard.JustDown(this.keyS)) this.triggerSiren();
        if(Phaser.Input.Keyboard.JustDown(this.keyN)) this.triggerNarwhal();
        if(Phaser.Input.Keyboard.JustDown(this.keyT)) this.triggerTornado();

        if(!sheetOK(this) && this.playerLimbs){ const moving=body.velocity.length()>5; updateLimbs(this.playerLimbs,this.player.x,this.player.y,moving,time/1000); }
      }

      drawCone(gfx,x,y,dir,fov,range,color,alpha){
        gfx.fillStyle(color,alpha);
        const a1=dir-fov/2, a2=dir+fov/2, p1={x:x+Math.cos(a1)*range,y:y+Math.sin(a1)*range}, p2={x:x+Math.cos(a2)*range,y:y+Math.sin(a2)*range};
        gfx.beginPath(); gfx.moveTo(x,y); gfx.lineTo(p1.x,p1.y); gfx.arc(x,y,range,a1,a2); gfx.lineTo(x,y); gfx.closePath(); gfx.fillPath();
      }
      isAnyPoopDetected(){
        for(const p of this.poops.getChildren()){
          if(!p.active) continue;
          if(this.inCone({x:this.lifeguard.x,y:this.lifeguard.y}, this.lifeguard.dir,this.lifeguard.fov,this.lifeguard.range, p)) return true;
          for(const s of this.swimmers){ if(this.inCone({x:s.sprite.x,y:s.sprite.y}, s.dir,s.fov,s.range, p)) return true; }
        }
        if(!GameState.crabsFriendly){
          for(const c of this.crabs){
            for(const p of this.poops.getChildren()){
              if(!p.active) continue;
              const d=Phaser.Math.Distance.Between(c.sprite.x,c.sprite.y,p.x,p.y);
              if(d <= this.CRAB_VISION_R) return true;
            }
          }
        }
        return false;
      }
      inCone(o,dir,fov,range,p){ const dx=p.x-o.x, dy=p.y-o.y, dist=Math.hypot(dx,dy); if(dist>range) return false; const ang=Math.atan2(dy,dx); let diff=ang-dir; diff=Math.atan2(Math.sin(diff),Math.cos(diff)); return Math.abs(diff)<=fov/2; }
    }

    /* ---------------- Win/Lose ---------------- */
    class LoseScene extends Phaser.Scene{
      constructor(){ super('LoseScene'); }
      create(data){
        hideToolbar();
        const {width,height}=this.scale; this.cameras.main.setBackgroundColor('#222');
        let title='Ops! Sei stato scoperto! üö®';
        if(data?.reason==='overeat'||data?.reason==='stomachache'){ title='Oh no! Hai mangiato troppo e ti sei fatto cacca addosso! üí•üí©'; }
        this.add.text(width/2,height/2-40,title,{fontFamily:FONT,fontSize:24,color:'#fff',align:'center',wordWrap:{width:Math.min(600,width-40)}}).setOrigin(0.5);
        this.add.text(width/2-130,height-60,'‚¨Ö Menu',{fontFamily:FONT,fontSize:22,color:'#fff',backgroundColor:'#444',padding:{left:10,right:10,top:6,bottom:6}})
          .setOrigin(0.5).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ resetForNewRun(); this.scene.start('MenuScene'); });
        this.add.text(width/2+130,height-60,'‚ü≤ Riprova',{fontFamily:FONT,fontSize:22,color:'#fff',backgroundColor:'#444',padding:{left:10,right:10,top:6,bottom:6}})
          .setOrigin(0.5).setInteractive({useHandCursor:true}).on('pointerdown',()=>{ resetForNewRun(); this.scene.start('LandScene'); });
      }
    }
    class WinScene extends Phaser.Scene{
      constructor(){ super('WinScene'); }
      create(){
        hideToolbar();
        const {width,height}=this.scale; this.cameras.main.setBackgroundColor('#1b5e20');
        this.add.text(width/2, height/2 - 40, 'Ce l\'hai fatta! ü§´üåä', { fontFamily:FONT, fontSize: 28, color:'#ffffff' }).setOrigin(0.5);
        this.add.text(width/2, height/2 + 10, 'Nessuno ha scoperto nulla. Bravo stratega!', { fontFamily:FONT, fontSize: 16, color:'#e8f5e9' }).setOrigin(0.5);
        this.add.text(width/2 - 130, height - 60, '‚¨Ö Menu', { fontFamily:FONT, fontSize:22, color:'#fff', backgroundColor:'#2e7d32', padding:{left:10,right:10,top:6,bottom:6} })
          .setOrigin(0.5).setInteractive({useHandCursor:true}).on('pointerdown', ()=>{ resetForNewRun(); this.scene.start('MenuScene'); });
        this.add.text(width/2 + 130, height - 60, '‚ü≤ Gioca ancora', { fontFamily:FONT, fontSize:22, color:'#fff', backgroundColor:'#2e7d32', padding:{left:10,right:10,top:6,bottom:6} })
          .setOrigin(0.5).setInteractive({useHandCursor:true}).on('pointerdown', ()=>{ resetForNewRun(); this.scene.start('LandScene'); });
      }
    }

    /* ---------------- DOM/Boot helpers ---------------- */
    function setupAudioUnlock(){
      const gate=document.getElementById('audio-gate'), btn=document.getElementById('audio-btn');
      if(!gate||!btn) return;
      gate.style.display='flex';
      const unlock=()=>{ try{ ensureAudioContext().resume(); }catch{} gate.style.display='none'; window.removeEventListener('pointerdown',unlock); };
      btn.addEventListener('click',unlock); window.addEventListener('pointerdown',unlock,{once:true});
    }
    function showToolbar(){ const el=document.getElementById('toolbar'); if(el) el.style.display='flex'; }
    function hideToolbar(){ const el=document.getElementById('toolbar'); if(el) el.style.display='none'; }
    function wireToolbarToSeaScene(scene){
      const g=window.PooPooPanda._game;
      const btn=(id)=>document.getElementById(id);
      const call=(fn)=>()=>{ const s=g?.scene?.getScene('SeaScene'); if(!s||!s.scene.isActive()) return; fn(s); };
      btn('btn-menu').onclick    = call(s=>{ resetForNewRun(); s.scene.start('MenuScene'); SFX.button(); });
      btn('btn-restart').onclick = call(s=>{ resetForNewRun(); s.scene.start('LandScene'); SFX.button(); });
      btn('btn-poop').onclick    = call(s=>{ s.dropPoop(); SFX.drop(); });
      btn('btn-narwhal').onclick = call(s=>{ s.triggerNarwhal(); Haptics.bonusUse(); });
      btn('btn-siren').onclick   = call(s=>{ s.triggerSiren();  Haptics.bonusUse(); });
      btn('btn-tornado').onclick = call(s=>{ s.triggerTornado();Haptics.bonusUse(); });
    }

    function labelForFood(foodType){ switch(foodType){ case Foods.BAMBOO:return 'üéã Bamboo'; case Foods.PASTA:return 'üçù Pasta'; case Foods.PIZZA:return 'üçï Pizza'; case Foods.GELATO:return 'üç¶ Gelato'; default:return 'Cibo'; } }
    function colorForFood(foodType){ switch(foodType){ case Foods.BAMBOO:return '#1f7a1f'; case Foods.PASTA:return '#7a5d1f'; case Foods.PIZZA:return '#a83232'; case Foods.GELATO:return '#7a1f6a'; default:return '#333'; } }

    function randomPointAvoiding(center,minDist,bounds){
      const maxTry=50;
      for(let i=0;i<maxTry;i++){
        const x=Math.floor(Math.random()*(bounds.xMax-bounds.xMin+1))+bounds.xMin;
        const y=Math.floor(Math.random()*(bounds.yMax-bounds.yMin+1))+bounds.yMin;
        const dx=x-center.x, dy=y-center.y; if(Math.hypot(dx,dy)>=minDist) return {x,y};
      }
      return {x:bounds.xMin,y:bounds.yMin};
    }

    function createGame(parent='game-container'){
      setupAudioUnlock();
      const config={
        type: Phaser.AUTO, width: 960, height: 540, backgroundColor:'#0d1117', parent,
        scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
        physics:{ default:'arcade', arcade:{ gravity:{y:0}, debug:false } },
        scene:[BootScene,MenuScene,LandScene,SeaScene,LoseScene,WinScene]
      };
      return new Phaser.Game(config);
    }

    // API minima per integrazioni (Unity WebView, ecc.)
    window.PooPooPanda={ createGame };

    window.addEventListener('DOMContentLoaded', ()=>{
      const el=document.getElementById('game-container');
      if(el) window.PooPooPanda._game=createGame('game-container');
      wireToolbarToSeaScene();
    });
  </script>
</body>
</html>
